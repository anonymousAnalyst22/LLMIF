///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V10.10.1.4655 for 8051              22/Nov/2023  15:42:43
// Copyright 2004-2017 IAR Systems AB.
// Standalone license - IAR Embedded Workbench for 8051
//
//    Core               =  plain
//    Code model         =  banked
//    Data model         =  large
//    Calling convention =  xdata reentrant
//    Constant location  =  data_rom
//    Dptr setup         =  1,16
//                          
//    Source file        =  
//        D:\fuzzing-coordinator-response-collection\Components\mt\MT_SYS.c
//    Command line       =  
//        -f C:\Users\ADMINI~1\AppData\Local\Temp\EWA84B.tmp
//        (D:\fuzzing-coordinator-response-collection\Components\mt\MT_SYS.c -D
//        SECURE=1 -D TC_LINKKEY_JOIN -D NV_INIT -D NV_RESTORE -D
//        MULTICAST_ENABLED=FALSE -D ZCL_READ -D ZCL_DISCOVER -D ZCL_WRITE -D
//        ZCL_BASIC -D ZCL_IDENTIFY -D ISR_KEYINTERRUPT -D HAL_UART=TRUE -D
//        HAL_LCD=FALSE -D ZCL_ON_OFF -D INT_HEAP_LEN=2800 -D
//        HAL_UART_DMA_RX_MAX=256 -D HAL_UART_DMA_TX_MAX=256 -lC
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\CoordinatorEB\List
//        -lA
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\CoordinatorEB\List
//        --diag_suppress Pe001,Pa010 -o
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\CoordinatorEB\Obj
//        -e --debug --core=plain --dptr=16,1 --data_model=large
//        --code_model=banked --calling_convention=xdata_reentrant
//        --place_constants=data_rom --nr_virtual_regs 8 -f
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg
//        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
//        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
//        -DZDO_COORDINATOR -DRTR_NWK) -f
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg
//        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
//        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
//        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
//        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
//        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
//        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
//        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
//        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
//        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
//        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x00, 0x01, 0x02, 0x03,
//        0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
//        0x0F}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
//        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
//        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
//        -DREJOIN_POLL_RATE=440 -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000
//        -DENABLE_LED4_DISABLE_S1) -f
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\Source\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\Source\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\ZMain\TI2530DB\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\include\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\include\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\high_level\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mt\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\osal\include\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\services\saddr\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\services\sdata\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\af\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\bdb\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\gp\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\nwk\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sapi\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sec\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sys\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\zcl\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\zdo\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\zmac\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\zmac\f8w\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\Common\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\SPI\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\HW_LCD\Font\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\HW_LCD\HAL_LCD_SPI\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\HW_LCD\HAL_OLED\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\HW_LCD\HAL_TFT\
//        -Ohz --require_prototypes)
//    Locale             =  Chinese (Simplified)_China.936
//    List file          =  
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\CoordinatorEB\List\MT_SYS.s51
//
///////////////////////////////////////////////////////////////////////////////

        NAME MT_SYS

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__register_banks", "*"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ?V0
        EXTERN ?V1
        EXTERN ?V2
        EXTERN ?ALLOC_XSTACK8
        EXTERN ?BANKED_ENTER_XDATA
        EXTERN ?BANKED_LEAVE_XDATA
        EXTERN ?BDISPATCH
        EXTERN ?DEALLOC_XSTACK8
        EXTERN ?PUSH_XSTACK_I_THREE
        EXTERN ?XSP
        EXTERN ?XSTACK_DISP0_8

        PUBLIC `??MT_SysOsalTimerExpired::?relay`
        FUNCTION `??MT_SysOsalTimerExpired::?relay`,0203H
        PUBLIC `??MT_SysResetInd::?relay`
        FUNCTION `??MT_SysResetInd::?relay`,0203H
        PUBLIC MT_SysOsalTimerExpired
        FUNCTION MT_SysOsalTimerExpired,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 10, STACK
        PUBLIC MT_SysResetInd
        FUNCTION MT_SysResetInd,0a1203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 20, STACK
        PUBWEAK SLEEPSTA
        
          CFI Names cfiNames0
          CFI StackFrame CFA_SP SP IDATA
          CFI StackFrame CFA_PSP16 PSP16 XDATA
          CFI StackFrame CFA_XSP16 XSP16 XDATA
          CFI StaticOverlayFrame CFA_IOVERLAY IOVERLAY
          CFI StaticOverlayFrame CFA_DOVERLAY DOVERLAY
          CFI Resource `PSW.CY`:1, `B.BR0`:1, `B.BR1`:1, `B.BR2`:1, `B.BR3`:1
          CFI Resource `B.BR4`:1, `B.BR5`:1, `B.BR6`:1, `B.BR7`:1, `VB.BR8`:1
          CFI Resource `VB.BR9`:1, `VB.BR10`:1, `VB.BR11`:1, `VB.BR12`:1
          CFI Resource `VB.BR13`:1, `VB.BR14`:1, `VB.BR15`:1, VB:8, B:8, A:8
          CFI Resource PSW:8, DPL0:8, DPH0:8, R0:8, R1:8, R2:8, R3:8, R4:8, R5:8
          CFI Resource R6:8, R7:8, V0:8, V1:8, V2:8, V3:8, V4:8, V5:8, V6:8, V7:8
          CFI Resource SP:8, PSPH:8, PSPL:8, PSP16:16, XSPH:8, XSPL:8, XSP16:16
          CFI VirtualResource ?RET:24
          CFI Resource ?BRET_EXT:8
          CFI VirtualResource ?RET_HIGH:8, ?RET_LOW:8
          CFI ResourceParts PSP16 PSPH, PSPL
          CFI ResourceParts XSP16 XSPH, XSPL
          CFI ResourceParts ?RET ?BRET_EXT, ?RET_HIGH, ?RET_LOW
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 1
          CFI DataAlign -1
          CFI ReturnAddress ?RET CODE
          CFI CFA_DOVERLAY Used
          CFI CFA_IOVERLAY Used
          CFI CFA_SP SP+-3
          CFI CFA_PSP16 PSP16+0
          CFI CFA_XSP16 XSP16+0
          CFI `PSW.CY` SameValue
          CFI `B.BR0` SameValue
          CFI `B.BR1` SameValue
          CFI `B.BR2` SameValue
          CFI `B.BR3` SameValue
          CFI `B.BR4` SameValue
          CFI `B.BR5` SameValue
          CFI `B.BR6` SameValue
          CFI `B.BR7` SameValue
          CFI `VB.BR8` SameValue
          CFI `VB.BR9` SameValue
          CFI `VB.BR10` SameValue
          CFI `VB.BR11` SameValue
          CFI `VB.BR12` SameValue
          CFI `VB.BR13` SameValue
          CFI `VB.BR14` SameValue
          CFI `VB.BR15` SameValue
          CFI VB SameValue
          CFI B Undefined
          CFI A Undefined
          CFI PSW SameValue
          CFI DPL0 SameValue
          CFI DPH0 SameValue
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 Undefined
          CFI R5 Undefined
          CFI R6 SameValue
          CFI R7 SameValue
          CFI V0 SameValue
          CFI V1 SameValue
          CFI V2 SameValue
          CFI V3 SameValue
          CFI V4 SameValue
          CFI V5 SameValue
          CFI V6 SameValue
          CFI V7 SameValue
          CFI PSPH Undefined
          CFI PSPL Undefined
          CFI XSPH Undefined
          CFI XSPL Undefined
          CFI ?RET Concat
          CFI ?BRET_EXT Frame(CFA_SP, 3)
          CFI ?RET_HIGH Frame(CFA_SP, 2)
          CFI ?RET_LOW Frame(CFA_SP, 1)
          CFI EndCommon cfiCommon0
        
MT_BuildAndSendZToolResponse SYMBOL "MT_BuildAndSendZToolResponse"
`??MT_BuildAndSendZToolResponse::?relay` SYMBOL "?relay", MT_BuildAndSendZToolResponse
osal_memcpy         SYMBOL "osal_memcpy"
`??osal_memcpy::?relay` SYMBOL "?relay", osal_memcpy
MT_SysOsalTimerExpired SYMBOL "MT_SysOsalTimerExpired"
`??MT_SysOsalTimerExpired::?relay` SYMBOL "?relay", MT_SysOsalTimerExpired
MT_SysResetInd      SYMBOL "MT_SysResetInd"
`??MT_SysResetInd::?relay` SYMBOL "?relay", MT_SysResetInd

        EXTERN `??MT_BuildAndSendZToolResponse::?relay`
        FUNCTION `??MT_BuildAndSendZToolResponse::?relay`,00H
        EXTERN `??osal_memcpy::?relay`
        FUNCTION `??osal_memcpy::?relay`,00H
        EXTERN MTVersionString
        EXTERN MT_BuildAndSendZToolResponse
        FUNCTION MT_BuildAndSendZToolResponse,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN osal_memcpy
        FUNCTION osal_memcpy,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC

// D:\fuzzing-coordinator-response-collection\Components\mt\MT_SYS.c
//    1 /******************************************************************************
//    2   Filename:       MT_SYS.c
//    3   Revised:        $Date: 2015-02-09 19:10:05 -0800 (Mon, 09 Feb 2015) $
//    4   Revision:       $Revision: 42469 $
//    5 
//    6   Description:   MonitorTest functions for SYS commands.
//    7 
//    8   Copyright 2007-2015 Texas Instruments Incorporated. All rights reserved.
//    9 
//   10   IMPORTANT: Your use of this Software is limited to those specific rights
//   11   granted under the terms of a software license agreement between the user
//   12   who downloaded the software, his/her employer (which must be your employer)
//   13   and Texas Instruments Incorporated (the "License"). You may not use this
//   14   Software unless you agree to abide by the terms of the License. The License
//   15   limits your use, and you acknowledge, that the Software may not be modified,
//   16   copied or distributed unless embedded on a Texas Instruments microcontroller
//   17   or used solely and exclusively in conjunction with a Texas Instruments radio
//   18   frequency transceiver, which is integrated into your product. Other than for
//   19   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   20   works of, modify, distribute, perform, display or sell this Software and/or
//   21   its documentation for any purpose.
//   22 
//   23   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   24   PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   25   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   26   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   27   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   28   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   29   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   30   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   31   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   32   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   33   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   34 
//   35   Should you have any questions regarding your right to use this Software,
//   36   contact Texas Instruments Incorporated at www.TI.com.
//   37 
//   38  *****************************************************************************/
//   39 
//   40 /******************************************************************************
//   41  * INCLUDES
//   42  *****************************************************************************/
//   43 #include "ZComDef.h"
//   44 #include "MT.h"
//   45 #include "MT_SYS.h"
//   46 #include "MT_VERSION.h"
//   47 #include "OSAL.h"
//   48 #include "OSAL_NV.h"
//   49 #include "Onboard.h"

        ASEGN SFR_AN:DATA:NOROOT,09dH
// unsigned char volatile __sfr SLEEPSTA
SLEEPSTA:
        DATA8
        DS 1
//   50 #include "OSAL_Clock.h"
//   51 #include "mac_low_level.h"
//   52 #include "ZMAC.h"
//   53 #include "MT_UART.h"
//   54 
//   55 #if !defined( CC26XX )
//   56   #include "hal_adc.h"
//   57 #endif
//   58 #if !defined( CC253X_MACNP )
//   59   #include "ZGlobals.h"
//   60 #endif
//   61 #if defined( FEATURE_NVEXID )
//   62   #include "zstackconfig.h"
//   63 #endif
//   64 #if defined( FEATURE_DUAL_MAC )
//   65   #include "dmmgr.h"
//   66 #endif
//   67 #if defined( FEATURE_SYSTEM_STATS )
//   68 #include "ZDiags.h"
//   69 #endif
//   70 #if defined( MT_SYS_JAMMER_FEATURE )
//   71   #include "mac_rx.h"
//   72   #include "mac_radio_defs.h"
//   73 #endif
//   74 #if (defined INCLUDE_REVISION_INFORMATION) && ((defined MAKE_CRC_SHDW) || (defined FAKE_CRC_SHDW)) //built for bootloader
//   75   #include "hal_flash.h"
//   76   #include "sb_shared.h"
//   77 #endif
//   78 
//   79 /******************************************************************************
//   80  * MACROS
//   81  *****************************************************************************/
//   82 
//   83 /* RPC_CMD responses for MT_SYS commands */
//   84 #define MT_ARSP_SYS ((uint8)MT_RPC_CMD_AREQ | (uint8)MT_RPC_SYS_SYS)
//   85 #define MT_SRSP_SYS ((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS)
//   86 
//   87 /* Max possible MT response length, limited by TX buffer and sizeof uint8 */
//   88 #define MT_MAX_RSP_LEN  ( MIN( MT_UART_DEFAULT_MAX_TX_BUFF, 255 ) )
//   89 
//   90 /* Max possible MT response data length, MT protocol overhead */
//   91 #define MT_MAX_RSP_DATA_LEN  ( (MT_MAX_RSP_LEN - 1) - SPI_0DATA_MSG_LEN )
//   92 
//   93 #define MT_SYS_DEVICE_INFO_RESPONSE_LEN 14
//   94 
//   95 #if !defined HAL_GPIO || !HAL_GPIO
//   96 #define GPIO_DIR_IN(IDX)
//   97 #define GPIO_DIR_OUT(IDX)
//   98 #define GPIO_TRI(IDX)
//   99 #define GPIO_PULL_UP(IDX)
//  100 #define GPIO_PULL_DN(IDX)
//  101 #define GPIO_SET(IDX)
//  102 #define GPIO_CLR(IDX)
//  103 #define GPIO_TOG(IDX)
//  104 #define GPIO_GET(IDX) 0
//  105 #define GPIO_HiD_SET() (val = 0)
//  106 #define GPIO_HiD_CLR() (val = 0)
//  107 #endif
//  108 
//  109 #if defined ( MT_SYS_SNIFFER_FEATURE )
//  110 #if defined ( HAL_MCU_CC2530 ) && !defined ( HAL_BOARD_CC2530USB )
//  111   // This only works with CC253x chips
//  112   #define HAL_BOARD_ENABLE_INTEGRATED_SNIFFER() st         \ 
//  113   (                                                                                                                                                                                                                                   \ 
//  114     OBSSEL3 = 0xFD;                                        \ 
//  115     OBSSEL4 = 0xFC;                                        \ 
//  116     RFC_OBS_CTRL1 = 0x09; /* 9 - sniff clk */              \ 
//  117     RFC_OBS_CTRL2 = 0x08; /* 8 - sniff data */             \ 
//  118     MDMTEST1 |= 0x04;                                      \ 
//  119   )
//  120 
//  121   // This only works with CC253x chips
//  122   #define HAL_BOARD_DISABLE_INTEGRATED_SNIFFER() st        \ 
//  123   (                                                                                                                                                                                                                                   \ 
//  124     OBSSEL3 &= ~0x80;                                                                                                                                                                             \ 
//  125     OBSSEL4 &= ~0x80;                                                                                                                                                                             \ 
//  126     RFC_OBS_CTRL1 = 0x00; /* 0 - constant value 0 to rfc_obs_sigs[1] */                                                                                   \ 
//  127     RFC_OBS_CTRL2 = 0x00; /* 0 - constant value 0 to rfc_obs_sigs[2] */                                                                                   \ 
//  128     MDMTEST1 &= ~0x04;                                                                                                                                                         \ 
//  129   )
//  130 #else
//  131   #define HAL_BOARD_ENABLE_INTEGRATED_SNIFFER() { status = FAILURE; }
//  132   #define HAL_BOARD_DISABLE_INTEGRATED_SNIFFER() { status = FAILURE; }
//  133 #endif
//  134 #endif // MT_SYS_SNIFFER_FEATURE
//  135 
//  136 #define RESET_HARD     0
//  137 #define RESET_SOFT     1
//  138 #define RESET_SHUTDOWN 2
//  139 
//  140 /******************************************************************************
//  141  * CONSTANTS
//  142  *****************************************************************************/
//  143 
//  144 #if !defined( MT_SYS_OSAL_NV_READ_CERTIFICATE_DATA )
//  145 #define MT_SYS_OSAL_NV_READ_CERTIFICATE_DATA  FALSE
//  146 #endif
//  147 
//  148 #if defined( MT_SYS_FUNC )
//  149 static const uint16 MT_SysOsalEventId[] =
//  150 {
//  151   MT_SYS_OSAL_EVENT_0,
//  152   MT_SYS_OSAL_EVENT_1,
//  153   MT_SYS_OSAL_EVENT_2,
//  154   MT_SYS_OSAL_EVENT_3
//  155 };
//  156 #endif
//  157 
//  158 typedef enum {
//  159   GPIO_DIR,
//  160   GPIO_TRI,
//  161   GPIO_SET,
//  162   GPIO_CLR,
//  163   GPIO_TOG,
//  164   GPIO_GET,
//  165   GPIO_HiD = 0x12
//  166 } GPIO_Op_t;
//  167 
//  168 #if defined( MT_SYS_JAMMER_FEATURE )
//  169   #define JAMMER_CHECK_EVT                           0x0001
//  170 
//  171   #if !defined( JAMMER_DETECT_CONTINUOUS_EVENTS )
//  172     #define JAMMER_DETECT_CONTINUOUS_EVENTS          150
//  173   #endif
//  174   #if !defined( JAMMER_DETECT_PERIOD_TIME )
//  175     #define JAMMER_DETECT_PERIOD_TIME                100  // In milliseconds
//  176   #endif
//  177   #if !defined( JAMMER_HIGH_NOISE_LEVEL )
//  178     #define JAMMER_HIGH_NOISE_LEVEL                  -65
//  179   #endif
//  180 #endif // MT_SYS_JAMMER_FEATURE
//  181 
//  182 /******************************************************************************
//  183  * EXTERNAL VARIABLES
//  184  *****************************************************************************/
//  185 #if defined( FEATURE_NVEXID )
//  186 extern zstack_Config_t *pZStackCfg;
//  187 #endif /* FEATURE_NVEXID */
//  188 
//  189 /******************************************************************************
//  190  * LOCAL VARIABLES
//  191  *****************************************************************************/
//  192 #if defined( MT_SYS_JAMMER_FEATURE )
//  193 static uint8 jammerTaskID;
//  194 static uint16 jammerContinuousEvents = JAMMER_DETECT_CONTINUOUS_EVENTS;
//  195 static uint16 jammerDetections = JAMMER_DETECT_CONTINUOUS_EVENTS;
//  196 static int8 jammerHighNoiseLevel = JAMMER_HIGH_NOISE_LEVEL;
//  197 static uint32 jammerDetectPeriodTime = JAMMER_DETECT_PERIOD_TIME;
//  198 #endif
//  199 
//  200 #if defined( MT_SYS_SNIFFER_FEATURE )
//  201 static uint8 sniffer = FALSE;
//  202 #endif
//  203 
//  204 /******************************************************************************
//  205  * LOCAL FUNCTIONS
//  206  *****************************************************************************/
//  207 #if defined( MT_SYS_FUNC )
//  208 static void MT_SysReset(uint8 *pBuf);
//  209 static void MT_SysPing(void);
//  210 static void MT_SysVersion(void);
//  211 static void MT_SysSetExtAddr(uint8 *pBuf);
//  212 static void MT_SysGetExtAddr(void);
//  213 static void MT_SysOsalStartTimer(uint8 *pBuf);
//  214 static void MT_SysOsalStopTimer(uint8 *pBuf);
//  215 static void MT_SysRandom(void);
//  216 static void MT_SysGpio(uint8 *pBuf);
//  217 static void MT_SysStackTune(uint8 *pBuf);
//  218 static void MT_SysSetUtcTime(uint8 *pBuf);
//  219 static void MT_SysGetUtcTime(void);
//  220 static void MT_SysSetTxPower(uint8 *pBuf);
//  221 #if !defined( CC26XX )
//  222 static void MT_SysAdcRead(uint8 *pBuf);
//  223 #endif /* !CC26xx */
//  224 #if !defined( CC253X_MACNP )
//  225 static void MT_SysOsalNVItemInit(uint8 *pBuf);
//  226 static void MT_SysOsalNVDelete(uint8 *pBuf);
//  227 static void MT_SysOsalNVLength(uint8 *pBuf);
//  228 static void MT_SysOsalNVRead(uint8 *pBuf);
//  229 static void MT_SysOsalNVWrite(uint8 *pBuf);
//  230 static uint8 MT_CheckNvId(uint16 nvId);
//  231 #if defined( FEATURE_NVEXID )
//  232 static void MT_SysNvCompact(uint8 *pBuf);
//  233 static void MT_SysNvCreate(uint8 *pBuf);
//  234 static void MT_SysNvDelete(uint8 *pBuf);
//  235 static void MT_SysNvLength(uint8 *pBuf);
//  236 static void MT_SysNvRead(uint8 *pBuf);
//  237 static void MT_SysNvWrite(uint8 *pBuf);
//  238 static uint8 MT_StackNvExtId( NVINTF_itemID_t *nvId );
//  239 static uint8 *MT_ParseNvExtId( uint8 *pBuf, NVINTF_itemID_t *nvId );
//  240 #endif /* FEATURE_NVEXID */
//  241 #endif /* !CC253X_MACNP */
//  242 #if defined( MT_SYS_JAMMER_FEATURE )
//  243 static void MT_SysJammerParameters( uint8 *pBuf );
//  244 #endif /* MT_SYS_JAMMER_FEATURE */
//  245 #if defined( MT_SYS_SNIFFER_FEATURE )
//  246 static void MT_SysSnifferParameters( uint8 *pBuf );
//  247 #endif /* MT_SYS_SNIFFER_FEATURE */
//  248 #if defined( FEATURE_SYSTEM_STATS )
//  249 static void MT_SysZDiagsInitStats(void);
//  250 static void MT_SysZDiagsClearStats(uint8 *pBuf);
//  251 static void MT_SysZDiagsGetStatsAttr(uint8 *pBuf);
//  252 static void MT_SysZDiagsRestoreStatsFromNV(void);
//  253 static void MT_SysZDiagsSaveStatsToNV(void);
//  254 #endif /* FEATURE_SYSTEM_STATS */
//  255 #if defined( ENABLE_MT_SYS_RESET_SHUTDOWN )
//  256 static void powerOffSoc(void);
//  257 #endif /* ENABLE_MT_SYS_RESET_SHUTDOWN */
//  258 #endif /* MT_SYS_FUNC */
//  259 
//  260 #if defined( MT_SYS_FUNC )
//  261 /******************************************************************************
//  262  * @fn      MT_SysProcessing
//  263  *
//  264  * @brief   Process all the SYS commands that are issued by test tool
//  265  *
//  266  * @param   pBuf - pointer to the msg buffer
//  267  *
//  268  *          | LEN  | CMD0  | CMD1  |  DATA  |
//  269  *          |  1   |   1   |   1   |  0-255 |
//  270  *
//  271  * @return  status
//  272  *****************************************************************************/
//  273 uint8 MT_SysCommandProcessing(uint8 *pBuf)
//  274 {
//  275   uint8 status = MT_RPC_SUCCESS;
//  276 
//  277   switch (pBuf[MT_RPC_POS_CMD1])
//  278   {
//  279     case MT_SYS_RESET_REQ:
//  280       MT_SysReset(pBuf);
//  281       break;
//  282 
//  283     case MT_SYS_PING:
//  284       MT_SysPing();
//  285       break;
//  286 
//  287     case MT_SYS_VERSION:
//  288       MT_SysVersion();
//  289       break;
//  290 
//  291     case MT_SYS_SET_EXTADDR:
//  292       MT_SysSetExtAddr(pBuf);
//  293       break;
//  294 
//  295     case MT_SYS_GET_EXTADDR:
//  296       MT_SysGetExtAddr();
//  297       break;
//  298 
//  299     case MT_SYS_OSAL_START_TIMER:
//  300       MT_SysOsalStartTimer(pBuf);
//  301       break;
//  302 
//  303     case MT_SYS_OSAL_STOP_TIMER:
//  304       MT_SysOsalStopTimer(pBuf);
//  305       break;
//  306 
//  307     case MT_SYS_RANDOM:
//  308       MT_SysRandom();
//  309       break;
//  310 
//  311 #if !defined( CC26XX )
//  312     case MT_SYS_ADC_READ:
//  313       MT_SysAdcRead(pBuf);
//  314       break;
//  315 #endif /* !CC26XX */
//  316 
//  317     case MT_SYS_GPIO:
//  318       MT_SysGpio(pBuf);
//  319       break;
//  320 
//  321     case MT_SYS_STACK_TUNE:
//  322       MT_SysStackTune(pBuf);
//  323       break;
//  324 
//  325     case MT_SYS_SET_TIME:
//  326       MT_SysSetUtcTime(pBuf);
//  327       break;
//  328 
//  329     case MT_SYS_GET_TIME:
//  330       MT_SysGetUtcTime();
//  331       break;
//  332 
//  333     case MT_SYS_SET_TX_POWER:
//  334       MT_SysSetTxPower(pBuf);
//  335       break;
//  336 
//  337 // CC253X MAC Network Processor does not have NV support
//  338 #if !defined( CC253X_MACNP )
//  339     case MT_SYS_OSAL_NV_DELETE:
//  340       MT_SysOsalNVDelete(pBuf);
//  341       break;
//  342 
//  343     case MT_SYS_OSAL_NV_ITEM_INIT:
//  344       MT_SysOsalNVItemInit(pBuf);
//  345       break;
//  346 
//  347     case MT_SYS_OSAL_NV_LENGTH:
//  348       MT_SysOsalNVLength(pBuf);
//  349       break;
//  350 
//  351     case MT_SYS_OSAL_NV_READ:
//  352     case MT_SYS_OSAL_NV_READ_EXT:
//  353       MT_SysOsalNVRead(pBuf);
//  354       break;
//  355 
//  356     case MT_SYS_OSAL_NV_WRITE:
//  357     case MT_SYS_OSAL_NV_WRITE_EXT:
//  358       MT_SysOsalNVWrite(pBuf);
//  359       break;
//  360 
//  361 #if defined( FEATURE_NVEXID )
//  362     case MT_SYS_NV_COMPACT:
//  363       MT_SysNvCompact(pBuf);
//  364       break;
//  365 
//  366     case MT_SYS_NV_CREATE:
//  367       MT_SysNvCreate(pBuf);
//  368       break;
//  369 
//  370     case MT_SYS_NV_DELETE:
//  371       MT_SysNvDelete(pBuf);
//  372       break;
//  373 
//  374     case MT_SYS_NV_LENGTH:
//  375       MT_SysNvLength(pBuf);
//  376       break;
//  377 
//  378     case MT_SYS_NV_READ:
//  379       MT_SysNvRead(pBuf);
//  380       break;
//  381 
//  382     case MT_SYS_NV_WRITE:
//  383     case MT_SYS_NV_UPDATE:
//  384       MT_SysNvWrite(pBuf);
//  385       break;
//  386 #endif  /* FEATURE_NVEXID */
//  387 #endif  /* !CC253X_MACNP */
//  388 
//  389 #if !defined( CC26XX )
//  390 #if defined( MT_SYS_JAMMER_FEATURE )
//  391     case MT_SYS_JAMMER_PARAMETERS:
//  392       MT_SysJammerParameters( pBuf );
//  393       break;
//  394 #endif  /* MT_SYS_JAMMER_FEATURE */
//  395 
//  396 #if defined( MT_SYS_SNIFFER_FEATURE )
//  397     case MT_SYS_SNIFFER_PARAMETERS:
//  398       MT_SysSnifferParameters( pBuf );
//  399       break;
//  400 #endif  /* MT_SYS_SNIFFER_FEATURE */
//  401 #endif /* !CC26XX */
//  402 
//  403 #if defined( FEATURE_SYSTEM_STATS )
//  404     case MT_SYS_ZDIAGS_INIT_STATS:
//  405       MT_SysZDiagsInitStats();
//  406       break;
//  407 
//  408     case MT_SYS_ZDIAGS_CLEAR_STATS:
//  409       MT_SysZDiagsClearStats(pBuf);
//  410       break;
//  411 
//  412     case MT_SYS_ZDIAGS_GET_STATS:
//  413       MT_SysZDiagsGetStatsAttr(pBuf);
//  414        break;
//  415 
//  416     case MT_SYS_ZDIAGS_RESTORE_STATS_NV:
//  417       MT_SysZDiagsRestoreStatsFromNV();
//  418       break;
//  419 
//  420     case MT_SYS_ZDIAGS_SAVE_STATS_TO_NV:
//  421       MT_SysZDiagsSaveStatsToNV();
//  422       break;
//  423 #endif /* FEATURE_SYSTEM_STATS */
//  424 
//  425     default:
//  426       status = MT_RPC_ERR_COMMAND_ID;
//  427       break;
//  428   }
//  429 
//  430   return status;
//  431 }
//  432 
//  433 /******************************************************************************
//  434  * @fn      MT_SysReset
//  435  *
//  436  * @brief   Reset the device.
//  437  * @param   typID: 0=reset, 1=serial bootloader,
//  438  *
//  439  * @return  None
//  440  *****************************************************************************/
//  441 void MT_SysReset( uint8 *pBuf )
//  442 {
//  443   switch( pBuf[MT_RPC_POS_DAT0] )
//  444   {
//  445     case MT_SYS_RESET_HARD:
//  446       SystemReset();
//  447       break;
//  448 
//  449     case MT_SYS_RESET_SOFT:
//  450 #if !defined( HAL_BOARD_F5438 )
//  451       SystemResetSoft();  // Especially useful for CC2531 to not break comm with USB Host.
//  452 #endif
//  453       break;
//  454 
//  455     case MT_SYS_RESET_SHUTDOWN:
//  456       {
//  457 #if defined( ENABLE_MT_SYS_RESET_SHUTDOWN )
//  458         // Disable interrupts and put into deep sleep, use hardware reset to wakeup
//  459         powerOffSoc();
//  460 #endif
//  461       }
//  462       break;
//  463   }
//  464 }
//  465 
//  466 /******************************************************************************
//  467  * @fn      MT_SysPing
//  468  *
//  469  * @brief   Process the Ping command
//  470  *
//  471  * @param   None
//  472  *
//  473  * @return  None
//  474  *****************************************************************************/
//  475 static void MT_SysPing(void)
//  476 {
//  477   uint16 tmp16;
//  478   uint8 retArray[2];
//  479 
//  480   /* Build Capabilities */
//  481   tmp16 = MT_CAP_SYS | MT_CAP_MAC  | MT_CAP_NWK  | MT_CAP_AF    |
//  482           MT_CAP_ZDO | MT_CAP_SAPI | MT_CAP_UTIL | MT_CAP_DEBUG |
//  483           MT_CAP_APP | MT_CAP_GP   | MT_CAP_ZOAD | MT_CAP_APP_CNF;
//  484 
//  485   /* Convert to high byte first into temp buffer */
//  486   retArray[0] = LO_UINT16( tmp16 );
//  487   retArray[1] = HI_UINT16( tmp16 );
//  488 
//  489   /* Build and send back the response */
//  490   MT_BuildAndSendZToolResponse( MT_SRSP_SYS, MT_SYS_PING,
//  491                                 sizeof(retArray), retArray );
//  492 }
//  493 
//  494 /******************************************************************************
//  495  * @fn      MT_SysVersion
//  496  *
//  497  * @brief   Process the Version command
//  498  *
//  499  * @param   None
//  500  *
//  501  * @return  None
//  502  *****************************************************************************/
//  503 static void MT_SysVersion(void)
//  504 {
//  505 #if !defined( INCLUDE_REVISION_INFORMATION )
//  506   /* Build and send back the default response */
//  507   MT_BuildAndSendZToolResponse( MT_SRSP_SYS, MT_SYS_VERSION,
//  508                                 sizeof(MTVersionString),(uint8*)MTVersionString);
//  509 #else
//  510   uint8 verStr[sizeof(MTVersionString) + 4];
//  511   uint8 *pBuf = &verStr[sizeof(MTVersionString)];
//  512 #if (defined MAKE_CRC_SHDW) || (defined FAKE_CRC_SHDW)  //built for bootloader
//  513   uint32 sblSig;
//  514   uint32 sblRev;
//  515 #endif
//  516 
//  517   osal_memcpy(verStr, (uint8 *)MTVersionString, sizeof(MTVersionString));
//  518 
//  519 #if (defined MAKE_CRC_SHDW) || (defined FAKE_CRC_SHDW)  //built for bootloader
//  520   HalFlashRead(SBL_SIG_ADDR / HAL_FLASH_PAGE_SIZE,
//  521                SBL_SIG_ADDR % HAL_FLASH_PAGE_SIZE,
//  522                (uint8 *)&sblSig, sizeof(sblSig));
//  523 
//  524   if (sblSig == SBL_SIGNATURE)
//  525   {
//  526     // SBL is supported and its revision is provided (in a known flash location)
//  527     HalFlashRead(SBL_REV_ADDR / HAL_FLASH_PAGE_SIZE,
//  528                  SBL_REV_ADDR % HAL_FLASH_PAGE_SIZE,
//  529                  (uint8 *)&sblRev, sizeof(sblRev));
//  530   }
//  531   else
//  532   {
//  533     //  SBL is supported but its revision is not provided
//  534     sblRev = 0x00000000;
//  535   }
//  536 #else
//  537   // SBL is NOT supported
//  538   sblRev = 0xFFFFFFFF;
//  539 #endif
//  540 
//  541   // Plug the SBL revision indication
//  542   UINT32_TO_BUF_LITTLE_ENDIAN(pBuf,sblRev);
//  543 
//  544   /* Build and send back the response */
//  545   MT_BuildAndSendZToolResponse( MT_SRSP_SYS, MT_SYS_VERSION,
//  546                                 sizeof(verStr), verStr);
//  547 #endif
//  548 }
//  549 
//  550 /******************************************************************************
//  551  * @fn      MT_SysSetExtAddr
//  552  *
//  553  * @brief   Set the Extended Address
//  554  *
//  555  * @param   pBuf
//  556  *
//  557  * @return  None
//  558  *****************************************************************************/
//  559 static void MT_SysSetExtAddr(uint8 *pBuf)
//  560 {
//  561   uint8 retValue = ZFailure;
//  562 
//  563   /* Skip over RPC header */
//  564   pBuf += MT_RPC_FRAME_HDR_SZ;
//  565 
//  566   if ( ZMacSetReq(ZMacExtAddr, pBuf) == ZMacSuccess )
//  567   {
//  568 // CC253X MAC Network Processor does not have NV support
//  569 #if defined(CC253X_MACNP)
//  570     retValue = ZSuccess;
//  571 #else
//  572     retValue = osal_nv_write(ZCD_NV_EXTADDR, 0, Z_EXTADDR_LEN, pBuf);
//  573 #endif
//  574   }
//  575 
//  576   /* Build and send back the response */
//  577   MT_BuildAndSendZToolResponse( MT_SRSP_SYS, MT_SYS_SET_EXTADDR,
//  578                                 sizeof(retValue), &retValue);
//  579 }
//  580 
//  581 /******************************************************************************
//  582  * @fn      MT_SysGetExtAddr
//  583  *
//  584  * @brief   Get the Extended Address
//  585  *
//  586  * @param   None
//  587  *
//  588  * @return  None
//  589  *****************************************************************************/
//  590 static void MT_SysGetExtAddr(void)
//  591 {
//  592   uint8 extAddr[Z_EXTADDR_LEN];
//  593 
//  594   ZMacGetReq( ZMacExtAddr, extAddr );
//  595 
//  596   /* Build and send back the response */
//  597   MT_BuildAndSendZToolResponse( MT_SRSP_SYS, MT_SYS_GET_EXTADDR,
//  598                                 sizeof(extAddr), extAddr);
//  599 }
//  600 
//  601 #if !defined( CC253X_MACNP )
//  602 /******************************************************************************
//  603  * @fn      MT_CheckNvId
//  604  *
//  605  * @brief   Check whether (ZigBee Stack) NV read should be blocked
//  606  *
//  607  * @param   nvId - NV item ID
//  608  *
//  609  * @return  'ZInvalidParameter' if blocked, otherwise 'ZSuccess'
//  610  *****************************************************************************/
//  611 static uint8 MT_CheckNvId( uint16 nvId )
//  612 {
//  613 #if !MT_SYS_OSAL_NV_READ_CERTIFICATE_DATA
//  614   if ((ZCD_NV_IMPLICIT_CERTIFICATE == nvId) ||
//  615       (ZCD_NV_CA_PUBLIC_KEY == nvId)        ||
//  616       (ZCD_NV_DEVICE_PRIVATE_KEY == nvId))
//  617   {
//  618     /* Access to Security Certificate Data is denied */
//  619     return( ZInvalidParameter );
//  620   }
//  621 #endif  /* MT_SYS_OSAL_NV_READ_CERTIFICATE_DATA */
//  622 
//  623 #if !MT_SYS_KEY_MANAGEMENT
//  624   if ( (nvId == ZCD_NV_NWK_ACTIVE_KEY_INFO) ||
//  625        (nvId == ZCD_NV_NWK_ALTERN_KEY_INFO) ||
//  626       ((nvId >= ZCD_NV_TCLK_TABLE_START) && (nvId <= ZCD_NV_TCLK_TABLE_END)) ||
//  627       ((nvId >= ZCD_NV_APS_LINK_KEY_DATA_START) && (nvId <= ZCD_NV_APS_LINK_KEY_DATA_END)) ||
//  628        (nvId == ZCD_NV_PRECFGKEY) )
//  629   {
//  630     /* Access to Security Key Data is denied */
//  631     return( ZInvalidParameter );
//  632   }
//  633 #endif  /* !MT_SYS_KEY_MANAGEMENT */
//  634 
//  635   return( ZSuccess );
//  636 }
//  637 
//  638 /******************************************************************************
//  639  * @fn      MT_SysOsalNVRead
//  640  *
//  641  * @brief   Attempt to read an NV value
//  642  *
//  643  * @param   pBuf - pointer to the data
//  644  *
//  645  * @return  None
//  646  *****************************************************************************/
//  647 static void MT_SysOsalNVRead(uint8 *pBuf)
//  648 {
//  649   uint8 error;
//  650   uint8 cmdId;
//  651   uint16 nvId;
//  652   uint16 dataLen;
//  653   uint16 dataOfs;
//  654   uint16 nvItemLen;
//  655 
//  656   /* MT command ID */
//  657   cmdId = pBuf[MT_RPC_POS_CMD1];
//  658   /* Skip over RPC header */
//  659   pBuf += MT_RPC_FRAME_HDR_SZ;
//  660 
//  661   /* NV item ID */
//  662   nvId = osal_build_uint16( pBuf );
//  663 
//  664 #if defined( ZCD_NV_POLL_RATE_OLD16 )
//  665   if( nvId == ZCD_NV_POLL_RATE_OLD16 )
//  666   {
//  667     // This ID shouldn't exist anymore, it was converted to the new size and ID
//  668     // then deleted during initialization. But, a read of this item will
//  669     // read the new item and convert the size and return the size expected.
//  670     uint32 pollRate;
//  671     uint16 *pOldPollRate;
//  672     uint8 respBuf[4];
//  673     uint8 respLen;
//  674     // Convert from old uint16 NV item to the new uint32 NV item
//  675     if ( osal_nv_read( ZCD_NV_POLL_RATE, 0, sizeof( uint32 ), &pollRate ) == ZSUCCESS )
//  676     {
//  677       respBuf[0] = ZSuccess;
//  678       respBuf[1] = sizeof( uint16 );
//  679       pOldPollRate = (uint16 *)&respBuf[2];
//  680       *pOldPollRate = (uint16)pollRate;
//  681       respLen = 4;
//  682     }
//  683     else
//  684     {
//  685       respBuf[0] = ZFailure;
//  686       respBuf[1] = 0;
//  687       respLen = 2;
//  688     }
//  689     /* Build and send back the response */
//  690     MT_BuildAndSendZToolResponse( MT_SRSP_SYS, MT_SYS_OSAL_NV_READ,
//  691                                   respLen, respBuf );
//  692     return;
//  693   }
//  694 #endif
//  695 
//  696   /* Check whether read-access to this item is allowed */
//  697   error = MT_CheckNvId( nvId );
//  698 
//  699   /* Get NV data offset */
//  700   if( cmdId == MT_SYS_OSAL_NV_READ )
//  701   {
//  702     /* MT_SYS_OSAL_NV_READ has 1-byte offset */
//  703     dataOfs = (uint16)pBuf[2];
//  704   }
//  705   else
//  706   {
//  707     /* MT_SYS_OSAL_NV_READ_EXT has 2-byte offset */
//  708     dataOfs = osal_build_uint16( pBuf+2 );
//  709   }
//  710 
//  711   /* Length of entire NV item data */
//  712   nvItemLen = osal_nv_item_len( nvId );
//  713   if( nvItemLen <= dataOfs )
//  714   {
//  715     /* Offset is past end of data */
//  716     error = ZInvalidParameter;
//  717   }
//  718 
//  719   if( error == ZSuccess )
//  720   {
//  721     uint8 *pRetBuf;
//  722     uint8 respLen = 2;  /* Response header: [0]=status,[1]=length */
//  723 
//  724     dataLen = nvItemLen - dataOfs;
//  725     if (dataLen > (uint16)(MT_MAX_RSP_DATA_LEN - respLen))
//  726     {
//  727       /* Data length is limited by TX buffer size and MT protocol */
//  728       dataLen = (MT_MAX_RSP_DATA_LEN - respLen);
//  729     }
//  730     respLen += dataLen;
//  731 
//  732     pRetBuf = osal_mem_alloc(respLen);
//  733     if( pRetBuf != NULL )
//  734     {
//  735       osal_memset(&pRetBuf[2], 0, dataLen);
//  736       if (((osal_nv_read( nvId, dataOfs, dataLen, &pRetBuf[2] )) == ZSUCCESS))
//  737       {
//  738         pRetBuf[0] = ZSuccess;
//  739         pRetBuf[1] = dataLen;
//  740         MT_BuildAndSendZToolResponse( MT_SRSP_SYS, cmdId,
//  741                                       respLen, pRetBuf );
//  742       }
//  743       else
//  744       {
//  745         error = NV_OPER_FAILED;
//  746       }
//  747       osal_mem_free(pRetBuf);
//  748     }
//  749     else
//  750     {
//  751       /* Could not get buffer for NV data */
//  752       error = ZMemError;
//  753     }
//  754   }
//  755 
//  756   if( error != ZSuccess )
//  757   {
//  758     uint8 tmp[2] = { error, 0 };
//  759     MT_BuildAndSendZToolResponse( MT_SRSP_SYS, cmdId,
//  760                                   sizeof(tmp), tmp);
//  761   }
//  762 }
//  763 
//  764 /******************************************************************************
//  765  * @fn      MT_SysOsalNVWrite
//  766  *
//  767  * @brief   Attempt to write an NV item
//  768  *
//  769  * @param   pBuf - pointer to the data
//  770  *
//  771  * @return  None
//  772  *****************************************************************************/
//  773 static void MT_SysOsalNVWrite(uint8 *pBuf)
//  774 {
//  775   uint8 cmdId;
//  776   uint16 nvId;
//  777   uint16 dataLen;
//  778   uint16 dataOfs;
//  779   uint16 nvItemLen;
//  780   uint8 rtrn = ZSuccess;
//  781 
//  782   /* MT command ID */
//  783   cmdId = pBuf[MT_RPC_POS_CMD1];
//  784   /* Skip over RPC header */
//  785   pBuf += MT_RPC_FRAME_HDR_SZ;
//  786 
//  787   /* NV item ID */
//  788   nvId = osal_build_uint16( pBuf );
//  789 
//  790   /* Get NV data offset & length */
//  791   if ( cmdId == MT_SYS_OSAL_NV_WRITE )
//  792   {
//  793     /* MT_SYS_OSAL_NV_WRITE has 1-byte offset & length */
//  794     dataOfs = (uint16)pBuf[2];
//  795     dataLen = (uint16)pBuf[3];
//  796     pBuf += 4;
//  797   }
//  798   else
//  799   {
//  800     /* MT_SYS_OSAL_NV_WRITE_EXT has 2-byte offset & length */
//  801     dataOfs = osal_build_uint16( pBuf+2 );
//  802     dataLen = osal_build_uint16( pBuf+4 );
//  803     pBuf += 6;
//  804   }
//  805 
//  806 #if defined ( ZCD_NV_POLL_RATE_OLD16 )
//  807   if ( nvId == ZCD_NV_POLL_RATE_OLD16 )
//  808   {
//  809     // This ID shouldn't exist anymore, it was converted to the new size and ID
//  810     // then deleted during initialization.  But a write to this item will
//  811     // convert the 16 bits to the new 32 bits and write that value to the new
//  812     // NV item.
//  813     uint32 pollRate;
//  814     uint16 *pOldPollRate = (uint16 *)pBuf;
//  815     uint16 oldPollRate = *pOldPollRate;
//  816     nvId = ZCD_NV_POLL_RATE;
//  817     nvItemLen = sizeof ( uint32 );
//  818     pollRate = (uint32)oldPollRate;
//  819     pBuf = (uint8 *)&pollRate;
//  820   }
//  821 #endif
//  822 
//  823   /* Length of entire NV item data */
//  824   nvItemLen = osal_nv_item_len(nvId);
//  825   if ((dataOfs + dataLen) <= nvItemLen)
//  826   {
//  827     if (dataOfs == 0)
//  828     {
//  829       /* Set the Z-Globals value of this NV item */
//  830       zgSetItem( nvId, dataLen, pBuf );
//  831     }
//  832 
//  833     if ((osal_nv_write(nvId, dataOfs, dataLen, pBuf)) == ZSUCCESS)
//  834     {
//  835       if (nvId == ZCD_NV_EXTADDR)
//  836       {
//  837         rtrn = ZMacSetReq(ZMacExtAddr, pBuf);
//  838       }
//  839     }
//  840     else
//  841     {
//  842       rtrn = NV_OPER_FAILED;
//  843     }
//  844   }
//  845   else
//  846   {
//  847     /* Bad length or/and offset */
//  848     rtrn = ZInvalidParameter;
//  849   }
//  850 
//  851   /* Build and send back the response */
//  852   MT_BuildAndSendZToolResponse( MT_SRSP_SYS, cmdId,
//  853                                 sizeof(rtrn), &rtrn);
//  854 }
//  855 
//  856 /******************************************************************************
//  857  * @fn      MT_SysOsalNVItemInit
//  858  *
//  859  * @brief   Attempt to create an NV item
//  860  *
//  861  * @param   pBuf - pointer to the data
//  862  *
//  863  * @return  None
//  864  *****************************************************************************/
//  865 static void MT_SysOsalNVItemInit(uint8 *pBuf)
//  866 {
//  867   uint8 ret;
//  868   uint8 idLen;
//  869   uint16 nvId;
//  870   uint16 nvLen;
//  871 
//  872   /* Skip over RPC header */
//  873   pBuf += MT_RPC_FRAME_HDR_SZ;
//  874 
//  875   /* NV item ID */
//  876   nvId = osal_build_uint16( pBuf );
//  877   /* NV item length */
//  878   nvLen = osal_build_uint16( pBuf+2 );
//  879   /* Initialization data length */
//  880   idLen = pBuf[4];
//  881   pBuf += 5;
//  882 
//  883 #if defined( ZCD_NV_POLL_RATE_OLD16 )
//  884   if ( nvId == ZCD_NV_POLL_RATE_OLD16 )
//  885   {
//  886     /* This item shouldn't exist anymore.  Read and write will convert
//  887      * to the new NV item, so return Success.
//  888      */
//  889     ret = ZSuccess;
//  890   }
//  891   else
//  892 #endif
//  893   {
//  894     if ( idLen < nvLen )
//  895     {
//  896       /* Attempt to create a new NV item */
//  897       ret = osal_nv_item_init( nvId, nvLen, NULL );
//  898       if ( (ret == NV_ITEM_UNINIT) && (idLen > 0) )
//  899       {
//  900         /* Write initialization data to first part of new item */
//  901         (void) osal_nv_write( nvId, 0, (uint16)idLen, pBuf );
//  902       }
//  903     }
//  904     else
//  905     {
//  906       /* Attempt to create/initialize a new NV item */
//  907       ret = osal_nv_item_init( nvId, nvLen, pBuf );
//  908     }
//  909   }
//  910 
//  911   /* Build and send back the response */
//  912   MT_BuildAndSendZToolResponse( MT_SRSP_SYS, MT_SYS_OSAL_NV_ITEM_INIT,
//  913                                 sizeof(ret), &ret);
//  914 }
//  915 
//  916 /******************************************************************************
//  917  * @fn      MT_SysOsalNVDelete
//  918  *
//  919  * @brief   Attempt to delete an NV item
//  920  *
//  921  * @param   pBuf - pointer to the data
//  922  *
//  923  * @return  None
//  924  *****************************************************************************/
//  925 static void MT_SysOsalNVDelete(uint8 *pBuf)
//  926 {
//  927   uint16 nvId;
//  928   uint16 nvLen;
//  929   uint8 ret;
//  930 
//  931   /* Skip over RPC header */
//  932   pBuf += MT_RPC_FRAME_HDR_SZ;
//  933 
//  934   /* Get the ID */
//  935   nvId = osal_build_uint16( pBuf );
//  936   /* Get the length */
//  937   nvLen = osal_build_uint16( pBuf+2 );
//  938 
//  939 #if defined ( ZCD_NV_POLL_RATE_OLD16 )
//  940   if ( nvId == ZCD_NV_POLL_RATE_OLD16 )
//  941   {
//  942     /* This item shouldn't exist anymore.  Read and write will convert
//  943      * to the new NV item, so return Success.
//  944      */
//  945     ret = ZSuccess;
//  946   }
//  947   else
//  948 #endif
//  949   {
//  950     /* Attempt to delete the NV item */
//  951     ret = osal_nv_delete( nvId, nvLen );
//  952   }
//  953 
//  954   /* Build and send back the response */
//  955   MT_BuildAndSendZToolResponse( MT_SRSP_SYS, MT_SYS_OSAL_NV_DELETE,
//  956                                 sizeof(ret), &ret);
//  957 }
//  958 
//  959 /******************************************************************************
//  960  * @fn      MT_SysOsalNVLength
//  961  *
//  962  * @brief   Attempt to get the length to an NV item
//  963  *
//  964  * @param   pBuf - pointer to the data
//  965  *
//  966  * @return  None
//  967  *****************************************************************************/
//  968 static void MT_SysOsalNVLength(uint8 *pBuf)
//  969 {
//  970   uint16 nvId;
//  971   uint16 nvLen;
//  972   uint8 rsp[2];
//  973 
//  974   /* Skip over RPC header */
//  975   pBuf += MT_RPC_FRAME_HDR_SZ;
//  976 
//  977   /* Get the ID */
//  978   nvId = osal_build_uint16( pBuf );
//  979 
//  980 #if defined ( ZCD_NV_POLL_RATE_OLD16 )
//  981   if ( nvId == ZCD_NV_POLL_RATE_OLD16 )
//  982   {
//  983     /* Ignore this item and force return  */
//  984     nvLen = 0;
//  985   }
//  986   else
//  987 #endif
//  988   {
//  989     /* Attempt to get NV item length */
//  990     nvLen = osal_nv_item_len( nvId );
//  991   }
//  992 
//  993   rsp[0] = LO_UINT16( nvLen );
//  994   rsp[1] = HI_UINT16( nvLen );
//  995 
//  996   /* Build and send back the response */
//  997   MT_BuildAndSendZToolResponse( MT_SRSP_SYS, MT_SYS_OSAL_NV_LENGTH,
//  998                                 sizeof(rsp), rsp);
//  999 }
// 1000 
// 1001 #if defined( FEATURE_NVEXID )
// 1002 /******************************************************************************
// 1003  * @fn      MT_ParseNvExtId
// 1004  *
// 1005  * @brief   Parse the incoming NV ID parameters
// 1006  *
// 1007  * @param   pBuf - pointer to incoming data
// 1008  * @param   nvId - pointer to outgoing NV ID
// 1009  *
// 1010  * @return  pointer to next incoming data byte
// 1011  *****************************************************************************/
// 1012 static uint8 *MT_ParseNvExtId( uint8 *pBuf, NVINTF_itemID_t *nvId )
// 1013 {
// 1014   /* Skip over RPC header */
// 1015   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1016 
// 1017   nvId->systemID = pBuf[0];
// 1018   nvId->itemID = osal_build_uint16( pBuf+1 );
// 1019   nvId->subID = osal_build_uint16( pBuf+3 );
// 1020 
// 1021   return( pBuf + 5 );
// 1022 }
// 1023 
// 1024 /******************************************************************************
// 1025  * @fn      MT_StackNvExtId
// 1026  *
// 1027  * @brief   Check whether extended NV ID is from ZigBee Stack
// 1028  *
// 1029  * @param   nvId - pointer to extended NV ID
// 1030  *
// 1031  * @return  TRUE if ZigBee Stack NV item, otherwise FALSE
// 1032  *****************************************************************************/
// 1033 static uint8 MT_StackNvExtId( NVINTF_itemID_t *nvId )
// 1034 {
// 1035   return( (nvId->systemID == NVINTF_SYSID_ZSTACK) && (nvId->itemID == 0) );
// 1036 }
// 1037 
// 1038 /******************************************************************************
// 1039  * @fn      MT_SysNvCompact
// 1040  *
// 1041  * @brief   Attempt to compact the active NV page
// 1042  *
// 1043  * @param   pBuf - pointer to the data
// 1044  *
// 1045  * @return  None
// 1046  *****************************************************************************/
// 1047 static void MT_SysNvCompact(uint8 *pBuf)
// 1048 {
// 1049   uint8 retVal;
// 1050 
// 1051   if (( pZStackCfg == NULL ) || ( pZStackCfg->nvFps.compactNV == NULL ))
// 1052   {
// 1053     /* NV item compact function not available */
// 1054     retVal = NVINTF_NOTREADY;
// 1055   }
// 1056   else
// 1057   {
// 1058     uint16 minSize;
// 1059 
// 1060     /* Skip over RPC header */
// 1061     pBuf += MT_RPC_FRAME_HDR_SZ;
// 1062 
// 1063     /* Get the remaining size threshold */
// 1064     minSize = osal_build_uint16( pBuf );
// 1065 
// 1066     /* Attempt to compact the active NV page */
// 1067     retVal = pZStackCfg->nvFps.compactNV( minSize );
// 1068   }
// 1069 
// 1070   /* Build and send back the response */
// 1071   MT_BuildAndSendZToolResponse( MT_SRSP_SYS, MT_SYS_NV_COMPACT,
// 1072                                 sizeof(retVal), &retVal);
// 1073 }
// 1074 
// 1075 /******************************************************************************
// 1076  * @fn      MT_SysNvCreate
// 1077  *
// 1078  * @brief   Attempt to create an NV item (extended item ID)
// 1079  *
// 1080  * @param   pBuf - pointer to the data
// 1081  *
// 1082  * @return  None
// 1083  *****************************************************************************/
// 1084 static void MT_SysNvCreate(uint8 *pBuf)
// 1085 {
// 1086   uint8 retVal;
// 1087 
// 1088   if(( pZStackCfg == NULL ) || ( pZStackCfg->nvFps.createItem == NULL ))
// 1089   {
// 1090     /* NV item create function not available */
// 1091     retVal = NVINTF_NOTREADY;
// 1092   }
// 1093   else
// 1094   {
// 1095     uint32 nvLen;
// 1096     NVINTF_itemID_t nvId;
// 1097 
// 1098     /* Get the NV ID parameters */
// 1099     pBuf = MT_ParseNvExtId( pBuf, &nvId );
// 1100 
// 1101     /* Get the length */
// 1102     nvLen = osal_build_uint32( pBuf, sizeof(nvLen) );
// 1103 
// 1104     /* Attempt to create the specified item with no initial data */
// 1105     retVal = pZStackCfg->nvFps.createItem( nvId, nvLen, NULL );
// 1106   }
// 1107 
// 1108   /* Build and send back the response */
// 1109   MT_BuildAndSendZToolResponse( MT_SRSP_SYS, MT_SYS_NV_CREATE,
// 1110                                 sizeof(retVal), &retVal);
// 1111 }
// 1112 
// 1113 /******************************************************************************
// 1114  * @fn      MT_SysNvDelete
// 1115  *
// 1116  * @brief   Attempt to delete an NV item (extended item ID)
// 1117  *
// 1118  * @param   pBuf - pointer to the data
// 1119  *
// 1120  * @return  None
// 1121  *****************************************************************************/
// 1122 static void MT_SysNvDelete(uint8 *pBuf)
// 1123 {
// 1124   uint8 retVal;
// 1125 
// 1126   if(( pZStackCfg == NULL ) || ( pZStackCfg->nvFps.deleteItem == NULL ))
// 1127   {
// 1128     /* NV item delete function not available */
// 1129     retVal = NVINTF_NOTREADY;
// 1130   }
// 1131   else
// 1132   {
// 1133     NVINTF_itemID_t nvId;
// 1134 
// 1135     /* Get the NV ID parameters */
// 1136     MT_ParseNvExtId( pBuf, &nvId );
// 1137 
// 1138     /* Attempt to delete the specified item */
// 1139     retVal = pZStackCfg->nvFps.deleteItem( nvId );
// 1140   }
// 1141 
// 1142   /* Build and send back the response */
// 1143   MT_BuildAndSendZToolResponse( MT_SRSP_SYS, MT_SYS_NV_DELETE,
// 1144                                 sizeof(retVal), &retVal);
// 1145 }
// 1146 
// 1147 /******************************************************************************
// 1148  * @fn      MT_SysNvLength
// 1149  *
// 1150  * @brief   Attempt to delete an NV item (extended item ID)
// 1151  *
// 1152  * @param   pBuf - pointer to the data
// 1153  *
// 1154  * @return  None
// 1155  *****************************************************************************/
// 1156 static void MT_SysNvLength(uint8 *pBuf)
// 1157 {
// 1158   uint32 nvLen;
// 1159   uint8 retBuf[4];
// 1160 
// 1161   if(( pZStackCfg == NULL ) || ( pZStackCfg->nvFps.getItemLen == NULL ))
// 1162   {
// 1163     /* NV item length function not available */
// 1164     nvLen = 0;
// 1165   }
// 1166   else
// 1167   {
// 1168     NVINTF_itemID_t nvId;
// 1169 
// 1170     /* Get the NV ID parameters */
// 1171     MT_ParseNvExtId( pBuf, &nvId );
// 1172 
// 1173     /* Attempt to get length of the specified item */
// 1174     nvLen = pZStackCfg->nvFps.getItemLen( nvId );
// 1175   }
// 1176 
// 1177   /* Serialize the length bytes */
// 1178   osal_buffer_uint32( retBuf, nvLen );
// 1179 
// 1180   /* Build and send back the response */
// 1181   MT_BuildAndSendZToolResponse( MT_SRSP_SYS, MT_SYS_NV_LENGTH,
// 1182                                 sizeof(retBuf), retBuf);
// 1183 }
// 1184 
// 1185 /******************************************************************************
// 1186  * @fn      MT_SysNvRead
// 1187  *
// 1188  * @brief   Attempt to read an NV item (extended item ID)
// 1189  *
// 1190  * @param   pBuf - pointer to the data
// 1191  *
// 1192  * @return  None
// 1193  *****************************************************************************/
// 1194 static void MT_SysNvRead(uint8 *pBuf)
// 1195 {
// 1196   uint8 error;
// 1197 
// 1198   if(( pZStackCfg == NULL ) || ( pZStackCfg->nvFps.readItem == NULL ))
// 1199   {
// 1200     /* NV item length/read function not available */
// 1201     error = NVINTF_NOTREADY;
// 1202   }
// 1203   else
// 1204   {
// 1205     uint8 dataLen;
// 1206     uint16 dataOfs;
// 1207     uint8 *pRetBuf;
// 1208     uint8 respLen = 2;  /* Response header: [0]=status,[1]=length */
// 1209     NVINTF_itemID_t nvId;
// 1210 
// 1211     /* Get the NV ID parameters */
// 1212     pBuf = MT_ParseNvExtId( pBuf, &nvId );
// 1213 
// 1214     if( MT_StackNvExtId(&nvId) == TRUE )
// 1215     {
// 1216       /* Check whether read-access to this ZigBee Stack item is allowed */
// 1217       if( MT_CheckNvId( nvId.subID ) != ZSuccess )
// 1218       {
// 1219         /* Convert to NVINTF error code */
// 1220         error = NVINTF_BADSUBID;
// 1221       }
// 1222     }
// 1223     else
// 1224     {
// 1225       /* It's OK to read this item */
// 1226       error = ZSuccess;
// 1227     }
// 1228 
// 1229     /* Get the read data offset */
// 1230     dataOfs = osal_build_uint16( pBuf );
// 1231 
// 1232     /* And the read data length */
// 1233     dataLen = pBuf[2];
// 1234 
// 1235     if( dataLen > (MT_MAX_RSP_DATA_LEN - respLen) )
// 1236     {
// 1237       /* Data length is limited by TX buffer size and MT protocol */
// 1238       dataLen = (MT_MAX_RSP_DATA_LEN - respLen);
// 1239     }
// 1240     respLen += dataLen;
// 1241 
// 1242     pRetBuf = osal_mem_alloc(respLen);
// 1243     if( pRetBuf != NULL )
// 1244     {
// 1245       /* Attempt to read data from the specified item */
// 1246       error = pZStackCfg->nvFps.readItem( nvId, dataOfs, dataLen, pRetBuf+2 );
// 1247       if( error == NVINTF_SUCCESS )
// 1248       {
// 1249         pRetBuf[0] = ZSuccess;
// 1250         pRetBuf[1] = dataLen;
// 1251         MT_BuildAndSendZToolResponse( MT_SRSP_SYS, MT_SYS_NV_READ,
// 1252                                       respLen, pRetBuf );
// 1253       }
// 1254       osal_mem_free(pRetBuf);
// 1255     }
// 1256     else
// 1257     {
// 1258       /* Could not get buffer for NV data */
// 1259       error = ZMemError;
// 1260     }
// 1261   }
// 1262 
// 1263   if( error != ZSuccess )
// 1264   {
// 1265     uint8 tmp[2] = { error, 0 };
// 1266     MT_BuildAndSendZToolResponse( MT_SRSP_SYS, MT_SYS_NV_READ,
// 1267                                   sizeof(tmp), tmp );
// 1268   }
// 1269 }
// 1270 
// 1271 /******************************************************************************
// 1272  * @fn      MT_SysNvWrite
// 1273  *
// 1274  * @brief   Attempt to write an NV item (extended item ID)
// 1275  *
// 1276  * @param   pBuf - pointer to the data
// 1277  *
// 1278  * @return  None
// 1279  *****************************************************************************/
// 1280 static void MT_SysNvWrite(uint8 *pBuf)
// 1281 {
// 1282   uint8 cmdId;
// 1283   uint8 error;
// 1284 
// 1285   /* MT command ID */
// 1286   cmdId = pBuf[MT_RPC_POS_CMD1];
// 1287 
// 1288   if(( pZStackCfg == NULL ) || ( pZStackCfg->nvFps.writeItem == NULL ))
// 1289   {
// 1290     /* NV item length/read function not available */
// 1291     error = NVINTF_NOTREADY;
// 1292   }
// 1293   else
// 1294   {
// 1295     uint8 dataLen;
// 1296     uint16 dataOfs = 0;
// 1297     NVINTF_itemID_t nvId;
// 1298 
// 1299     /* Get the NV ID parameters */
// 1300     pBuf = MT_ParseNvExtId( pBuf, &nvId );
// 1301 
// 1302     if( cmdId == MT_SYS_NV_WRITE )
// 1303     {
// 1304       /* Get data offset for Write command */
// 1305       dataOfs = osal_build_uint16( pBuf );
// 1306       pBuf += 2;
// 1307     }
// 1308 
// 1309     /* Get the write data length */
// 1310     dataLen = pBuf[0];
// 1311     pBuf += 1;
// 1312 
// 1313     if( (dataOfs == 0) && (MT_StackNvExtId(&nvId) == TRUE) )
// 1314     {
// 1315       /* Set the Z-Globals value of this NV item */
// 1316       zgSetItem( nvId.subID, dataLen, pBuf );
// 1317 
// 1318       if( nvId.subID == ZCD_NV_EXTADDR )
// 1319       {
// 1320         /* Give MAC the new 64-bit address */
// 1321         ZMacSetReq( ZMacExtAddr, pBuf );
// 1322       }
// 1323     }
// 1324 
// 1325     if( cmdId == MT_SYS_NV_UPDATE )
// 1326     {
// 1327       /* Attempt to update (create) data to the specified item */
// 1328       error = pZStackCfg->nvFps.writeItem( nvId, dataLen, pBuf );
// 1329     }
// 1330     else
// 1331     {
// 1332       /* Attempt to write data (existing) to the specified item */
// 1333       error = pZStackCfg->nvFps.writeItemEx( nvId, dataOfs, dataLen, pBuf );
// 1334     }
// 1335   }
// 1336 
// 1337   /* Build and send back the response */
// 1338   MT_BuildAndSendZToolResponse( MT_SRSP_SYS, cmdId, sizeof(error), &error);
// 1339 }
// 1340 #endif  /* FEATURE_NVEXID */
// 1341 #endif  /* !CC253X_MACNP */
// 1342 
// 1343 /******************************************************************************
// 1344  * @fn      MT_SysOsalStartTimer
// 1345  *
// 1346  * @brief
// 1347  *
// 1348  * @param   uint8 pBuf - pointer to the data
// 1349  *
// 1350  * @return  None
// 1351  *****************************************************************************/
// 1352 static void MT_SysOsalStartTimer(uint8 *pBuf)
// 1353 {
// 1354   uint8 retValue;
// 1355 
// 1356   /* Skip over RPC header */
// 1357   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1358 
// 1359   if (*pBuf <= 3)
// 1360   {
// 1361     uint16 timer = osal_build_uint16( pBuf+1 );
// 1362     uint16 eventId = (uint16)MT_SysOsalEventId[pBuf[0]];
// 1363 
// 1364     retValue = osal_start_timerEx(MT_TaskID, eventId, timer);
// 1365   }
// 1366   else
// 1367   {
// 1368     retValue = ZInvalidParameter;
// 1369   }
// 1370 
// 1371   /* Build and send back the response */
// 1372   MT_BuildAndSendZToolResponse( MT_SRSP_SYS, MT_SYS_OSAL_START_TIMER,
// 1373                                 sizeof(retValue), &retValue);
// 1374 }
// 1375 
// 1376 /******************************************************************************
// 1377  * @fn      MT_SysOsalStopTimer
// 1378  *
// 1379  * @brief
// 1380  *
// 1381  * @param   uint8 pBuf - pointer to the data
// 1382  *
// 1383  * @return  None
// 1384  *****************************************************************************/
// 1385 static void MT_SysOsalStopTimer(uint8 *pBuf)
// 1386 {
// 1387   uint16 eventId;
// 1388   uint8 retValue = ZFailure;
// 1389 
// 1390   /* Skip over RPC header */
// 1391   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1392 
// 1393   if (*pBuf <= 3)
// 1394   {
// 1395     eventId = (uint16) MT_SysOsalEventId[*pBuf];
// 1396     retValue = osal_stop_timerEx(MT_TaskID, eventId);
// 1397   }
// 1398   else
// 1399   {
// 1400     retValue = ZInvalidParameter;
// 1401   }
// 1402 
// 1403   /* Build and send back the response */
// 1404   MT_BuildAndSendZToolResponse( MT_SRSP_SYS, MT_SYS_OSAL_STOP_TIMER,
// 1405                                 sizeof(retValue), &retValue );
// 1406 }
// 1407 
// 1408 /******************************************************************************
// 1409  * @fn      MT_SysRandom
// 1410  *
// 1411  * @brief
// 1412  *
// 1413  * @param   uint8 pData - pointer to the data
// 1414  *
// 1415  * @return  None
// 1416  *****************************************************************************/
// 1417 static void MT_SysRandom()
// 1418 {
// 1419   uint16 randValue = Onboard_rand();
// 1420   uint8 retArray[2];
// 1421 
// 1422   retArray[0] = LO_UINT16(randValue);
// 1423   retArray[1] = HI_UINT16(randValue);
// 1424 
// 1425   /* Build and send back the response */
// 1426   MT_BuildAndSendZToolResponse( MT_SRSP_SYS, MT_SYS_RANDOM,
// 1427                                 sizeof(retArray), retArray );
// 1428 }
// 1429 
// 1430 #if !defined( CC26XX )
// 1431 /******************************************************************************
// 1432  * @fn      MT_SysAdcRead
// 1433  *
// 1434  * @brief   Reading ADC value, temperature sensor and voltage
// 1435  *
// 1436  * @param   uint8 pBuf - pointer to the data
// 1437  *
// 1438  * @return  None
// 1439  *****************************************************************************/
// 1440 static void MT_SysAdcRead(uint8 *pBuf)
// 1441 {
// 1442   uint16 tempValue = 0;
// 1443   uint8 retArray[2];
// 1444 
// 1445   /* Skip over RPC header */
// 1446   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1447 
// 1448   {
// 1449     uint8 channel = *pBuf++;  /* ADC channel */
// 1450     uint8 resolution = *pBuf++;  /* ADC resolution */
// 1451 
// 1452     /* Voltage reading */
// 1453     switch (channel)
// 1454     {
// 1455       case HAL_ADC_CHANNEL_TEMP:  /* Temperature sensor */
// 1456       case HAL_ADC_CHANNEL_VDD:   /* Voltage reading */
// 1457         resolution = HAL_ADC_RESOLUTION_14;
// 1458 
// 1459       case HAL_ADC_CHANNEL_0:  /* Analog input channels */
// 1460       case HAL_ADC_CHANNEL_1:
// 1461       case HAL_ADC_CHANNEL_2:
// 1462       case HAL_ADC_CHANNEL_3:
// 1463       case HAL_ADC_CHANNEL_4:
// 1464       case HAL_ADC_CHANNEL_5:
// 1465       case HAL_ADC_CHANNEL_6:
// 1466       case HAL_ADC_CHANNEL_7:
// 1467         tempValue = HalAdcRead(channel, resolution);
// 1468         break;
// 1469 
// 1470       default:  /* Undefined channel */
// 1471         break;
// 1472     }
// 1473   }
// 1474 
// 1475   retArray[0] = LO_UINT16(tempValue);
// 1476   retArray[1] = HI_UINT16(tempValue);
// 1477 
// 1478   /* Build and send back the response */
// 1479   MT_BuildAndSendZToolResponse( MT_SRSP_SYS, MT_SYS_ADC_READ,
// 1480                                 sizeof(retArray), retArray);
// 1481 }
// 1482 #endif /* !CC26XX */
// 1483 
// 1484 /******************************************************************************
// 1485  * @fn      MT_SysGpio
// 1486  *
// 1487  * @brief   ZAccel RPC interface for controlling the available GPIO pins.
// 1488  *
// 1489  * @param   uint8 pBuf - pointer to the data
// 1490  *
// 1491  * @return  None
// 1492  *****************************************************************************/
// 1493 static void MT_SysGpio(uint8 *pBuf)
// 1494 {
// 1495   uint8 val;
// 1496   GPIO_Op_t op;
// 1497 
// 1498   /* Skip over RPC header */
// 1499   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1500 
// 1501   op = (GPIO_Op_t)(*pBuf++);
// 1502   val = *pBuf;
// 1503 
// 1504   switch (op)
// 1505   {
// 1506     case GPIO_DIR:
// 1507       if (val & BV(0)) {GPIO_DIR_OUT(0);} else {GPIO_DIR_IN(0);}
// 1508       if (val & BV(1)) {GPIO_DIR_OUT(1);} else {GPIO_DIR_IN(1);}
// 1509       if (val & BV(2)) {GPIO_DIR_OUT(2);} else {GPIO_DIR_IN(2);}
// 1510       if (val & BV(3)) {GPIO_DIR_OUT(3);} else {GPIO_DIR_IN(3);}
// 1511       break;
// 1512 
// 1513     case GPIO_TRI:
// 1514       if(val & BV(0)) {GPIO_TRI(0);} else if(val & BV(4)) {GPIO_PULL_DN(0);} else {GPIO_PULL_UP(0);}
// 1515       if(val & BV(1)) {GPIO_TRI(1);} else if(val & BV(5)) {GPIO_PULL_DN(1);} else {GPIO_PULL_UP(1);}
// 1516       if(val & BV(2)) {GPIO_TRI(2);} else if(val & BV(6)) {GPIO_PULL_DN(2);} else {GPIO_PULL_UP(2);}
// 1517       if(val & BV(3)) {GPIO_TRI(3);} else if(val & BV(7)) {GPIO_PULL_DN(3);} else {GPIO_PULL_UP(3);}
// 1518       break;
// 1519 
// 1520     case GPIO_SET:
// 1521       if (val & BV(0)) {GPIO_SET(0);}
// 1522       if (val & BV(1)) {GPIO_SET(1);}
// 1523       if (val & BV(2)) {GPIO_SET(2);}
// 1524       if (val & BV(3)) {GPIO_SET(3);}
// 1525       break;
// 1526 
// 1527     case GPIO_CLR:
// 1528       if (val & BV(0)) {GPIO_CLR(0);}
// 1529       if (val & BV(1)) {GPIO_CLR(1);}
// 1530       if (val & BV(2)) {GPIO_CLR(2);}
// 1531       if (val & BV(3)) {GPIO_CLR(3);}
// 1532       break;
// 1533 
// 1534     case GPIO_TOG:
// 1535       if (val & BV(0)) {GPIO_TOG(0);}
// 1536       if (val & BV(1)) {GPIO_TOG(1);}
// 1537       if (val & BV(2)) {GPIO_TOG(2);}
// 1538       if (val & BV(3)) {GPIO_TOG(3);}
// 1539       break;
// 1540 
// 1541     case GPIO_GET:
// 1542       break;
// 1543 
// 1544     case GPIO_HiD:
// 1545       (val) ? GPIO_HiD_SET() :  GPIO_HiD_CLR();
// 1546       break;
// 1547 
// 1548     default:
// 1549       break;
// 1550   }
// 1551 
// 1552   val  = (GPIO_GET(0)) ? BV(0) : 0;
// 1553   val |= (GPIO_GET(1)) ? BV(1) : 0;
// 1554   val |= (GPIO_GET(2)) ? BV(2) : 0;
// 1555   val |= (GPIO_GET(3)) ? BV(3) : 0;
// 1556 
// 1557   /* Build and send back the response */
// 1558   MT_BuildAndSendZToolResponse( MT_SRSP_SYS, MT_SYS_GPIO,
// 1559                                 sizeof(val), &val);
// 1560 }
// 1561 
// 1562 /******************************************************************************
// 1563  * @fn      MT_SysStackTune
// 1564  *
// 1565  * @brief   RPC interface for tuning the stack parameters to adjust performance
// 1566  *
// 1567  * @param   uint8 pBuf - pointer to the data
// 1568  *
// 1569  * @return  None
// 1570  *****************************************************************************/
// 1571 static void MT_SysStackTune(uint8 *pBuf)
// 1572 {
// 1573   uint8 rtrn;
// 1574 
// 1575   /* Skip over RPC header */
// 1576   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1577 
// 1578   switch (*pBuf++)
// 1579   {
// 1580   case STK_TX_PWR:
// 1581     rtrn = ZMacSetReq(ZMacPhyTransmitPowerSigned, pBuf);
// 1582     break;
// 1583 
// 1584   case STK_RX_ON_IDLE:
// 1585     if ((*pBuf != TRUE) && (*pBuf != FALSE))
// 1586     {
// 1587       (void)ZMacGetReq(ZMacRxOnIdle, &rtrn);
// 1588     }
// 1589     else
// 1590     {
// 1591       rtrn = ZMacSetReq(ZMacRxOnIdle, pBuf);
// 1592     }
// 1593     break;
// 1594 
// 1595   default:
// 1596     rtrn = ZInvalidParameter;
// 1597     break;
// 1598   }
// 1599 
// 1600   MT_BuildAndSendZToolResponse( MT_SRSP_SYS, MT_SYS_STACK_TUNE,
// 1601                                 sizeof(rtrn), &rtrn);
// 1602 }
// 1603 
// 1604 /******************************************************************************
// 1605  * @fn      MT_SysSetUtcTime
// 1606  *
// 1607  * @brief   Set the OSAL UTC Time. UTC rollover is: 06:28:16 02/07/2136
// 1608  *
// 1609  * @param   pBuf - pointer to time parameters
// 1610  *
// 1611  * @return  None
// 1612  *****************************************************************************/
// 1613 static void MT_SysSetUtcTime(uint8 *pBuf)
// 1614 {
// 1615   uint8 retStat;
// 1616   UTCTime utcSecs;
// 1617 
// 1618   /* Skip over RPC header */
// 1619   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1620 
// 1621   utcSecs = osal_build_uint32( pBuf, 4 );
// 1622   if ( utcSecs == 0 )
// 1623   {
// 1624     UTCTimeStruct utc;
// 1625 
// 1626     /* Skip past UTC time */
// 1627     pBuf += 4;
// 1628 
// 1629     /* Get time and date parameters */
// 1630     utc.hour = *pBuf++;
// 1631     utc.minutes = *pBuf++;
// 1632     utc.seconds = *pBuf++;
// 1633     utc.month = (*pBuf++) - 1;
// 1634     utc.day = (*pBuf++) - 1;
// 1635     utc.year = osal_build_uint16 ( pBuf );
// 1636 
// 1637     if ((utc.hour < 24) && (utc.minutes < 60) && (utc.seconds < 60) &&
// 1638         (utc.month < 12) && (utc.day < 31) && (utc.year > 1999) && (utc.year < 2136))
// 1639     {
// 1640       /* Got past the course filter, now check for leap year */
// 1641       if ((utc.month != 1) || (utc.day < (IsLeapYear( utc.year ) ? 29 : 28)))
// 1642       {
// 1643         /* Numbers look reasonable, convert to UTC */
// 1644         utcSecs = osal_ConvertUTCSecs( &utc );
// 1645       }
// 1646     }
// 1647   }
// 1648 
// 1649   if ( utcSecs == 0 )
// 1650   {
// 1651     /* Bad parameter(s) */
// 1652     retStat = ZInvalidParameter;
// 1653   }
// 1654   else
// 1655   {
// 1656     /* Parameters accepted, set the time */
// 1657     osal_setClock( utcSecs );
// 1658     retStat = ZSuccess;
// 1659   }
// 1660 
// 1661   /* Build and send back the response */
// 1662   MT_BuildAndSendZToolResponse( MT_SRSP_SYS, MT_SYS_SET_TIME,
// 1663                                 sizeof(retStat), &retStat);
// 1664 }
// 1665 
// 1666 /******************************************************************************
// 1667  * @fn      MT_SysGetUtcTime
// 1668  *
// 1669  * @brief   Get the OSAL UTC time
// 1670  *
// 1671  * @param   None
// 1672  *
// 1673  * @return  32-bit and Parsed UTC time
// 1674  *****************************************************************************/
// 1675 static void MT_SysGetUtcTime(void)
// 1676 {
// 1677   uint8 len;
// 1678   uint8 *buf;
// 1679 
// 1680   len = sizeof( UTCTime ) + sizeof( UTCTimeStruct );
// 1681 
// 1682   buf = osal_mem_alloc( len );
// 1683   if ( buf )
// 1684   {
// 1685     uint8 *pBuf;
// 1686     UTCTime utcSecs;
// 1687     UTCTimeStruct utcTime;
// 1688 
// 1689     // Get current 32-bit UTC time and parse it
// 1690     utcSecs = osal_getClock();
// 1691     osal_ConvertUTCTime( &utcTime, utcSecs );
// 1692 
// 1693     // Start with 32-bit UTC time
// 1694     pBuf = osal_buffer_uint32( buf, utcSecs );
// 1695 
// 1696     // Concatenate parsed UTC time fields
// 1697     *pBuf++ = utcTime.hour;
// 1698     *pBuf++ = utcTime.minutes;
// 1699     *pBuf++ = utcTime.seconds;
// 1700     *pBuf++ = utcTime.month + 1;  // Convert to human numbers
// 1701     *pBuf++ = utcTime.day + 1;
// 1702     *pBuf++ = LO_UINT16( utcTime.year );
// 1703     *pBuf++ = HI_UINT16( utcTime.year );
// 1704 
// 1705     /* Build and send back the response */
// 1706     MT_BuildAndSendZToolResponse( MT_SRSP_SYS, MT_SYS_GET_TIME,
// 1707                                  (uint8)(pBuf-buf), buf);
// 1708 
// 1709     osal_mem_free( buf );
// 1710   }
// 1711 }
// 1712 
// 1713 /******************************************************************************
// 1714  * @fn      MT_SysSetTxPower
// 1715  *
// 1716  * @brief   Set the transmit power.
// 1717  *
// 1718  * @param   pBuf - MT message containing the ZMacTransmitPower_t power level to set.
// 1719  *
// 1720  * @return  None
// 1721  *****************************************************************************/
// 1722 static void MT_SysSetTxPower(uint8 *pBuf)
// 1723 {
// 1724   /* A local variable to hold the signed dBm value of TxPower that is being requested. */
// 1725   uint8 signed_dBm_of_TxPower_requeseted;
// 1726 
// 1727   /*
// 1728    * A local variable to hold the signed dBm value of TxPower that can be set which is closest to
// 1729    * the requested dBm value of TxPower, but which is also valid according to a complex set of
// 1730    * compile-time and run-time configuration which is interpreted by the macRadioSetTxPower()
// 1731    * function.
// 1732    */
// 1733   uint8 signed_dBm_of_TxPower_range_corrected;
// 1734 
// 1735   /* Parse the requested dBm from the RPC message. */
// 1736   signed_dBm_of_TxPower_requeseted = pBuf[MT_RPC_POS_DAT0];
// 1737 
// 1738   /*
// 1739    * MAC_MlmeSetReq() will store an out-of-range dBm parameter value into the NIB. So it is not
// 1740    * possible to learn the actual dBm value that will be set by invoking MACMlmeGetReq().
// 1741    * But this actual dBm value is a required return value in the SRSP to this SREQ. Therefore,
// 1742    * it is necessary to make this redundant pre-call to macRadioSetTxPower() here in order to run
// 1743    * the code that will properly constrain the requested dBm to a valid range based on both the
// 1744    * compile-time and the run-time configurations that affect the available valid ranges
// 1745    * (i.e. MAC_MlmeSetReq() itself will invoke for a second time the macRadioSetTxPower() function).
// 1746    */
// 1747   signed_dBm_of_TxPower_range_corrected = macRadioSetTxPower(signed_dBm_of_TxPower_requeseted);
// 1748 
// 1749   /*
// 1750    * Call the function to store the requested dBm in the MAC PIB and to set the TxPower as closely
// 1751    * as possible within the TxPower range that is valid for the compile-time and run-time
// 1752    * configuration.
// 1753    */
// 1754   (void)MAC_MlmeSetReq(MAC_PHY_TRANSMIT_POWER_SIGNED, &signed_dBm_of_TxPower_requeseted);
// 1755 
// 1756   /* Send back response that includes the actual dBm TxPower that can be set. */
// 1757   MT_BuildAndSendZToolResponse( MT_SRSP_SYS, MT_SYS_SET_TX_POWER, 1,
// 1758                                 &signed_dBm_of_TxPower_range_corrected);
// 1759 }
// 1760 
// 1761 #if defined ( FEATURE_SYSTEM_STATS )
// 1762 /******************************************************************************
// 1763  * @fn      MT_SysZDiagsInitStats
// 1764  *
// 1765  * @brief   Initialize the statistics table in NV or restore values from
// 1766  *          NV into the Statistics table in RAM
// 1767  *
// 1768  * @param   None
// 1769  *
// 1770  * @return  None
// 1771  *****************************************************************************/
// 1772 static void MT_SysZDiagsInitStats(void)
// 1773 {
// 1774   uint8 retValue;
// 1775 
// 1776   retValue = ZDiagsInitStats();
// 1777 
// 1778   /* Build and send back the response */
// 1779   MT_BuildAndSendZToolResponse( MT_SRSP_SYS, MT_SYS_ZDIAGS_INIT_STATS,
// 1780                                 sizeof(retValue), &retValue);
// 1781 }
// 1782 
// 1783 /******************************************************************************
// 1784  * @fn      MT_SysZDiagsClearStats
// 1785  *
// 1786  * @brief   Clears the statistics table in RAM and NV if option flag set.
// 1787  *
// 1788  * @param   uint8 pBuf - pointer to the data
// 1789  *
// 1790  * @return  None
// 1791  *****************************************************************************/
// 1792 static void MT_SysZDiagsClearStats(uint8 *pBuf)
// 1793 {
// 1794   uint32 sysClock;
// 1795   uint8 retBuf[4];
// 1796 
// 1797   /* parse header */
// 1798   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1799 
// 1800   /* returns the system clock of the time when the statistics were cleared */
// 1801   sysClock = ZDiagsClearStats( *pBuf );
// 1802 
// 1803   osal_buffer_uint32( retBuf, sysClock );
// 1804 
// 1805   /* Build and send back the response */
// 1806   MT_BuildAndSendZToolResponse( MT_SRSP_SYS, MT_SYS_ZDIAGS_CLEAR_STATS,
// 1807                                 sizeof(retBuf), retBuf);
// 1808 }
// 1809 
// 1810 /******************************************************************************
// 1811  * @fn      MT_SysZDiagsGetStatsAttr
// 1812  *
// 1813  * @brief   Reads specific system (attribute) ID statistics and/or metrics.
// 1814  *
// 1815  * @param   uint8 pBuf - pointer to the data
// 1816  *
// 1817  * @return  None
// 1818  *****************************************************************************/
// 1819 static void MT_SysZDiagsGetStatsAttr(uint8 *pBuf)
// 1820 {
// 1821   uint16 attrId;
// 1822   uint32 attrValue;
// 1823   uint8 retBuf[4];
// 1824 
// 1825   /* parse header */
// 1826   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1827 
// 1828   /* Get the Attribute ID */
// 1829   attrId = osal_build_uint16( pBuf );
// 1830 
// 1831   attrValue = ZDiagsGetStatsAttr( attrId );
// 1832 
// 1833   osal_buffer_uint32( retBuf, attrValue );
// 1834 
// 1835   /* Build and send back the response */
// 1836   MT_BuildAndSendZToolResponse( MT_SRSP_SYS, MT_SYS_ZDIAGS_GET_STATS,
// 1837                                 sizeof(retBuf), retBuf);
// 1838 }
// 1839 
// 1840 /******************************************************************************
// 1841  * @fn      MT_SysZDiagsRestoreStatsFromNV
// 1842  *
// 1843  * @brief   Restores the statistics table from NV into the RAM table.
// 1844  *
// 1845  * @param   None
// 1846  *
// 1847  * @return  None
// 1848  *****************************************************************************/
// 1849 static void MT_SysZDiagsRestoreStatsFromNV(void)
// 1850 {
// 1851   uint8 retValue;
// 1852 
// 1853   retValue = ZDiagsRestoreStatsFromNV();
// 1854 
// 1855   /* Build and send back the response */
// 1856   MT_BuildAndSendZToolResponse( MT_SRSP_SYS, MT_SYS_ZDIAGS_RESTORE_STATS_NV,
// 1857                                 sizeof(retValue), &retValue);
// 1858 }
// 1859 
// 1860 /******************************************************************************
// 1861  * @fn      MT_SysZDiagsSaveStatsToNV
// 1862  *
// 1863  * @brief   Saves the statistics table from RAM to NV.
// 1864  *
// 1865  * @param   None
// 1866  *
// 1867  * @return  None
// 1868  *****************************************************************************/
// 1869 static void MT_SysZDiagsSaveStatsToNV(void)
// 1870 {
// 1871   uint32 sysClock;
// 1872   uint8 retBuf[4];
// 1873 
// 1874   /* Returns system clock of the time when the statistics were saved to NV */
// 1875   sysClock = ZDiagsSaveStatsToNV();
// 1876 
// 1877   osal_buffer_uint32( retBuf, sysClock );
// 1878 
// 1879   /* Build and send back the response */
// 1880   MT_BuildAndSendZToolResponse( MT_SRSP_SYS, MT_SYS_ZDIAGS_SAVE_STATS_TO_NV,
// 1881                                 sizeof(retBuf), retBuf);
// 1882 }
// 1883 #endif /* FEATURE_SYSTEM_STATS */
// 1884 #endif /* MT_SYS_FUNC */
// 1885 
// 1886 /******************************************************************************
// 1887  * SUPPORT
// 1888  *****************************************************************************/
// 1889 
// 1890 /******************************************************************************
// 1891  * @fn      MT_SysResetInd()
// 1892  *
// 1893  * @brief   Sends a ZTOOL "reset response" message.
// 1894  *
// 1895  * @param   None
// 1896  *
// 1897  * @return  None
// 1898  *
// 1899  *****************************************************************************/

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
// 1900 void MT_SysResetInd(void)
MT_SysResetInd:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function MT_SysResetInd
        CODE
// 1901 {
        FUNCALL MT_SysResetInd, osal_memcpy
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 20, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 20, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL MT_SysResetInd, MT_BuildAndSendZToolResponse
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 17, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 17, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        REQUIRE ?V0
        REQUIRE ?V1
        REQUIRE ?V2
        MOV       A,#-0xb
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 11)
        ; Saved register size: 11
        ; Auto size: 6
        MOV       A,#-0x6
        LCALL     ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 17)
// 1902   uint8 retArray[6];
// 1903 
// 1904   retArray[0] = ResetReason();   /* Reason */
        MOV       A,0x9d
        RRC       A
        RRC       A
        RRC       A
        ANL       A,#0x1f
        ANL       A,#0x3
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOVX      @DPTR,A
// 1905   osal_memcpy( &retArray[1], MTVersionString, 5 );   /* Revision info */
        ; Setup parameters for call to function osal_memcpy
        MOV       ?V0,#MTVersionString & 0xff
        MOV       ?V1,#(MTVersionString >> 8) & 0xff
        MOV       ?V2,#0x0
        MOV       R0,#?V0
        LCALL     ?PUSH_XSTACK_I_THREE
          CFI CFA_XSP16 add(XSP16, 20)
        MOV       R4,#0x5
        MOV       R5,#0x0
        MOV       A,#0x4
        LCALL     ?XSTACK_DISP0_8
        MOV       R2,DPL
        MOV       R3,DPH
        LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
        MOV       A,#0x3
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 17)
// 1906 
// 1907   /* Send out Reset Response message */
// 1908   MT_BuildAndSendZToolResponse( MT_ARSP_SYS, MT_SYS_RESET_IND,
// 1909                                 sizeof(retArray), retArray);
        ; Setup parameters for call to function MT_BuildAndSendZToolResponse
        MOV       R4,?XSP + 0
        MOV       R5,?XSP + 1
        MOV       R3,#0x6
        MOV       R2,#-0x80
        MOV       R1,#0x41
        LCALL     `??MT_BuildAndSendZToolResponse::?relay`; Banked call to: MT_BuildAndSendZToolResponse
// 1910 }
        MOV       A,#0x6
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 11)
        MOV       R7,#0x3
        LJMP      ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock0
        REQUIRE SLEEPSTA
// 1911 
// 1912 /******************************************************************************
// 1913  * @fn      MT_SysOsalTimerExpired()
// 1914  *
// 1915  * @brief   Sends a SYS Osal Timer Expired
// 1916  *
// 1917  * @param   None
// 1918  *
// 1919  * @return  None
// 1920  *
// 1921  *****************************************************************************/

        RSEG BANKED_CODE:HUGECODE:NOROOT(0)
// 1922 void MT_SysOsalTimerExpired(uint8 Id)
MT_SysOsalTimerExpired:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function MT_SysOsalTimerExpired
        CODE
// 1923 {
        FUNCALL MT_SysOsalTimerExpired, MT_BuildAndSendZToolResponse
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV       A,#-0x9
        LCALL     ?BANKED_ENTER_XDATA
          CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
          CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
          CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
          CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
          CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
          CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
          CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-7)))
          CFI VB load(1, XDATA, add(CFA_XSP16, literal(-8)))
          CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-9)))
          CFI CFA_SP SP+0
          CFI CFA_XSP16 add(XSP16, 9)
        ; Saved register size: 9
        ; Auto size: 1
        MOV       A,#-0x1
        LCALL     ?ALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 10)
        MOV       A,R1
// 1924   uint8 retValue = Id;
        MOV       DPL,?XSP + 0
        MOV       DPH,?XSP + 1
        MOVX      @DPTR,A
// 1925 
// 1926   MT_BuildAndSendZToolResponse( MT_ARSP_SYS, MT_SYS_OSAL_TIMER_EXPIRED,
// 1927                                 sizeof(retValue), &retValue);
        ; Setup parameters for call to function MT_BuildAndSendZToolResponse
        MOV       R4,?XSP + 0
        MOV       R5,?XSP + 1
        MOV       R3,#0x1
        MOV       R2,#-0x7f
        MOV       R1,#0x41
        LCALL     `??MT_BuildAndSendZToolResponse::?relay`; Banked call to: MT_BuildAndSendZToolResponse
// 1928 }
        MOV       A,#0x1
        LCALL     ?DEALLOC_XSTACK8
          CFI CFA_XSP16 add(XSP16, 9)
        MOV       R7,#0x1
        LJMP      ?BANKED_LEAVE_XDATA
          CFI EndBlock cfiBlock1

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??MT_SysResetInd::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    MT_SysResetInd

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
`??MT_SysOsalTimerExpired::?relay`:
        CODE
        LCALL   ?BDISPATCH
        DATA24
        DC24    MT_SysOsalTimerExpired

        END
// 1929 
// 1930 #if defined ( MT_SYS_JAMMER_FEATURE )
// 1931 /******************************************************************************
// 1932  * @fn      MT_SysJammerParameters
// 1933  *
// 1934  * @brief   Set the Jammer detection parameters.
// 1935  *
// 1936  * @param   pBuf - MT message containing the parameters.
// 1937  *
// 1938  * @return  None
// 1939  *****************************************************************************/
// 1940 static void MT_SysJammerParameters( uint8 *pBuf )
// 1941 {
// 1942   uint8 status = SUCCESS;
// 1943 
// 1944   // Adjust for the data
// 1945   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1946 
// 1947   // Number of continuous events needed to detect Jam
// 1948   jammerContinuousEvents = osal_build_uint16( pBuf );
// 1949   jammerDetections = jammerContinuousEvents;
// 1950   pBuf += 2;
// 1951 
// 1952   // Noise Level need to be a Jam
// 1953   jammerHighNoiseLevel = *pBuf++;
// 1954 
// 1955   // The time between each noise level reading
// 1956   jammerDetectPeriodTime = osal_build_uint32( pBuf, 4 );
// 1957 
// 1958   // Update the timer
// 1959   osal_start_reload_timer( jammerTaskID, JAMMER_CHECK_EVT, jammerDetectPeriodTime );
// 1960 
// 1961   /* Send out Reset Response message */
// 1962   MT_BuildAndSendZToolResponse( MT_SRSP_SYS, MT_SYS_JAMMER_PARAMETERS,
// 1963                                 sizeof(status), &status );
// 1964 }
// 1965 
// 1966 /******************************************************************************
// 1967  * @fn      MT_SysJammerInd()
// 1968  *
// 1969  * @brief   Sends a jammer indication message.
// 1970  *
// 1971  * @param   jammerInd - TRUE if jammer detected, FALSE if changed to undetected
// 1972  *
// 1973  * @return  None
// 1974  *
// 1975  *****************************************************************************/
// 1976 void MT_SysJammerInd( uint8 jammerInd )
// 1977 {
// 1978   /* Send out Reset Response message */
// 1979   MT_BuildAndSendZToolResponse( MT_ARSP_SYS, MT_SYS_JAMMER_IND,
// 1980                                 sizeof(jammerInd), &jammerInd );
// 1981 }
// 1982 
// 1983 /******************************************************************************
// 1984  * @fn      jammerInit()
// 1985  *
// 1986  * @brief   Jammer Detection task initialization function
// 1987  *
// 1988  * @param   taskId - task ID
// 1989  *
// 1990  * @return  None
// 1991  *
// 1992  *****************************************************************************/
// 1993 void jammerInit( uint8 taskId )
// 1994 {
// 1995   jammerTaskID = taskId;
// 1996 
// 1997   // Start the jammer check timer
// 1998   osal_start_reload_timer( taskId, JAMMER_CHECK_EVT, jammerDetectPeriodTime );
// 1999 }
// 2000 
// 2001 /******************************************************************************
// 2002  * @fn      jammerEventLoop()
// 2003  *
// 2004  * @brief   Jammer Detection task event processing function
// 2005  *
// 2006  * @param   taskId - task ID
// 2007  * @param   events - task events
// 2008  *
// 2009  * @return  remaining events
// 2010  *
// 2011  *****************************************************************************/
// 2012 uint16 jammerEventLoop( uint8 taskId, uint16 events )
// 2013 {
// 2014   osal_event_hdr_t  *pMsg;
// 2015 
// 2016   if (events & SYS_EVENT_MSG)
// 2017   {
// 2018     if ( (pMsg = (osal_event_hdr_t *) osal_msg_receive( taskId )) != NULL )
// 2019     {
// 2020       switch ( pMsg->event )
// 2021       {
// 2022         default:
// 2023           break;
// 2024       }
// 2025 
// 2026       osal_msg_deallocate( (byte *)pMsg );
// 2027     }
// 2028 
// 2029     events ^= SYS_EVENT_MSG;
// 2030   }
// 2031   else if ( events & JAMMER_CHECK_EVT )
// 2032   {
// 2033 #ifdef FEATURE_DUAL_MAC
// 2034     if ( DMMGR_IsDefaultMac() )
// 2035 #endif /* FEATURE_DUAL_MAC */
// 2036     {
// 2037     // Make sure we aren't currently receiving a message and radio is active.
// 2038     if ( MAC_RX_IS_PHYSICALLY_ACTIVE() == MAC_RX_ACTIVE_NO_ACTIVITY )
// 2039     {
// 2040       int8 rssiDbm = -128;
// 2041 
// 2042       // Read the noise level
// 2043       if ( RSSISTAT & 0x01 )
// 2044       {
// 2045         /* Add the RSSI offset */
// 2046         rssiDbm = RSSI + MAC_RADIO_RSSI_OFFSET;
// 2047 
// 2048         /* Adjust for external PA/LNA, if any */
// 2049         MAC_RADIO_RSSI_LNA_OFFSET( rssiDbm );
// 2050 
// 2051         // Check for a noise level that's high
// 2052         if ( jammerDetections && (rssiDbm  > jammerHighNoiseLevel) )
// 2053         {
// 2054           jammerDetections--;
// 2055           if ( jammerDetections == 0 )
// 2056           {
// 2057             // Jam detected
// 2058             MT_SysJammerInd( TRUE );
// 2059           }
// 2060         }
// 2061         else if ( rssiDbm <= jammerHighNoiseLevel )
// 2062         {
// 2063           if ( jammerDetections == 0 )
// 2064           {
// 2065             // Jam cleared
// 2066             MT_SysJammerInd( FALSE );
// 2067           }
// 2068           jammerDetections = jammerContinuousEvents;
// 2069         }
// 2070       }
// 2071     }
// 2072     }
// 2073     events ^= JAMMER_CHECK_EVT;
// 2074   }
// 2075   else
// 2076   {
// 2077     events = 0;  /* Discard unknown events. */
// 2078   }
// 2079 
// 2080   return ( events );
// 2081 }
// 2082 #endif // MT_SYS_JAMMER_FEATURE
// 2083 
// 2084 #if defined ( MT_SYS_SNIFFER_FEATURE )
// 2085 /******************************************************************************
// 2086  * @fn      MT_SysSnifferParameters
// 2087  *
// 2088  * @brief   Set the sniffer parameters.
// 2089  *
// 2090  * @param   pBuf - MT message containing the parameters.
// 2091  *
// 2092  * @return  None
// 2093  *****************************************************************************/
// 2094 static void MT_SysSnifferParameters( uint8 *pBuf )
// 2095 {
// 2096   uint8 status = SUCCESS;
// 2097   uint8 param;
// 2098 
// 2099   // Adjust for the data
// 2100   pBuf += MT_RPC_FRAME_HDR_SZ;
// 2101 
// 2102   // Noise Level need to be a Jam
// 2103   param = *pBuf;
// 2104 
// 2105   if ( param == MT_SYS_SNIFFER_DISABLE )
// 2106   {
// 2107     // Disable Sniffer
// 2108     HAL_BOARD_DISABLE_INTEGRATED_SNIFFER();
// 2109     sniffer = FALSE;
// 2110   }
// 2111   else if ( param == MT_SYS_SNIFFER_ENABLE )
// 2112   {
// 2113     // Enable the Sniffer
// 2114     HAL_BOARD_ENABLE_INTEGRATED_SNIFFER();
// 2115     sniffer = TRUE;
// 2116   }
// 2117   else if ( param == MT_SYS_SNIFFER_GET_SETTING )
// 2118   {
// 2119     status = sniffer; // sniffer setting
// 2120   }
// 2121   else
// 2122   {
// 2123     status = INVALIDPARAMETER;
// 2124   }
// 2125 
// 2126   /* Send back response that includes the actual dBm TxPower that can be set. */
// 2127   MT_BuildAndSendZToolResponse( MT_SRSP_SYS, MT_SYS_SNIFFER_PARAMETERS,
// 2128                                 sizeof(status), &status );
// 2129 }
// 2130 #endif // MT_SYS_SNIFFER_FEATURE
// 2131 
// 2132 #if defined( ENABLE_MT_SYS_RESET_SHUTDOWN )
// 2133 /******************************************************************************
// 2134  * @fn          powerOffSoc
// 2135  *
// 2136  * @brief   Put the device in lowest power mode infinitely
// 2137  *
// 2138  * @param   None
// 2139  *
// 2140  * @return  None
// 2141  *****************************************************************************/
// 2142 static void powerOffSoc(void)
// 2143 {
// 2144   HAL_DISABLE_INTERRUPTS();
// 2145 
// 2146   /* turn off the RF front end device */
// 2147   //TBD, based on the rf-front-end being used
// 2148 
// 2149   /* turn off the receiver */
// 2150   MAC_RADIO_RXTX_OFF();
// 2151 
// 2152   /* just in case a receive was about to start, flush the receive FIFO */
// 2153   MAC_RADIO_FLUSH_RX_FIFO();
// 2154 
// 2155   /* clear any receive interrupt that happened to squeak through */
// 2156   MAC_RADIO_CLEAR_RX_THRESHOLD_INTERRUPT_FLAG();
// 2157 
// 2158   /* put MAC timer to sleep */
// 2159   MAC_RADIO_TIMER_SLEEP();
// 2160 
// 2161   /* power of radio */
// 2162   MAC_RADIO_TURN_OFF_POWER();
// 2163 
// 2164   STIF = 0; //HAL_SLEEP_TIMER_CLEAR_INT;
// 2165 
// 2166   if (ZNP_CFG1_UART == znpCfg1)
// 2167   {
// 2168     HalUARTSuspend();
// 2169   }
// 2170 
// 2171   /* Prep CC2530 power mode */
// 2172   //HAL_SLEEP_PREP_POWER_MODE(3);
// 2173   SLEEPCMD &= ~PMODE; /* clear mode bits */
// 2174   SLEEPCMD |= 3;      /* set mode bits  to PM3 */
// 2175   while (!(STLOAD & LDRDY));
// 2176 
// 2177   while (1) //just in case we wake up for some unknown reason
// 2178   {
// 2179     /* Execution is supposed to halt at this instruction. Interrupts are
// 2180        disabled - the only way to exit this state is from hardware reset. */
// 2181     PCON = halSleepPconValue;
// 2182     asm("NOP");
// 2183   }
// 2184 }
// 2185 #endif
// 2186 
// 2187 /******************************************************************************
// 2188  *****************************************************************************/
// 
// 125 bytes in segment BANKED_CODE
//  12 bytes in segment BANK_RELAYS
//   1 byte  in segment SFR_AN
// 
//  12 bytes of CODE     memory
//   0 bytes of DATA     memory (+ 1 byte shared)
// 125 bytes of HUGECODE memory
//
//Errors: none
//Warnings: none
