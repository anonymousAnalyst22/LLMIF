###############################################################################
#
# IAR C/C++ Compiler V10.10.1.4655 for 8051               22/Nov/2023  15:42:40
# Copyright 2004-2017 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        D:\fuzzing-coordinator-response-collection\Components\stack\bdb\bdb.c
#    Command line       =  
#        -f C:\Users\ADMINI~1\AppData\Local\Temp\EW98A9.tmp
#        (D:\fuzzing-coordinator-response-collection\Components\stack\bdb\bdb.c
#        -D SECURE=1 -D TC_LINKKEY_JOIN -D NV_INIT -D NV_RESTORE -D
#        MULTICAST_ENABLED=FALSE -D ZCL_READ -D ZCL_DISCOVER -D ZCL_WRITE -D
#        ZCL_BASIC -D ZCL_IDENTIFY -D ISR_KEYINTERRUPT -D HAL_UART=TRUE -D
#        HAL_LCD=FALSE -D ZCL_ON_OFF -D INT_HEAP_LEN=2800 -D
#        HAL_UART_DMA_RX_MAX=256 -D HAL_UART_DMA_TX_MAX=256 -lC
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\CoordinatorEB\List
#        -lA
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\CoordinatorEB\List
#        --diag_suppress Pe001,Pa010 -o
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\CoordinatorEB\Obj
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 8 -f
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DZDO_COORDINATOR -DRTR_NWK) -f
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x00, 0x01, 0x02, 0x03,
#        0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
#        0x0F}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440 -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000
#        -DENABLE_LED4_DISABLE_S1) -f
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg
#        -I
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\
#        -I
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\Source\
#        -I
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\Source\
#        -I
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\ZMain\TI2530DB\
#        -I
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\include\
#        -I
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\
#        -I
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\include\
#        -I
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\high_level\
#        -I
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\
#        -I
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\
#        -I
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mt\
#        -I
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\osal\include\
#        -I
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\services\saddr\
#        -I
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\services\sdata\
#        -I
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\af\
#        -I
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\bdb\
#        -I
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\gp\
#        -I
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\nwk\
#        -I
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sapi\
#        -I
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sec\
#        -I
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sys\
#        -I
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\zcl\
#        -I
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\zdo\
#        -I
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\zmac\
#        -I
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\zmac\f8w\
#        -I
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\Common\
#        -I
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\SPI\
#        -I
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\HW_LCD\Font\
#        -I
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\HW_LCD\HAL_LCD_SPI\
#        -I
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\HW_LCD\HAL_OLED\
#        -I
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\HW_LCD\HAL_TFT\
#        -Ohz --require_prototypes)
#    Locale             =  Chinese (Simplified)_China.936
#    List file          =  
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\CoordinatorEB\List\bdb.lst
#    Object file        =  
#        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\CoordinatorEB\Obj\bdb.r51
#
###############################################################################

D:\fuzzing-coordinator-response-collection\Components\stack\bdb\bdb.c
      1          /**************************************************************************************************
      2            Filename:       bdb.c
      3            Revised:        $Date: 2016-02-25 11:51:49 -0700 (Thu, 25 Feb 2016) $
      4            Revision:       $Revision: - $
      5          
      6            Description:    This file contains the Base Device Behavior functions and attributes.
      7          
      8          
      9            Copyright 2006-2015 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          
     44          #include "bdb.h"
     45          #include "ZDApp.h"
     46          #include "OSAL.h"
     47          #include "ZDConfig.h"
     48          #include "hal_led.h"
     49          #include "ZDObject.h"
     50          #include "OSAL_Nv.h"
     51          #include "AddrMgr.h"
     52          #include "ZDSecMgr.h"
     53          #include "nwk.h"
     54          #include "nwk_util.h"
     55          #include "ssp_hash.h"
     56          #ifdef BDB_REPORTING
     57          #include "bdb_Reporting.h"
     58          #endif 
     59          
     60          #if !defined (DISABLE_GREENPOWER_BASIC_PROXY) && (ZG_BUILD_RTR_TYPE)
     61          #include "gp_interface.h"
     62          #include "gp_common.h"
     63          #include "dgp_stub.h"
     64          #endif
     65          
     66          #include "bdb_interface.h"
     67          
     68          #include <stdio.h>
     69          
     70          #if defined ( INTER_PAN ) 
     71          #if defined ( BDB_TL_INITIATOR )  
     72          #include "bdb_touchlink_initiator.h"
     73          #endif
     74          #if defined ( BDB_TL_TARGET )  
     75          #include "bdb_touchlink_target.h"
     76          #endif
     77          #endif
     78             
     79          #if defined ( INTER_PAN ) && ( defined ( BDB_TL_INITIATOR ) || defined ( BDB_TL_TARGET ) )
     80            #include "bdb_touchlink.h"
     81          #endif
     82           
     83          #ifdef MT_APP_CNF_FUNC
     84          #include "MT_APP_CONFIG.h"
     85          #endif
     86             
     87           /*********************************************************************
     88           * MACROS
     89           */
     90          //This is actually the channels used
     91          #define vScanChannels  zgDefaultChannelList
     92             
     93           /*********************************************************************
     94           * CONSTANTS
     95           */
     96          
     97          #define NUMBER_OF_CHANNELS     16
     98          
     99          #define CHANNEL_11_MASK_POS    11
    100          #define CHANNEL_26_MASK_POS    26
    101             

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    102          uint8 bdb_FB_InitiatorCurrentCyclesNumber = 0; //last cycle is #1 (i.e. cycles-left = (bdb_FB_InitiatorCurrentCyclesNumber - 1))
   \                     bdb_FB_InitiatorCurrentCyclesNumber:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    103          
    104          /*********************************************************************
    105           * TYPEDEFS
    106           */
    107           
    108           
    109           /*********************************************************************
    110           * GLOBAL VARIABLES
    111           */
    112          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    113          byte bdb_TaskID;
   \                     bdb_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_I, align 1, keep-with-next
    114          bdbAttributes_t bdbAttributes = BDB_ATTRIBUTES_DEFAULT_CONFIG;
   \                     bdbAttributes:
   \   000000                DS 18
   \   000012                REQUIRE `?<Initializer for bdbAttributes>`
   \   000012                REQUIRE __INIT_XDATA_I

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    115          epList_t *bdb_HeadEpDescriptorList = NULL;
   \                     bdb_HeadEpDescriptorList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    116          epList_t *bdb_CurrEpDescriptorList = NULL;
   \                     bdb_CurrEpDescriptorList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    117          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    118          bdbFindingBindingRespondent_t *pRespondentHead = NULL;
   \                     pRespondentHead:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    119          bdbFindingBindingRespondent_t *pRespondentCurr = NULL;
   \                     pRespondentCurr:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    120          bdbFindingBindingRespondent_t *pRespondentNext = NULL;
   \                     pRespondentNext:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    121          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    122          bdbCommissioningProcedureState_t bdbCommissioningProcedureState; 
   \                     bdbCommissioningProcedureState:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    123          bool bdb_initialization = FALSE;  //Variable to tell if the initialization process has been started
   \                     bdb_initialization:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    124          
    125          //Nwk formation and nwk steering for nodes not in nwk

   \                                 In  segment XDATA_I, align 1, keep-with-next
    126          bool vDoPrimaryScan = TRUE;
   \                     vDoPrimaryScan:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for vDoPrimaryScan>`
   \   000001                REQUIRE __INIT_XDATA_I
    127          

   \                                 In  segment XDATA_I, align 1, keep-with-next
    128          uint8 zgBdbInstallCodeCRC[INSTALL_CODE_LEN + INSTALL_CODE_CRC_LEN] = {0x83,0xFE,0xD3,0x40,0x7A,0x93,0x97,0x23,0xA5,0xC6,0x39,0xB2,0x69,0x16,0xD5,0x05,0xC3,0xB5};
   \                     zgBdbInstallCodeCRC:
   \   000000                DS 18
   \   000012                REQUIRE `?<Initializer for zgBdbInstallCodeCRC>`
   \   000012                REQUIRE __INIT_XDATA_I
    129          
    130          //Pointer of the nwk being tried in association process
    131          #if (ZG_BUILD_JOINING_TYPE)
    132          static networkDesc_t *pBDBListNwk = NULL;
    133          #endif
    134          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    135          uint8 bdb_ZclTransactionSequenceNumber=0x00;
   \                     bdb_ZclTransactionSequenceNumber:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    136          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    137          bool touchLinkTargetEnabled = FALSE;
   \                     touchLinkTargetEnabled:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    138          
    139           /*********************************************************************
    140           * EXTERNAL VARIABLES
    141           */
    142          
    143          extern devStartModes_t devStartMode;
    144          extern bool  requestNewTrustCenterLinkKey;
    145          extern uint32 requestLinkKeyTimeout;
    146          extern uint32 ZDApp_SavedPollRate;
    147          
    148          #if (BDB_FINDING_BINDING_CAPABILITY_ENABLED==1)
    149          extern bdbGCB_IdentifyTimeChange_t pfnIdentifyTimeChangeCB;
    150          extern uint8 bdbIndentifyActiveEndpoint;
    151          #endif
    152          
    153          extern bdbFindingBindingRespondent_t *pRespondentNext;
    154          
    155          #ifndef DISABLE_GREENPOWER_BASIC_PROXY
    156          extern ZDO_DeviceAnnce_t aliasConflictAnnce;
    157          #endif
    158          
    159          /*********************************************************************
    160           * EXTERNAL FUNCTIONS
    161           */
    162          
    163          extern void ZDApp_ResetTimerStart( uint16 delay );
    164          extern void ZDApp_NodeProfileSync( uint8 stackProfile );
    165          extern uint8 ZDApp_RestoreNwkKey( uint8 incrFrmCnt );
    166          extern uint8 ZDApp_ReadNetworkRestoreState( void );
    167          
    168          extern bdbFindingBindingRespondent_t* bdb_getRespondentRetry(bdbFindingBindingRespondent_t* pRespondentHead);
    169          extern void bdb_ProcessSimpleDesc( zdoIncomingMsg_t *msgPtr );
    170          extern void bdb_ProcessIEEEAddrRsp(zdoIncomingMsg_t *pMsg);
    171          
    172          /*********************************************************************
    173           * LOCAL VARIABLES
    174           */
    175          #if (ZG_BUILD_JOINING_TYPE)
    176            static uint8 bdb_nwkAssocRetriesCount = 0;
    177          #endif
    178          #if (ZG_BUILD_COORDINATOR_TYPE)

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    179            static bdb_joiningDeviceList_t *bdb_joiningDeviceList = NULL;
   \                     bdb_joiningDeviceList:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    180          #endif
    181            
    182          #if (BDB_FINDING_BINDING_CAPABILITY_ENABLED==1) 
    183          //Latch to save the status success of any attempt in the periodic F&B process  

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    184          static uint8 bdb_FBStateSuccessLatch = FALSE;
   \                     bdb_FBStateSuccessLatch:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    185          #endif
    186           /*********************************************************************
    187           * LOCAL FUNCTIONS
    188           */
    189          static void bdb_ProcessOSALMsg(bdbInMsg_t *msgPtr);
    190          void bdb_NotifyCommissioningModeStart(uint8 commissioningMode);
    191          static void bdb_processZDOMgs(zdoIncomingMsg_t *pMsg);
    192          
    193          #if (ZG_BUILD_JOINING_TYPE)
    194          static void bdb_requestTCStackVersion(void);
    195          static void bdb_requestTCLinkKey(void);
    196          static void bdb_requestVerifyTCLinkKey(void);
    197          static void bdb_tryNwkAssoc(void);
    198          #endif
    199          
    200          
    201          static void bdb_processTimeout(void);
    202          static void bdb_startResumeCommissioningProcess(void);
    203          static void bdb_nwkSteeringDeviceOnNwk(void);
    204          static void bdb_nwkJoiningFormation(bool isJoining);
    205          
    206          #if !defined (DISABLE_GREENPOWER_BASIC_PROXY) && (ZG_BUILD_RTR_TYPE)
    207          static uint8 gp_ChangeChannelReq(void);
    208          static void gp_CBInit(void);
    209          #endif
    210          
    211          
    212          #if (ZG_BUILD_COORDINATOR_TYPE)
    213          static void bdb_TCProcessJoiningList(void);
    214          static ZStatus_t bdb_TCJoiningDeviceFree(bdb_joiningDeviceList_t* JoiningDeviceToRemove);
    215          #endif
    216          #if (ZG_BUILD_COORDINATOR_TYPE)

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    217          static bdbGCB_TCLinkKeyExchangeProcess_t  pfnTCLinkKeyExchangeProcessCB = NULL;
   \                     pfnTCLinkKeyExchangeProcessCB:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    218          #endif

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    219          static bdbGCB_CommissioningStatus_t       pfnCommissioningStatusCB = NULL; 
   \                     pfnCommissioningStatusCB:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    220          #if (ZG_BUILD_JOINING_TYPE)
    221          static bdbGCB_CBKETCLinkKeyExchange_t     pfnCBKETCLinkKeyExchange = NULL;
    222          static bdbGCB_FilterNwkDesc_t             pfnFilterNwkDesc = NULL;   
    223          #endif
    224          
    225          
    226          
    227          void bdb_calculateCCITT_CRC (uint8 *Mb, uint32 msglen, uint16 *crc);
    228          void bdb_crcInit(uint16 *crc, uint16 *crcinit_direct, uint16 *crcinit_nondirect);
    229          uint16 bdb_crcReflect (uint16 crc, uint16 bitnum);
    230          uint16 bdb_crcBitByBitFast(uint8 * p, uint32 len, uint16 crcinit_direct, uint16 crcinit_nondirect);
    231          void bdb_ProcessNodeDescRsp(zdoIncomingMsg_t *pMsg);
    232          
    233          /*********************************************************************
    234           * PUBLIC FUNCTIONS
    235           *********************************************************************/
    236          void bdb_filterNwkDisc(void);
    237          ZStatus_t bdb_joinProcess(networkDesc_t *pChosenNwk);
    238          
    239          ZStatus_t bdb_TCAddJoiningDevice(uint16 parentAddr, uint8* JoiningExtAddr);
    240          void bdb_TCjoiningDeviceComplete(uint8* JoiningExtAddr);
    241          
    242           /*********************************************************************
    243           * @fn          bdb_Init
    244           *
    245           * @brief       Initialization function for the Base Device Behavior.
    246           *
    247           * @param       task_id - bdb_TaskID Task ID
    248           *
    249           * @return      none
    250           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    251          void bdb_Init( byte task_id )
   \                     bdb_Init:
    252          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
    253            bdb_TaskID = task_id;
   \   000007   90....       MOV       DPTR,#bdb_TaskID
   \   00000A   F0           MOVX      @DPTR,A
    254              
    255          #if (ZG_BUILD_COORDINATOR_TYPE)
    256            if(ZG_DEVICE_COORDINATOR_TYPE)
    257            {
    258              if(bdbAttributes.bdbJoinUsesInstallCodeKey)
   \   00000B   90....       MOV       DPTR,#bdbAttributes + 15
   \   00000E   E0           MOVX      A,@DPTR
   \   00000F   6006         JZ        ??bdb_Init_0
    259              {
    260                zgAllowInstallCodes = ZG_IC_MUST_USED;
   \   000011   90....       MOV       DPTR,#zgAllowInstallCodes
   \   000014   7402         MOV       A,#0x2
   \   000016   F0           MOVX      @DPTR,A
    261              }
    262            }
    263          #endif
    264            
    265          #if defined ( INTER_PAN ) && defined ( BDB_TL_INITIATOR )  
    266            touchLinkInitiator_InitDevice( );
    267          #endif
    268          
    269          #if (BDB_REPORTING)
    270            bdb_RepInit();
    271          #endif  
    272            
    273            //Register ZDO callbacks
    274            ZDO_RegisterForZDOMsg ( task_id, Node_Desc_rsp );
   \                     ??bdb_Init_0:
   \   000017                ; Setup parameters for call to function ZDO_RegisterForZDOMsg
   \   000017   7A02         MOV       R2,#0x2
   \   000019   7B80         MOV       R3,#-0x80
   \   00001B   12....       LCALL     `??ZDO_RegisterForZDOMsg::?relay`; Banked call to: ZDO_RegisterForZDOMsg
    275          #if (BDB_FINDING_BINDING_CAPABILITY_ENABLED==1)  
    276            ZDO_RegisterForZDOMsg ( task_id, IEEE_addr_rsp );
   \   00001E                ; Setup parameters for call to function ZDO_RegisterForZDOMsg
   \   00001E   7A01         MOV       R2,#0x1
   \   000020   7B80         MOV       R3,#-0x80
   \   000022   EE           MOV       A,R6
   \   000023   F9           MOV       R1,A
   \   000024   12....       LCALL     `??ZDO_RegisterForZDOMsg::?relay`; Banked call to: ZDO_RegisterForZDOMsg
    277            ZDO_RegisterForZDOMsg ( task_id, Simple_Desc_rsp );
   \   000027                ; Setup parameters for call to function ZDO_RegisterForZDOMsg
   \   000027   7A04         MOV       R2,#0x4
   \   000029   7B80         MOV       R3,#-0x80
   \   00002B   EE           MOV       A,R6
   \   00002C   F9           MOV       R1,A
   \   00002D   12....       LCALL     `??ZDO_RegisterForZDOMsg::?relay`; Banked call to: ZDO_RegisterForZDOMsg
    278          #endif
    279            
    280          #if !defined (DISABLE_GREENPOWER_BASIC_PROXY) && (ZG_BUILD_RTR_TYPE)
    281            gp_RegisterGPChangeChannelReqForBDBCB(gp_ChangeChannelReq);
   \   000030                ; Setup parameters for call to function gp_RegisterGPChangeChannelReqForBDBCB
   \   000030   7A..         MOV       R2,#`??gp_ChangeChannelReq::?relay` & 0xff
   \   000032   7B..         MOV       R3,#(`??gp_ChangeChannelReq::?relay` >> 8) & 0xff
   \   000034   12....       LCALL     `??gp_RegisterGPChangeChannelReqForBDBCB::?relay`; Banked call to: gp_RegisterGPChangeChannelReqForBDBCB
    282            gp_CBInit();
   \   000037   90....       MOV       DPTR,#GP_DataCnfGCB
   \   00003A   74..         MOV       A,#`??GP_DataCnf::?relay` & 0xff
   \   00003C   F0           MOVX      @DPTR,A
   \   00003D   A3           INC       DPTR
   \   00003E   74..         MOV       A,#(`??GP_DataCnf::?relay` >> 8) & 0xff
   \   000040   F0           MOVX      @DPTR,A
   \   000041   90....       MOV       DPTR,#GP_endpointInitGCB
   \   000044   74..         MOV       A,#`??gp_endpointInit::?relay` & 0xff
   \   000046   F0           MOVX      @DPTR,A
   \   000047   A3           INC       DPTR
   \   000048   74..         MOV       A,#(`??gp_endpointInit::?relay` >> 8) & 0xff
   \   00004A   F0           MOVX      @DPTR,A
   \   00004B   90....       MOV       DPTR,#GP_expireDuplicateFilteringGCB
   \   00004E   74..         MOV       A,#`??gp_expireDuplicateFiltering::?relay` & 0xff
   \   000050   F0           MOVX      @DPTR,A
   \   000051   A3           INC       DPTR
   \   000052   74..         MOV       A,#(`??gp_expireDuplicateFiltering::?relay` >> 8) & 0xff
   \   000054   F0           MOVX      @DPTR,A
   \   000055   90....       MOV       DPTR,#GP_stopCommissioningModeGCB
   \   000058   74..         MOV       A,#`??gp_stopCommissioningMode::?relay` & 0xff
   \   00005A   F0           MOVX      @DPTR,A
   \   00005B   A3           INC       DPTR
   \   00005C   74..         MOV       A,#(`??gp_stopCommissioningMode::?relay` >> 8) & 0xff
   \   00005E   F0           MOVX      @DPTR,A
   \   00005F   90....       MOV       DPTR,#GP_returnOperationalChannelGCB
   \   000062   74..         MOV       A,#`??gp_returnOperationalChannel::?relay` & 0xff
   \   000064   F0           MOVX      @DPTR,A
   \   000065   A3           INC       DPTR
   \   000066   74..         MOV       A,#(`??gp_returnOperationalChannel::?relay` >> 8) & 0xff
   \   000068   F0           MOVX      @DPTR,A
   \   000069   90....       MOV       DPTR,#GP_DataIndGCB
   \   00006C   74..         MOV       A,#`??GP_DataInd::?relay` & 0xff
   \   00006E   F0           MOVX      @DPTR,A
   \   00006F   A3           INC       DPTR
   \   000070   74..         MOV       A,#(`??GP_DataInd::?relay` >> 8) & 0xff
   \   000072   F0           MOVX      @DPTR,A
   \   000073   90....       MOV       DPTR,#GP_SecReqGCB
   \   000076   74..         MOV       A,#`??GP_SecReq::?relay` & 0xff
   \   000078   F0           MOVX      @DPTR,A
   \   000079   A3           INC       DPTR
   \   00007A   74..         MOV       A,#(`??GP_SecReq::?relay` >> 8) & 0xff
   \   00007C   F0           MOVX      @DPTR,A
   \   00007D   90....       MOV       DPTR,#GP_CheckAnnouncedDeviceGCB
   \   000080   74..         MOV       A,#`??gp_CheckAnnouncedDevice::?relay` & 0xff
   \   000082   F0           MOVX      @DPTR,A
   \   000083   A3           INC       DPTR
   \   000084   74..         MOV       A,#(`??gp_CheckAnnouncedDevice::?relay` >> 8) & 0xff
   \   000086   F0           MOVX      @DPTR,A
   \   000087   90....       MOV       DPTR,#GP_aliasConflictAnnce
   \   00008A   74..         MOV       A,#aliasConflictAnnce & 0xff
   \   00008C   F0           MOVX      @DPTR,A
   \   00008D   A3           INC       DPTR
   \   00008E   74..         MOV       A,#(aliasConflictAnnce >> 8) & 0xff
   \   000090   F0           MOVX      @DPTR,A
   \   000091                ; Setup parameters for call to function gp_endpointInit
   \   000091   12....       LCALL     `??gp_endpointInit::?relay`; Banked call to: gp_endpointInit
    283          #endif
    284          }
   \   000094   02....       LJMP      ?Subroutine0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7F01         MOV       R7,#0x1
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
    285          
    286          /*********************************************************************
    287           * @fn      bdb_RegisterSimpleDescriptor
    288           *
    289           * @brief   Register the Simple descriptor. This function also registers 
    290           *          the profile's cluster conversion table.
    291           *
    292           * @param   simpleDesc - a pointer to a valid SimpleDescriptionFormat_t, must not be NULL.
    293           *
    294           * @return  none
    295           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    296          void bdb_RegisterSimpleDescriptor( SimpleDescriptionFormat_t *simpleDesc )
   \                     bdb_RegisterSimpleDescriptor:
    297          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
    298            endPointDesc_t *epDesc;
    299          
    300            // Register the application's endpoint descriptor
    301            //  - This memory is allocated and never freed.
    302            epDesc = osal_mem_alloc( sizeof ( endPointDesc_t ) );
   \   000009                ; Setup parameters for call to function osal_mem_alloc
   \   000009   7A07         MOV       R2,#0x7
   \   00000B   7B00         MOV       R3,#0x0
   \   00000D   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
    303            if ( epDesc )
   \   000010   EA           MOV       A,R2
   \   000011   4B           ORL       A,R3
   \   000012   6023         JZ        ??bdb_RegisterSimpleDescriptor_0
    304            {
    305              // Fill out the endpoint description.
    306              epDesc->endPoint = simpleDesc->EndPoint;
   \   000014   8E82         MOV       DPL,R6
   \   000016   8F83         MOV       DPH,R7
   \   000018   E0           MOVX      A,@DPTR
   \   000019   8A82         MOV       DPL,R2
   \   00001B   8B83         MOV       DPH,R3
   \   00001D   F0           MOVX      @DPTR,A
    307              epDesc->task_id = &zcl_TaskID;   // all messages get sent to ZCL first
   \   00001E   A3           INC       DPTR
   \   00001F   A3           INC       DPTR
   \   000020   74..         MOV       A,#zcl_TaskID & 0xff
   \   000022   F0           MOVX      @DPTR,A
   \   000023   A3           INC       DPTR
   \   000024   74..         MOV       A,#(zcl_TaskID >> 8) & 0xff
   \   000026   12....       LCALL     ?Subroutine13 & 0xFFFF
    308              epDesc->simpleDesc = simpleDesc;
   \                     ??CrossCallReturnLabel_6:
   \   000029   EE           MOV       A,R6
   \   00002A   F0           MOVX      @DPTR,A
   \   00002B   A3           INC       DPTR
   \   00002C   EF           MOV       A,R7
   \   00002D   12....       LCALL     ?Subroutine13 & 0xFFFF
    309              epDesc->latencyReq = noLatencyReqs;
   \                     ??CrossCallReturnLabel_7:
   \   000030   A3           INC       DPTR
   \   000031   A3           INC       DPTR
   \   000032   E4           CLR       A
   \   000033   F0           MOVX      @DPTR,A
    310          
    311              // Register the endpoint description with the AF
    312              afRegister( epDesc );
   \   000034                ; Setup parameters for call to function afRegister
   \   000034   12....       LCALL     `??afRegister::?relay`; Banked call to: afRegister
    313            }
    314          }
   \                     ??bdb_RegisterSimpleDescriptor_0:
   \   000037   80..         SJMP      ??Subroutine37_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   8A82         MOV       DPL,R2
   \   000003   8B83         MOV       DPH,R3
   \   000005   A3           INC       DPTR
   \   000006   A3           INC       DPTR
   \   000007   A3           INC       DPTR
   \   000008   A3           INC       DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine37_0:
   \   000000   7F02         MOV       R7,#0x2
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
    315          
    316          #if (BDB_FINDING_BINDING_CAPABILITY_ENABLED==1)  
    317          /*********************************************************************
    318           * @fn      bdb_ZclIdentifyCmdInd
    319           *
    320           * @brief   Callback from the ZCL General Cluster Library when
    321           *          it received an Identity Command for this application.
    322           *
    323           * @param   identifyTime - the number of seconds to identify yourself
    324           * @param   endpoint - destination endpoint
    325           *
    326           * @return  none
    327           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    328          void bdb_ZclIdentifyCmdInd( uint16 identifyTime, uint8 endpoint )
   \                     bdb_ZclIdentifyCmdInd:
    329          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV       A,#-0x8
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
   \   00000E   E9           MOV       A,R1
   \   00000F   FE           MOV       R6,A
    330            zclAttrRec_t identifyAttrRec;
    331            
    332            if ( zclFindAttrRec( endpoint, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    333                                ATTRID_IDENTIFY_TIME, &identifyAttrRec ) )
   \   000010                ; Setup parameters for call to function zclFindAttrRec
   \   000010   A8..         MOV       R0,?XSP + 0
   \   000012   A9..         MOV       R1,?XSP + 1
   \   000014   88..         MOV       ?V2,R0
   \   000016   89..         MOV       ?V3,R1
   \   000018   78..         MOV       R0,#?V2
   \   00001A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001D   7C00         MOV       R4,#0x0
   \   00001F   7D00         MOV       R5,#0x0
   \   000021   7A03         MOV       R2,#0x3
   \   000023   7B00         MOV       R3,#0x0
   \   000025   EE           MOV       A,R6
   \   000026   F9           MOV       R1,A
   \   000027   12....       LCALL     `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   00002A   7402         MOV       A,#0x2
   \   00002C   12....       LCALL     ?DEALLOC_XSTACK8
   \   00002F   E9           MOV       A,R1
   \   000030   605C         JZ        ??bdb_ZclIdentifyCmdInd_0
    334            {
    335              //If we are processing an actual change
    336              if(*(uint16*)identifyAttrRec.attr.dataPtr != identifyTime)
   \   000032   7406         MOV       A,#0x6
   \   000034   12....       LCALL     ?XSTACK_DISP0_8
   \   000037   12....       LCALL     ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   00003A   E0           MOVX      A,@DPTR
   \   00003B   65..         XRL       A,?V0
   \   00003D   7004         JNZ       ??bdb_ZclIdentifyCmdInd_1
   \   00003F   A3           INC       DPTR
   \   000040   E0           MOVX      A,@DPTR
   \   000041   65..         XRL       A,?V1
   \                     ??bdb_ZclIdentifyCmdInd_1:
   \   000043   6049         JZ        ??bdb_ZclIdentifyCmdInd_0
    337              {
    338                if ( identifyTime > 0 )
   \   000045   E5..         MOV       A,?V0
   \   000047   45..         ORL       A,?V1
   \   000049   8882         MOV       DPL,R0
   \   00004B   8983         MOV       DPH,R1
   \   00004D   6020         JZ        ??bdb_ZclIdentifyCmdInd_2
    339                {
    340                  *((uint16*)identifyAttrRec.attr.dataPtr) = identifyTime;
   \   00004F   E5..         MOV       A,?V0
   \   000051   F0           MOVX      @DPTR,A
   \   000052   A3           INC       DPTR
   \   000053   E5..         MOV       A,?V1
   \   000055   F0           MOVX      @DPTR,A
    341                  osal_start_timerEx( bdb_TaskID, BDB_IDENTIFY_TIMEOUT, 1000 );
   \   000056                ; Setup parameters for call to function osal_start_timerEx
   \   000056   90....       MOV       DPTR,#__Constant_3e8
   \   000059   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   00005C   7A00         MOV       R2,#0x0
   \   00005E   7B20         MOV       R3,#0x20
   \   000060   90....       MOV       DPTR,#bdb_TaskID
   \   000063   E0           MOVX      A,@DPTR
   \   000064   F9           MOV       R1,A
   \   000065   12....       LCALL     `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   000068   7404         MOV       A,#0x4
   \   00006A   12....       LCALL     ?DEALLOC_XSTACK8
   \   00006D   800F         SJMP      ??bdb_ZclIdentifyCmdInd_3
    342                }
    343                else if ( identifyTime <= 0 )
    344                {
    345                  *((uint16*)identifyAttrRec.attr.dataPtr) = 0;
   \                     ??bdb_ZclIdentifyCmdInd_2:
   \   00006F   E4           CLR       A
   \   000070   F0           MOVX      @DPTR,A
   \   000071   A3           INC       DPTR
   \   000072   F0           MOVX      @DPTR,A
    346                  osal_stop_timerEx( bdb_TaskID, BDB_IDENTIFY_TIMEOUT );
   \   000073                ; Setup parameters for call to function osal_stop_timerEx
   \   000073   FA           MOV       R2,A
   \   000074   7B20         MOV       R3,#0x20
   \   000076   90....       MOV       DPTR,#bdb_TaskID
   \   000079   E0           MOVX      A,@DPTR
   \   00007A   F9           MOV       R1,A
   \   00007B   12....       LCALL     `??osal_stop_timerEx::?relay`; Banked call to: osal_stop_timerEx
    347                }
    348                
    349                if(pfnIdentifyTimeChangeCB != NULL)
   \                     ??bdb_ZclIdentifyCmdInd_3:
   \   00007E   90....       MOV       DPTR,#pfnIdentifyTimeChangeCB
   \   000081   12....       LCALL     ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_52:
   \   000084   6008         JZ        ??bdb_ZclIdentifyCmdInd_0
    350                {
    351                  pfnIdentifyTimeChangeCB(endpoint);
   \   000086                ; Setup parameters for indirect call
   \   000086   EE           MOV       A,R6
   \   000087   F9           MOV       R1,A
   \   000088   12....       LCALL     ??Subroutine48_0 & 0xFFFF
    352                }
    353              }
    354            }
   \                     ??CrossCallReturnLabel_78:
   \   00008B   12....       LCALL     ?CALL_IND
    355          }
   \                     ??bdb_ZclIdentifyCmdInd_0:
   \   00008E   7408         MOV       A,#0x8
   \   000090   02....       LJMP      ??Subroutine42_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F9           MOV       R1,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine42_0:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine43_0
   \   000003                ; // Fall through to label ??Subroutine43_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine43_0:
   \   000000   7F04         MOV       R7,#0x4
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   12....       LCALL     ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   000003   8882         MOV       DPL,R0
   \   000005   8983         MOV       DPH,R1
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine46_0:
   \   000000   12....       LCALL     ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_74:
   \   000003   E8           MOV       A,R0
   \   000004   49           ORL       A,R1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine48_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F583         MOV       DPH,A
   \   000003   8882         MOV       DPL,R0
   \   000005   22           RET
    356          #endif
    357          
    358          
    359          #if (ZG_BUILD_JOINING_TYPE) 
    360           /*********************************************************************
    361           * @fn          bdb_setActiveCentralizedLinkKey
    362           *
    363           * @brief       Set the active centralized key to be used, Global or IC derived.
    364           *
    365           * @param       useGlobal - If TRUE, then use default TC link key, if FALSE use 
    366           *                          pBuf as source for IC key derived input
    367           * @param       pBuf - The expected format and length of the IC is defined by 
    368           *                     BDB_INSTALL_CODE_USE
    369           *
    370           * @return      ZStatus_t - ZFailure when no valid BDB_INSTALL_CODE_USE is used
    371           *                          ZInvalidParameter when IC buffer is null
    372           */
    373          ZStatus_t bdb_setActiveCentralizedLinkKey(bool useGlobal, uint8* pBuf)
    374          {
    375            ZStatus_t Status = ZSuccess;
    376            uint8 extAddr[Z_EXTADDR_LEN];
    377            
    378            if(useGlobal)
    379            {
    380              //Set the default key to be used in centralized networks as defaultTCLinkKey
    381              APSME_SetDefaultKey();
    382            } 
    383            else
    384            {
    385              if(pBuf != NULL)
    386              {
    387            #if (BDB_INSTALL_CODE_USE==BDB_INSTALL_CODE_USE_IC_CRC)
    388                
    389                osal_memset(extAddr,0x00,Z_EXTADDR_LEN);
    390                
    391                //Set the install code as default key
    392                Status = bdb_addInstallCode(pBuf,extAddr);
    393              
    394            #elif (BDB_INSTALL_CODE_USE==BDB_INSTALL_CODE_USE_KEY)
    395          
    396                //Set the key as global default
    397                APSME_AddTCLinkKey(pBuf,extAddr);
    398            #else
    399              
    400                //BDB_INSTALL_CODE_USE not supported
    401                Status = ZFailure;
    402            #endif
    403              }
    404              else
    405              {
    406                Status = ZInvalidParameter;
    407              }
    408            }
    409            return Status;
    410          }
    411          #endif
    412          
    413          
    414              
    415            
    416          /******************************************************************************
    417           * @fn          bdb_addInstallCode
    418           *
    419           * @brief       Interface to add an install codes and adds a APS TC Link key.
    420           *
    421           * @param       pInstallCode - [in] Install Code with CRC (buffer size of 18 bytes).
    422           *              pExt - [in] Extended address of the node.
    423           *
    424           * @return      ZStatus_t
    425           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    426          ZStatus_t bdb_addInstallCode(uint8* pInstallCode, uint8* pExt)
   \                     bdb_addInstallCode:
    427          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 16
   \   000005   74F0         MOV       A,#-0x10
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   \   00000E   8C..         MOV       ?V2,R4
   \   000010   8D..         MOV       ?V3,R5
    428            uint8  hashOutput[16];
    429            uint16 CRC;
    430            
    431          #if (ZG_BUILD_COORDINATOR_TYPE)
    432            if(ZG_DEVICE_COORDINATOR_TYPE)
    433            {
    434              if(zgAllowInstallCodes == ZG_IC_NOT_SUPPORTED)
   \   000012   90....       MOV       DPTR,#zgAllowInstallCodes
   \   000015   E0           MOVX      A,@DPTR
   \   000016   7004         JNZ       ??bdb_addInstallCode_0
    435              {
    436                return ZFailure;
   \   000018   7901         MOV       R1,#0x1
   \   00001A   805D         SJMP      ??bdb_addInstallCode_1
    437              }
    438            }
    439          #endif
    440                 
    441            if((pInstallCode == NULL) || (pExt == NULL))
   \                     ??bdb_addInstallCode_0:
   \   00001C   EE           MOV       A,R6
   \   00001D   4F           ORL       A,R7
   \   00001E   6020         JZ        ??bdb_addInstallCode_2
   \   000020   EC           MOV       A,R4
   \   000021   45..         ORL       A,?V3
   \   000023   601B         JZ        ??bdb_addInstallCode_2
    442            {
    443              return ZInvalidParameter;
    444            }
    445            
    446            CRC = bdb_GenerateInstallCodeCRC(pInstallCode);
   \   000025                ; Setup parameters for call to function bdb_GenerateInstallCodeCRC
   \   000025   12....       LCALL     `??bdb_GenerateInstallCodeCRC::?relay`; Banked call to: bdb_GenerateInstallCodeCRC
   \   000028   8A..         MOV       ?V0,R2
   \   00002A   8B..         MOV       ?V1,R3
    447            //Validate CRC
    448            if(CRC != osal_build_uint16(&pInstallCode[INSTALL_CODE_LEN]))
   \   00002C                ; Setup parameters for call to function osal_build_uint16
   \   00002C   EE           MOV       A,R6
   \   00002D   2410         ADD       A,#0x10
   \   00002F   FA           MOV       R2,A
   \   000030   E4           CLR       A
   \   000031   3F           ADDC      A,R7
   \   000032   FB           MOV       R3,A
   \   000033   12....       LCALL     `??osal_build_uint16::?relay`; Banked call to: osal_build_uint16
   \   000036   EA           MOV       A,R2
   \   000037   65..         XRL       A,?V0
   \   000039   7003         JNZ       ??bdb_addInstallCode_3
   \   00003B   EB           MOV       A,R3
   \   00003C   65..         XRL       A,?V1
   \                     ??bdb_addInstallCode_3:
   \   00003E   6004         JZ        ??bdb_addInstallCode_4
    449            {
    450              return ZInvalidParameter;
   \                     ??bdb_addInstallCode_2:
   \   000040   7902         MOV       R1,#0x2
   \   000042   8035         SJMP      ??bdb_addInstallCode_1
    451            }
    452          
    453            sspMMOHash (NULL, 0, pInstallCode,(INSTALL_CODE_LEN + INSTALL_CODE_CRC_LEN) * BITS_PER_BYTE, hashOutput);
   \                     ??bdb_addInstallCode_4:
   \   000044                ; Setup parameters for call to function sspMMOHash
   \   000044   A8..         MOV       R0,?XSP + 0
   \   000046   A9..         MOV       R1,?XSP + 1
   \   000048   88..         MOV       ?V0,R0
   \   00004A   89..         MOV       ?V1,R1
   \   00004C   78..         MOV       R0,#?V0
   \   00004E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000051   75..90       MOV       ?V0,#-0x70
   \   000054   75..00       MOV       ?V1,#0x0
   \   000057   78..         MOV       R0,#?V0
   \   000059   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00005C   EE           MOV       A,R6
   \   00005D   FC           MOV       R4,A
   \   00005E   EF           MOV       A,R7
   \   00005F   FD           MOV       R5,A
   \   000060   7900         MOV       R1,#0x0
   \   000062   7A00         MOV       R2,#0x0
   \   000064   7B00         MOV       R3,#0x0
   \   000066   12....       LCALL     `??sspMMOHash::?relay`; Banked call to: sspMMOHash
   \   000069   7404         MOV       A,#0x4
   \   00006B   12....       LCALL     ?DEALLOC_XSTACK8
    454          
    455            return APSME_AddTCLinkKey(hashOutput,pExt);
   \   00006E                ; Setup parameters for call to function APSME_AddTCLinkKey
   \   00006E   AC..         MOV       R4,?V2
   \   000070   AD..         MOV       R5,?V3
   \   000072   AA..         MOV       R2,?XSP + 0
   \   000074   AB..         MOV       R3,?XSP + 1
   \   000076   12....       LCALL     `??APSME_AddTCLinkKey::?relay`; Banked call to: APSME_AddTCLinkKey
   \                     ??bdb_addInstallCode_1:
   \   000079   7410         MOV       A,#0x10
   \   00007B   12....       LCALL     ?DEALLOC_XSTACK8
   \   00007E                REQUIRE ?Subroutine3
   \   00007E                ; // Fall through to label ?Subroutine3
    456          }    

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7F06         MOV       R7,#0x6
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
    457              
    458          
    459          #if (ZG_BUILD_COORDINATOR_TYPE)
    460           /*********************************************************************
    461           * @fn      bdb_RegisterTCLinkKeyExchangeProcessCB
    462           *
    463           * @brief   Register a callback to receive notifications on the joining devices 
    464           *          and its status on TC link key exchange
    465           *
    466           * @param   bdbGCB_TCLinkKeyExchangeProcess - application callback 
    467           *          (extended address of device, status: 0 = Joining, 1 = TC link key exchange success, 2 = TC link key exchange failed)
    468           *
    469           * @return  none
    470           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    471          void bdb_RegisterTCLinkKeyExchangeProcessCB(bdbGCB_TCLinkKeyExchangeProcess_t bdbGCB_TCLinkKeyExchangeProcess)
   \                     bdb_RegisterTCLinkKeyExchangeProcessCB:
    472          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    473            if(bdbGCB_TCLinkKeyExchangeProcess != NULL)
   \   000004   EA           MOV       A,R2
   \   000005   4B           ORL       A,R3
   \   000006   6008         JZ        ??bdb_RegisterTCLinkKeyExchangeProcessCB_0
    474            {
    475              pfnTCLinkKeyExchangeProcessCB = bdbGCB_TCLinkKeyExchangeProcess;
   \   000008   90....       MOV       DPTR,#pfnTCLinkKeyExchangeProcessCB
   \   00000B   EA           MOV       A,R2
   \   00000C   F0           MOVX      @DPTR,A
   \   00000D   A3           INC       DPTR
   \   00000E   EB           MOV       A,R3
   \   00000F   F0           MOVX      @DPTR,A
    476            }
    477          }
   \                     ??bdb_RegisterTCLinkKeyExchangeProcessCB_0:
   \   000010   02....       LJMP      ??Subroutine40_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine40_0:
   \   000000   D083         POP       DPH
   \   000002   D082         POP       DPL
   \   000004   02....       LJMP      ?BRET
    478          
    479          
    480          
    481           /*********************************************************************
    482           * @fn          bdb_setTCRequireKeyExchange
    483           *
    484           * @brief       Set the bdb_setTCRequireKeyExchange attribute
    485           *
    486           * @param       isKeyExchangeRequired - True if TC will remove devices that do 
    487           *              not perform key exchange after bdbTrustCenterNodeJoinTimeout, 
    488           *              False to not remove devices.
    489           *
    490           * @return      none
    491           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    492          void bdb_setTCRequireKeyExchange(bool isKeyExchangeRequired)
   \                     bdb_setTCRequireKeyExchange:
    493          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    494            bdbAttributes.bdbTrustCenterRequireKeyExchange = isKeyExchangeRequired;
   \   000004   E9           MOV       A,R1
   \   000005   90....       MOV       DPTR,#bdbAttributes + 17
   \   000008   02....       LJMP      ??Subroutine39_0 & 0xFFFF
    495          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine39_0:
   \   000000   F0           MOVX      @DPTR,A
   \   000001                REQUIRE ??Subroutine40_0
   \   000001                ; // Fall through to label ??Subroutine40_0
    496          
    497          
    498          
    499           /*********************************************************************
    500           * @fn          bdb_TCAddJoiningDevice
    501           *
    502           * @brief       Add a joining device to the list of devices that must request a 
    503           *              key before bdbTrustCenterNodeJoinTimeout.
    504           *
    505           * @param       parentAddr - Address of the parent device
    506           * @param       JoiningExtAddr - IEEE address of the joining device
    507           *
    508           * @return      ZStatus_t - ZFailure No memory to allocate the device in the list
    509           *                          ZInvalidParameter
    510           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    511          ZStatus_t bdb_TCAddJoiningDevice(uint16 parentAddr, uint8* JoiningExtAddr)
   \                     bdb_TCAddJoiningDevice:
    512          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV       A,#-0xf
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 11
   \   000005   74F5         MOV       A,#-0xb
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   EA           MOV       A,R2
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   EB           MOV       A,R3
   \   000014   12....       LCALL     ?Subroutine15 & 0xFFFF
    513            bdb_joiningDeviceList_t* tempJoiningDescNode;
    514            
    515            if((parentAddr == INVALID_NODE_ADDR) || (JoiningExtAddr == NULL))
   \                     ??CrossCallReturnLabel_10:
   \   000017   64FE         XRL       A,#0xfe
   \   000019   7003         JNZ       ??bdb_TCAddJoiningDevice_0
   \   00001B   A3           INC       DPTR
   \   00001C   E0           MOVX      A,@DPTR
   \   00001D   F4           CPL       A
   \                     ??bdb_TCAddJoiningDevice_0:
   \   00001E   6004         JZ        ??bdb_TCAddJoiningDevice_1
   \   000020   EC           MOV       A,R4
   \   000021   4D           ORL       A,R5
   \   000022   7005         JNZ       ??bdb_TCAddJoiningDevice_2
    516            {
    517              return ZInvalidParameter;
   \                     ??bdb_TCAddJoiningDevice_1:
   \   000024   7902         MOV       R1,#0x2
   \   000026   02....       LJMP      ??bdb_TCAddJoiningDevice_3 & 0xFFFF
    518            }
    519            
    520            //If the list was empty and element was allocated, then start the timer
    521            if(bdb_joiningDeviceList == NULL)
   \                     ??bdb_TCAddJoiningDevice_2:
   \   000029   8C..         MOV       ?V0,R4
   \   00002B   8D..         MOV       ?V1,R5
   \   00002D   75..00       MOV       ?V2,#0x0
   \   000030   90....       MOV       DPTR,#bdb_joiningDeviceList
   \   000033   12....       LCALL     ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_53:
   \   000036   7033         JNZ       ??bdb_TCAddJoiningDevice_4
    522            {
    523              bdb_joiningDeviceList = osal_mem_alloc(sizeof(bdb_joiningDeviceList_t));
   \   000038                ; Setup parameters for call to function osal_mem_alloc
   \   000038   7A0D         MOV       R2,#0xd
   \   00003A   7B00         MOV       R3,#0x0
   \   00003C   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00003F   90....       MOV       DPTR,#bdb_joiningDeviceList
   \   000042   12....       LCALL     ?Subroutine11 & 0xFFFF
    524              if(bdb_joiningDeviceList == NULL)
   \                     ??CrossCallReturnLabel_4:
   \   000045   7003         JNZ       $+5
   \   000047   02....       LJMP      ??bdb_TCAddJoiningDevice_5 & 0xFFFF
    525              {
    526                return ZFailure;
    527              }
    528             
    529              osal_start_reload_timer(bdb_TaskID,BDB_TC_JOIN_TIMEOUT,1000);
   \   00004A                ; Setup parameters for call to function osal_start_reload_timer
   \   00004A   90....       MOV       DPTR,#__Constant_3e8
   \   00004D   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   000050   7A00         MOV       R2,#0x0
   \   000052   7B08         MOV       R3,#0x8
   \   000054   90....       MOV       DPTR,#bdb_TaskID
   \   000057   E0           MOVX      A,@DPTR
   \   000058   F9           MOV       R1,A
   \   000059   12....       LCALL     `??osal_start_reload_timer::?relay`; Banked call to: osal_start_reload_timer
   \   00005C   7404         MOV       A,#0x4
   \   00005E   12....       LCALL     ?DEALLOC_XSTACK8
    530              tempJoiningDescNode = bdb_joiningDeviceList;
   \   000061   90....       MOV       DPTR,#bdb_joiningDeviceList
   \   000064   E0           MOVX      A,@DPTR
   \   000065   FE           MOV       R6,A
   \   000066   A3           INC       DPTR
   \   000067   E0           MOVX      A,@DPTR
   \   000068   02....       LJMP      ??bdb_TCAddJoiningDevice_6 & 0xFFFF
    531            }
    532            //if the list was not empty then add the entry at the end of the list
    533            else
    534            {
    535              tempJoiningDescNode = bdb_joiningDeviceList;
   \                     ??bdb_TCAddJoiningDevice_4:
   \   00006B   12....       LCALL     ?Subroutine34 & 0xFFFF
    536              
    537              //Validate that this is not already in the list... somehow
    538              if(osal_memcmp(JoiningExtAddr,tempJoiningDescNode->bdbJoiningNodeEui64,Z_EXTADDR_LEN))
   \                     ??CrossCallReturnLabel_89:
   \   00006E                ; Setup parameters for call to function osal_memcmp
   \   00006E   8E82         MOV       DPL,R6
   \   000070   8F83         MOV       DPH,R7
   \   000072   A3           INC       DPTR
   \   000073   A3           INC       DPTR
   \   000074   A982         MOV       R1,DPL
   \   000076   AA83         MOV       R2,DPH
   \   000078   89..         MOV       ?V4,R1
   \   00007A   8A..         MOV       ?V5,R2
   \   00007C   75..00       MOV       ?V6,#0x0
   \   00007F   78..         MOV       R0,#?V4
   \   000081   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000084   7C08         MOV       R4,#0x8
   \   000086   7D00         MOV       R5,#0x0
   \   000088   A9..         MOV       R1,?V0
   \   00008A   AA..         MOV       R2,?V1
   \   00008C   AB..         MOV       R3,?V2
   \   00008E   12....       LCALL     `??osal_memcmp::?relay`; Banked call to: osal_memcmp
   \   000091   7403         MOV       A,#0x3
   \   000093   12....       LCALL     ?DEALLOC_XSTACK8
   \   000096   E9           MOV       A,R1
   \   000097   7038         JNZ       ??bdb_TCAddJoiningDevice_7
    539              {
    540                //The device added is already in the list, refresh its time and do nothing else
    541                tempJoiningDescNode->NodeJoinTimeout = bdbAttributes.bdbTrustCenterNodeJoinTimeout;
    542                return ZSuccess;
    543              }
    544              
    545              while(tempJoiningDescNode->nextDev != NULL)
   \                     ??bdb_TCAddJoiningDevice_8:
   \   000099   EE           MOV       A,R6
   \   00009A   240B         ADD       A,#0xb
   \   00009C   FE           MOV       R6,A
   \   00009D   5001         JNC       ??bdb_TCAddJoiningDevice_9
   \   00009F   0F           INC       R7
   \                     ??bdb_TCAddJoiningDevice_9:
   \   0000A0   12....       LCALL     ??Subroutine45_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_67:
   \   0000A3   6033         JZ        ??bdb_TCAddJoiningDevice_10
    546              {
    547                tempJoiningDescNode = tempJoiningDescNode->nextDev;
   \   0000A5   E8           MOV       A,R0
   \   0000A6   FE           MOV       R6,A
   \   0000A7   E9           MOV       A,R1
   \   0000A8   FF           MOV       R7,A
    548                
    549                //Validate that this is not already in the list... somehow
    550                if(osal_memcmp(JoiningExtAddr,tempJoiningDescNode->bdbJoiningNodeEui64,Z_EXTADDR_LEN))
   \   0000A9                ; Setup parameters for call to function osal_memcmp
   \   0000A9   8E82         MOV       DPL,R6
   \   0000AB   8F83         MOV       DPH,R7
   \   0000AD   A3           INC       DPTR
   \   0000AE   A3           INC       DPTR
   \   0000AF   A982         MOV       R1,DPL
   \   0000B1   AA83         MOV       R2,DPH
   \   0000B3   89..         MOV       ?V4,R1
   \   0000B5   8A..         MOV       ?V5,R2
   \   0000B7   78..         MOV       R0,#?V4
   \   0000B9   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   0000BC   7C08         MOV       R4,#0x8
   \   0000BE   7D00         MOV       R5,#0x0
   \   0000C0   A9..         MOV       R1,?V0
   \   0000C2   AA..         MOV       R2,?V1
   \   0000C4   AB..         MOV       R3,?V2
   \   0000C6   12....       LCALL     `??osal_memcmp::?relay`; Banked call to: osal_memcmp
   \   0000C9   7403         MOV       A,#0x3
   \   0000CB   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000CE   E9           MOV       A,R1
   \   0000CF   60C8         JZ        ??bdb_TCAddJoiningDevice_8
    551                {
    552                  //The device added is already in the list, refresh its time and do nothing else
    553                  tempJoiningDescNode->NodeJoinTimeout = bdbAttributes.bdbTrustCenterNodeJoinTimeout;
   \                     ??bdb_TCAddJoiningDevice_7:
   \   0000D1   12....       LCALL     ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_28:
   \   0000D4   F0           MOVX      @DPTR,A
    554                  return ZSuccess;
   \   0000D5   02....       LJMP      ??bdb_TCAddJoiningDevice_11 & 0xFFFF
    555                }
    556              }
    557              
    558              tempJoiningDescNode->nextDev = osal_mem_alloc(sizeof(bdb_joiningDeviceList_t));
   \                     ??bdb_TCAddJoiningDevice_10:
   \   0000D8                ; Setup parameters for call to function osal_mem_alloc
   \   0000D8   7A0D         MOV       R2,#0xd
   \   0000DA   7B00         MOV       R3,#0x0
   \   0000DC   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   0000DF   8A..         MOV       ?V4,R2
   \   0000E1   8B..         MOV       ?V5,R3
   \   0000E3   A8..         MOV       R0,?V4
   \   0000E5   A9..         MOV       R1,?V5
   \   0000E7   12....       LCALL     ??Subroutine49_0 & 0xFFFF
    559              if(tempJoiningDescNode->nextDev == NULL)
   \                     ??CrossCallReturnLabel_86:
   \   0000EA   7005         JNZ       ??bdb_TCAddJoiningDevice_12
    560              {
    561                return ZFailure;
   \                     ??bdb_TCAddJoiningDevice_5:
   \   0000EC   7901         MOV       R1,#0x1
   \   0000EE   02....       LJMP      ??bdb_TCAddJoiningDevice_3 & 0xFFFF
    562              }
    563              
    564              tempJoiningDescNode = tempJoiningDescNode->nextDev;
   \                     ??bdb_TCAddJoiningDevice_12:
   \   0000F1   E8           MOV       A,R0
   \   0000F2   FE           MOV       R6,A
   \   0000F3   E9           MOV       A,R1
   \                     ??bdb_TCAddJoiningDevice_6:
   \   0000F4   FF           MOV       R7,A
   \   0000F5   90....       MOV       DPTR,#pfnTCLinkKeyExchangeProcessCB
    565            }
   \   0000F8   12....       LCALL     ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_54:
   \   0000FB   6053         JZ        ??bdb_TCAddJoiningDevice_13
    566            
    567            if(pfnTCLinkKeyExchangeProcessCB)
    568            {
    569              bdb_TCLinkKeyExchProcess_t bdb_TCLinkKeyExchProcess;
    570              osal_memcpy(bdb_TCLinkKeyExchProcess.extAddr,tempJoiningDescNode->bdbJoiningNodeEui64, Z_EXTADDR_LEN);
   \   0000FD                ; Setup parameters for call to function osal_memcpy
   \   0000FD   8E82         MOV       DPL,R6
   \   0000FF   8F83         MOV       DPH,R7
   \   000101   A3           INC       DPTR
   \   000102   A3           INC       DPTR
   \   000103   A982         MOV       R1,DPL
   \   000105   AA83         MOV       R2,DPH
   \   000107   89..         MOV       ?V4,R1
   \   000109   8A..         MOV       ?V5,R2
   \   00010B   75..00       MOV       ?V6,#0x0
   \   00010E   78..         MOV       R0,#?V4
   \   000110   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000113   7C08         MOV       R4,#0x8
   \   000115   7D00         MOV       R5,#0x0
   \   000117   7406         MOV       A,#0x6
   \   000119   12....       LCALL     ?XSTACK_DISP0_8
   \   00011C   AA82         MOV       R2,DPL
   \   00011E   AB83         MOV       R3,DPH
   \   000120   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000123   7403         MOV       A,#0x3
   \   000125   12....       LCALL     ?DEALLOC_XSTACK8
    571              bdb_TCLinkKeyExchProcess.status = BDB_TC_LK_EXCH_PROCESS_JOINING;
   \   000128   7402         MOV       A,#0x2
   \   00012A   12....       LCALL     ?XSTACK_DISP0_8
   \   00012D   E4           CLR       A
   \   00012E   F0           MOVX      @DPTR,A
    572              
    573              bdb_SendMsg(bdb_TaskID, BDB_TC_LINK_KEY_EXCHANGE_PROCESS, BDB_MSG_EVENT_SUCCESS,sizeof(bdb_TCLinkKeyExchProcess_t),(uint8*)&bdb_TCLinkKeyExchProcess);
   \   00012F                ; Setup parameters for call to function bdb_SendMsg
   \   00012F   7402         MOV       A,#0x2
   \   000131   12....       LCALL     ?XSTACK_DISP100_8
   \   000134   88..         MOV       ?V4,R0
   \   000136   89..         MOV       ?V5,R1
   \   000138   78..         MOV       R0,#?V4
   \   00013A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00013D   7C09         MOV       R4,#0x9
   \   00013F   7B00         MOV       R3,#0x0
   \   000141   7A09         MOV       R2,#0x9
   \   000143   90....       MOV       DPTR,#bdb_TaskID
   \   000146   E0           MOVX      A,@DPTR
   \   000147   F9           MOV       R1,A
   \   000148   12....       LCALL     `??bdb_SendMsg::?relay`; Banked call to: bdb_SendMsg
   \   00014B   7402         MOV       A,#0x2
   \   00014D   12....       LCALL     ?DEALLOC_XSTACK8
    574            }
    575            
    576            tempJoiningDescNode->nextDev = NULL;
   \                     ??bdb_TCAddJoiningDevice_13:
   \   000150   12....       LCALL     ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   000153   E4           CLR       A
   \   000154   F0           MOVX      @DPTR,A
   \   000155   A3           INC       DPTR
   \   000156   F0           MOVX      @DPTR,A
    577            tempJoiningDescNode->NodeJoinTimeout = bdbAttributes.bdbTrustCenterNodeJoinTimeout;
   \   000157   12....       LCALL     ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   00015A   12....       LCALL     ?Subroutine15 & 0xFFFF
    578            tempJoiningDescNode->parentAddr = parentAddr;
   \                     ??CrossCallReturnLabel_11:
   \   00015D   F8           MOV       R0,A
   \   00015E   A3           INC       DPTR
   \   00015F   E0           MOVX      A,@DPTR
   \   000160   F9           MOV       R1,A
   \   000161   12....       LCALL     ?Subroutine31 & 0xFFFF
    579            osal_memcpy(tempJoiningDescNode->bdbJoiningNodeEui64, JoiningExtAddr, Z_EXTADDR_LEN);
   \                     ??CrossCallReturnLabel_102:
   \   000164                ; Setup parameters for call to function osal_memcpy
   \   000164   78..         MOV       R0,#?V0
   \   000166   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000169   7C08         MOV       R4,#0x8
   \   00016B   7D00         MOV       R5,#0x0
   \   00016D   EE           MOV       A,R6
   \   00016E   2402         ADD       A,#0x2
   \   000170   FA           MOV       R2,A
   \   000171   E4           CLR       A
   \   000172   3F           ADDC      A,R7
   \   000173   FB           MOV       R3,A
   \   000174   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000177   7403         MOV       A,#0x3
   \   000179   12....       LCALL     ?DEALLOC_XSTACK8
    580            
    581            return ZSuccess;
   \                     ??bdb_TCAddJoiningDevice_11:
   \   00017C   7900         MOV       R1,#0x0
   \                     ??bdb_TCAddJoiningDevice_3:
   \   00017E                REQUIRE ?Subroutine5
   \   00017E                ; // Fall through to label ?Subroutine5
    582          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   740B         MOV       A,#0xb
   \   000002   12....       LCALL     ?DEALLOC_XSTACK8
   \   000005   7F07         MOV       R7,#0x7
   \   000007   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   90....       MOV       DPTR,#bdbAttributes + 16
   \   000003   E0           MOVX      A,@DPTR
   \   000004   8E82         MOV       DPL,R6
   \   000006   8F83         MOV       DPH,R7
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   A3           INC       DPTR
   \   00000B   A3           INC       DPTR
   \   00000C   A3           INC       DPTR
   \   00000D   A3           INC       DPTR
   \   00000E   A3           INC       DPTR
   \   00000F   A3           INC       DPTR
   \   000010   A3           INC       DPTR
   \   000011   A3           INC       DPTR
   \   000012   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   85..82       MOV       DPL,?XSP + 0
   \   000004   85..83       MOV       DPH,?XSP + 1
   \   000007   E0           MOVX      A,@DPTR
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   EE           MOV       A,R6
   \   000001   240B         ADD       A,#0xb
   \   000003   F582         MOV       DPL,A
   \   000005   E4           CLR       A
   \   000006   3F           ADDC      A,R7
   \   000007   F583         MOV       DPH,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   EA           MOV       A,R2
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   EB           MOV       A,R3
   \   000004   F0           MOVX      @DPTR,A
   \   000005   90....       MOV       DPTR,#bdb_joiningDeviceList
   \   000008   12....       LCALL     ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   00000B   E8           MOV       A,R0
   \   00000C   49           ORL       A,R1
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine45_0:
   \   000000   8E82         MOV       DPL,R6
   \   000002   8F83         MOV       DPH,R7
   \   000004                REQUIRE ??Subroutine46_0
   \   000004                ; // Fall through to label ??Subroutine46_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine49_0:
   \   000000   12....       LCALL     ?Subroutine31 & 0xFFFF
   \                     ??CrossCallReturnLabel_104:
   \   000003   E8           MOV       A,R0
   \   000004   49           ORL       A,R1
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   90....       MOV       DPTR,#bdb_joiningDeviceList
   \   000003                REQUIRE ??Subroutine50_0
   \   000003                ; // Fall through to label ??Subroutine50_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine50_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FE           MOV       R6,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FF           MOV       R7,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   8E82         MOV       DPL,R6
   \   000002   8F83         MOV       DPH,R7
   \   000004                REQUIRE ??Subroutine52_0
   \   000004                ; // Fall through to label ??Subroutine52_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine52_0:
   \   000000   E8           MOV       A,R0
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   E9           MOV       A,R1
   \   000004   F0           MOVX      @DPTR,A
   \   000005   22           RET
    583          
    584          /****************************************************************************
    585           * @fn          bdb_TCProcessJoiningList
    586           *
    587           * @brief       Process the timer to handle the joining devices if the TC link 
    588           *              key is mandatory for all devices
    589           *
    590           * @param       none
    591           *
    592           * @return      none
    593           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    594          void bdb_TCProcessJoiningList(void)
   \                     bdb_TCProcessJoiningList:
    595          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 42
   \   000005   74D6         MOV       A,#-0x2a
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
    596            bdb_joiningDeviceList_t* tempJoiningDescNode;
    597            
    598            if(bdb_joiningDeviceList)
   \   00000A   90....       MOV       DPTR,#bdb_joiningDeviceList
   \   00000D   12....       LCALL     ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_55:
   \   000010   7003         JNZ       $+5
   \   000012   02....       LJMP      ??bdb_TCProcessJoiningList_0 & 0xFFFF
    599            {
    600              tempJoiningDescNode = bdb_joiningDeviceList;
   \   000015   90....       MOV       DPTR,#bdb_joiningDeviceList
   \   000018   E0           MOVX      A,@DPTR
   \   000019   F5..         MOV       ?V6,A
   \   00001B   A3           INC       DPTR
   \   00001C   E0           MOVX      A,@DPTR
   \   00001D   F5..         MOV       ?V7,A
    601            
    602              while(tempJoiningDescNode)
    603              {
    604                if(tempJoiningDescNode->NodeJoinTimeout)
   \                     ??bdb_TCProcessJoiningList_1:
   \   00001F   E5..         MOV       A,?V6
   \   000021   240A         ADD       A,#0xa
   \   000023   F582         MOV       DPL,A
   \   000025   E4           CLR       A
   \   000026   35..         ADDC      A,?V7
   \   000028   F583         MOV       DPH,A
   \   00002A   E0           MOVX      A,@DPTR
   \   00002B   6007         JZ        ??bdb_TCProcessJoiningList_2
    605                {
    606                  tempJoiningDescNode->NodeJoinTimeout--;
   \   00002D   14           DEC       A
   \   00002E   F0           MOVX      @DPTR,A
    607                }
    608                
    609                if(tempJoiningDescNode->NodeJoinTimeout == 0)
   \   00002F   6003         JZ        $+5
   \   000031   02....       LJMP      ??bdb_TCProcessJoiningList_3 & 0xFFFF
    610                {
    611                  //Check if the key exchange is required 
    612                  if(bdb_doTrustCenterRequireKeyExchange())
   \                     ??bdb_TCProcessJoiningList_2:
   \   000034   E5..         MOV       A,?V6
   \   000036   2402         ADD       A,#0x2
   \   000038   FE           MOV       R6,A
   \   000039   E4           CLR       A
   \   00003A   35..         ADDC      A,?V7
   \   00003C   FF           MOV       R7,A
   \   00003D   8E..         MOV       ?V0,R6
   \   00003F   8F..         MOV       ?V1,R7
   \   000041   75..00       MOV       ?V2,#0x0
   \   000044   90....       MOV       DPTR,#bdbAttributes + 17
   \   000047   E0           MOVX      A,@DPTR
   \   000048   604E         JZ        ??bdb_TCProcessJoiningList_4
    613                  {
    614                      AddrMgrEntry_t entry;
    615                      
    616                      entry.user = ADDRMGR_USER_DEFAULT;
   \   00004A   740A         MOV       A,#0xa
   \   00004C   12....       LCALL     ?XSTACK_DISP0_8
   \   00004F   E4           CLR       A
   \   000050   F0           MOVX      @DPTR,A
    617                      osal_memcpy(entry.extAddr,tempJoiningDescNode->bdbJoiningNodeEui64, Z_EXTADDR_LEN);
   \   000051                ; Setup parameters for call to function osal_memcpy
   \   000051   78..         MOV       R0,#?V0
   \   000053   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000056   7C08         MOV       R4,#0x8
   \   000058   7D00         MOV       R5,#0x0
   \   00005A   7410         MOV       A,#0x10
   \   00005C   12....       LCALL     ?XSTACK_DISP0_8
   \   00005F   AA82         MOV       R2,DPL
   \   000061   AB83         MOV       R3,DPH
   \   000063   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000066   7403         MOV       A,#0x3
   \   000068   12....       LCALL     ?DEALLOC_XSTACK8
    618                      
    619                      if(AddrMgrEntryLookupExt(&entry))
   \   00006B                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   00006B   740A         MOV       A,#0xa
   \   00006D   12....       LCALL     ?XSTACK_DISP101_8
   \   000070   12....       LCALL     `??AddrMgrEntryLookupExt::?relay`; Banked call to: AddrMgrEntryLookupExt
   \   000073   E9           MOV       A,R1
   \   000074   6022         JZ        ??bdb_TCProcessJoiningList_4
    620                      {
    621                        ZDSecMgrAPSRemove(entry.nwkAddr,entry.extAddr,tempJoiningDescNode->parentAddr);
   \   000076                ; Setup parameters for call to function ZDSecMgrAPSRemove
   \   000076   85..82       MOV       DPL,?V6
   \   000079   85..83       MOV       DPH,?V7
   \   00007C   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   00007F   740F         MOV       A,#0xf
   \   000081   12....       LCALL     ?XSTACK_DISP0_8
   \   000084   AC82         MOV       R4,DPL
   \   000086   AD83         MOV       R5,DPH
   \   000088   740D         MOV       A,#0xd
   \   00008A   12....       LCALL     ?XSTACK_DISP0_8
   \   00008D   12....       LCALL     ??Subroutine51_0 & 0xFFFF
    622                      }
    623                  }
   \                     ??CrossCallReturnLabel_91:
   \   000090   12....       LCALL     `??ZDSecMgrAPSRemove::?relay`; Banked call to: ZDSecMgrAPSRemove
   \   000093   7402         MOV       A,#0x2
   \   000095   12....       LCALL     ?DEALLOC_XSTACK8
    624                  
    625                  //Expired device either is legacy device not using the TCLK entry or got 
    626                  //removed from the network because of timeout, eitherway it is not using
    627                  //TCLK entry neither the Security user in the address manager, so free the entry
    628                  //in both tables.
    629                  
    630                  uint16 keyNvIndex;
    631                  uint16 index;        
    632                  APSME_TCLKDevEntry_t TCLKDevEntry;
    633                  uint8 found;
    634                  
    635                  //Remove the entry in address manager
    636                  ZDSecMgrAddrClear(tempJoiningDescNode->bdbJoiningNodeEui64);
   \                     ??bdb_TCProcessJoiningList_4:
   \   000098                ; Setup parameters for call to function ZDSecMgrAddrClear
   \   000098   EE           MOV       A,R6
   \   000099   FA           MOV       R2,A
   \   00009A   EF           MOV       A,R7
   \   00009B   FB           MOV       R3,A
   \   00009C   12....       LCALL     `??ZDSecMgrAddrClear::?relay`; Banked call to: ZDSecMgrAddrClear
    637                  
    638                  //search for the entry in the TCLK table
    639                  keyNvIndex = APSME_SearchTCLinkKeyEntry(tempJoiningDescNode->bdbJoiningNodeEui64,&found, NULL);
   \   00009F                ; Setup parameters for call to function APSME_SearchTCLinkKeyEntry
   \   00009F   E4           CLR       A
   \   0000A0   F5..         MOV       ?V4,A
   \   0000A2   F5..         MOV       ?V5,A
   \   0000A4   78..         MOV       R0,#?V4
   \   0000A6   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000A9   7402         MOV       A,#0x2
   \   0000AB   12....       LCALL     ?XSTACK_DISP102_8
   \   0000AE   EE           MOV       A,R6
   \   0000AF   FA           MOV       R2,A
   \   0000B0   EF           MOV       A,R7
   \   0000B1   FB           MOV       R3,A
   \   0000B2   12....       LCALL     `??APSME_SearchTCLinkKeyEntry::?relay`; Banked call to: APSME_SearchTCLinkKeyEntry
   \   0000B5   7402         MOV       A,#0x2
   \   0000B7   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000BA   8A..         MOV       ?V4,R2
   \   0000BC   8B..         MOV       ?V5,R3
   \   0000BE   AE..         MOV       R6,?V4
   \   0000C0   AF..         MOV       R7,?V5
    640                  
    641                  //If found, erase it.
    642                  if(found == TRUE)
   \   0000C2   85..82       MOV       DPL,?XSP + 0
   \   0000C5   85..83       MOV       DPH,?XSP + 1
   \   0000C8   E0           MOVX      A,@DPTR
   \   0000C9   6401         XRL       A,#0x1
   \   0000CB   7070         JNZ       ??bdb_TCProcessJoiningList_5
    643                  {
    644                    osal_memset(&TCLKDevEntry,0,sizeof(APSME_TCLKDevEntry_t));
   \   0000CD                ; Setup parameters for call to function osal_memset
   \   0000CD   7C13         MOV       R4,#0x13
   \   0000CF   7D00         MOV       R5,#0x0
   \   0000D1   7900         MOV       R1,#0x0
   \   0000D3   7417         MOV       A,#0x17
   \   0000D5   12....       LCALL     ?XSTACK_DISP101_8
   \   0000D8   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    645                    TCLKDevEntry.keyAttributes = ZG_DEFAULT_KEY;
   \   0000DB   7427         MOV       A,#0x27
   \   0000DD   12....       LCALL     ?XSTACK_DISP0_8
   \   0000E0   74FF         MOV       A,#-0x1
   \   0000E2   F0           MOVX      @DPTR,A
    646                    
    647                    //Increase the shift by one. Validate the maximum shift of the seed which is 15
    648                    index = keyNvIndex - ZCD_NV_TCLK_TABLE_START;
   \   0000E3   EE           MOV       A,R6
   \   0000E4   24EF         ADD       A,#-0x11
   \   0000E6   F8           MOV       R0,A
   \   0000E7   EF           MOV       A,R7
   \   0000E8   34FE         ADDC      A,#-0x2
   \   0000EA   F9           MOV       R1,A
    649                    
    650                    TCLinkKeyFrmCntr[index].rxFrmCntr = 0;
   \   0000EB   E8           MOV       A,R0
   \   0000EC   75F009       MOV       B,#0x9
   \   0000EF   A4           MUL       AB
   \   0000F0   F8           MOV       R0,A
   \   0000F1   AAF0         MOV       R2,B
   \   0000F3   75F009       MOV       B,#0x9
   \   0000F6   E9           MOV       A,R1
   \   0000F7   A4           MUL       AB
   \   0000F8   2A           ADD       A,R2
   \   0000F9   F9           MOV       R1,A
   \   0000FA   74..         MOV       A,#TCLinkKeyFrmCntr & 0xff
   \   0000FC   28           ADD       A,R0
   \   0000FD   F8           MOV       R0,A
   \   0000FE   74..         MOV       A,#(TCLinkKeyFrmCntr >> 8) & 0xff
   \   000100   39           ADDC      A,R1
   \   000101   F9           MOV       R1,A
   \   000102   8882         MOV       DPL,R0
   \   000104   8983         MOV       DPH,R1
   \   000106   A3           INC       DPTR
   \   000107   A3           INC       DPTR
   \   000108   A3           INC       DPTR
   \   000109   A3           INC       DPTR
   \   00010A   12....       LCALL     ?Subroutine10 & 0xFFFF
    651                    TCLinkKeyFrmCntr[index].txFrmCntr = 0;
   \                     ??CrossCallReturnLabel_47:
   \   00010D   8882         MOV       DPL,R0
   \   00010F   8983         MOV       DPH,R1
   \   000111   12....       LCALL     ??Subroutine38_0 & 0xFFFF
    652                    
    653                    //Update the entry
    654                    osal_nv_write(keyNvIndex,0,sizeof(APSME_TCLKDevEntry_t), &TCLKDevEntry );
   \                     ??CrossCallReturnLabel_45:
   \   000114                ; Setup parameters for call to function osal_nv_write
   \   000114   7417         MOV       A,#0x17
   \   000116   12....       LCALL     ?XSTACK_DISP100_8
   \   000119   88..         MOV       ?V4,R0
   \   00011B   89..         MOV       ?V5,R1
   \   00011D   78..         MOV       R0,#?V4
   \   00011F   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000122   75..13       MOV       ?V4,#0x13
   \   000125   75..00       MOV       ?V5,#0x0
   \   000128   78..         MOV       R0,#?V4
   \   00012A   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00012D   7C00         MOV       R4,#0x0
   \   00012F   7D00         MOV       R5,#0x0
   \   000131   EE           MOV       A,R6
   \   000132   FA           MOV       R2,A
   \   000133   EF           MOV       A,R7
   \   000134   FB           MOV       R3,A
   \   000135   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000138   7404         MOV       A,#0x4
   \   00013A   12....       LCALL     ?DEALLOC_XSTACK8
    655                  }
    656                  
    657                  if(pfnTCLinkKeyExchangeProcessCB)
   \                     ??bdb_TCProcessJoiningList_5:
   \   00013D   90....       MOV       DPTR,#pfnTCLinkKeyExchangeProcessCB
   \   000140   12....       LCALL     ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_56:
   \   000143   6042         JZ        ??bdb_TCProcessJoiningList_6
    658                  {
    659                    bdb_TCLinkKeyExchProcess_t bdb_TCLinkKeyExchProcess;
    660                    osal_memcpy(bdb_TCLinkKeyExchProcess.extAddr,tempJoiningDescNode->bdbJoiningNodeEui64, Z_EXTADDR_LEN);
   \   000145                ; Setup parameters for call to function osal_memcpy
   \   000145   78..         MOV       R0,#?V0
   \   000147   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00014A   7C08         MOV       R4,#0x8
   \   00014C   7D00         MOV       R5,#0x0
   \   00014E   7405         MOV       A,#0x5
   \   000150   12....       LCALL     ?XSTACK_DISP0_8
   \   000153   AA82         MOV       R2,DPL
   \   000155   AB83         MOV       R3,DPH
   \   000157   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   00015A   7403         MOV       A,#0x3
   \   00015C   12....       LCALL     ?DEALLOC_XSTACK8
    661                    bdb_TCLinkKeyExchProcess.status = BDB_TC_LK_EXCH_PROCESS_EXCH_FAIL;
   \   00015F   7401         MOV       A,#0x1
   \   000161   12....       LCALL     ?XSTACK_DISP0_8
   \   000164   7402         MOV       A,#0x2
   \   000166   F0           MOVX      @DPTR,A
    662                    
    663                    bdb_SendMsg(bdb_TaskID, BDB_TC_LINK_KEY_EXCHANGE_PROCESS, BDB_MSG_EVENT_SUCCESS,sizeof(bdb_TCLinkKeyExchProcess_t),(uint8*)&bdb_TCLinkKeyExchProcess);
   \   000167                ; Setup parameters for call to function bdb_SendMsg
   \   000167   14           DEC       A
   \   000168   12....       LCALL     ?XSTACK_DISP100_8
   \   00016B   88..         MOV       ?V0,R0
   \   00016D   89..         MOV       ?V1,R1
   \   00016F   78..         MOV       R0,#?V0
   \   000171   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000174   7C09         MOV       R4,#0x9
   \   000176   7B00         MOV       R3,#0x0
   \   000178   7A09         MOV       R2,#0x9
   \   00017A   90....       MOV       DPTR,#bdb_TaskID
   \   00017D   E0           MOVX      A,@DPTR
   \   00017E   F9           MOV       R1,A
   \   00017F   12....       LCALL     `??bdb_SendMsg::?relay`; Banked call to: bdb_SendMsg
   \   000182   7402         MOV       A,#0x2
   \   000184   12....       LCALL     ?DEALLOC_XSTACK8
    664                  }
    665                 
    666                  //Free the device from the list
    667                  bdb_TCJoiningDeviceFree(tempJoiningDescNode);
   \                     ??bdb_TCProcessJoiningList_6:
   \   000187                ; Setup parameters for call to function bdb_TCJoiningDeviceFree
   \   000187   AA..         MOV       R2,?V6
   \   000189   AB..         MOV       R3,?V7
   \   00018B   12....       LCALL     `??bdb_TCJoiningDeviceFree::?relay`; Banked call to: bdb_TCJoiningDeviceFree
    668                }
    669                tempJoiningDescNode = tempJoiningDescNode->nextDev;
   \                     ??bdb_TCProcessJoiningList_3:
   \   00018E   E5..         MOV       A,?V6
   \   000190   240B         ADD       A,#0xb
   \   000192   F582         MOV       DPL,A
   \   000194   E4           CLR       A
   \   000195   35..         ADDC      A,?V7
   \   000197   F583         MOV       DPH,A
   \   000199   E0           MOVX      A,@DPTR
   \   00019A   F5..         MOV       ?V6,A
   \   00019C   A3           INC       DPTR
   \   00019D   E0           MOVX      A,@DPTR
   \   00019E   F5..         MOV       ?V7,A
    670              }
   \   0001A0   E5..         MOV       A,?V6
   \   0001A2   45..         ORL       A,?V7
   \   0001A4   6003         JZ        $+5
   \   0001A6   02....       LJMP      ??bdb_TCProcessJoiningList_1 & 0xFFFF
    671            }
    672          
    673            //we are done with the list
    674            if(bdb_joiningDeviceList == NULL)
   \   0001A9   90....       MOV       DPTR,#bdb_joiningDeviceList
   \   0001AC   12....       LCALL     ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   0001AF   700C         JNZ       ??bdb_TCProcessJoiningList_7
    675            {
    676              osal_stop_timerEx(bdb_TaskID,BDB_TC_JOIN_TIMEOUT);
   \                     ??bdb_TCProcessJoiningList_0:
   \   0001B1                ; Setup parameters for call to function osal_stop_timerEx
   \   0001B1   7A00         MOV       R2,#0x0
   \   0001B3   7B08         MOV       R3,#0x8
   \   0001B5   90....       MOV       DPTR,#bdb_TaskID
   \   0001B8   E0           MOVX      A,@DPTR
   \   0001B9   F9           MOV       R1,A
   \   0001BA   12....       LCALL     `??osal_stop_timerEx::?relay`; Banked call to: osal_stop_timerEx
    677            }
    678          }
   \                     ??bdb_TCProcessJoiningList_7:
   \   0001BD   742A         MOV       A,#0x2a
   \   0001BF   02....       LJMP      ?Subroutine6 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   E4           CLR       A
   \   000001                REQUIRE ??Subroutine38_0
   \   000001                ; // Fall through to label ??Subroutine38_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine38_0:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   A3           INC       DPTR
   \   000002   F0           MOVX      @DPTR,A
   \   000003   A3           INC       DPTR
   \   000004   F0           MOVX      @DPTR,A
   \   000005   A3           INC       DPTR
   \   000006   F0           MOVX      @DPTR,A
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine51_0:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FB           MOV       R3,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003   7F08         MOV       R7,#0x8
   \   000005   02....       LJMP      ?BANKED_LEAVE_XDATA
    679          
    680          
    681          
    682          /****************************************************************************
    683           * @fn          bdb_TCjoiningDeviceComplete
    684           *
    685           * @brief       This function frees a joining device from the list that has 
    686           *              finished TC link key exchange process
    687           *
    688           * @param       JoiningExtAddr - Extended address of the device
    689           *
    690           * @return      none
    691           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    692          void bdb_TCjoiningDeviceComplete(uint8* JoiningExtAddr)
   \                     bdb_TCjoiningDeviceComplete:
    693          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV       A,#-0xf
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 11
   \   000005   74F5         MOV       A,#-0xb
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   12....       LCALL     ?Subroutine11 & 0xFFFF
    694            bdb_joiningDeviceList_t* tempJoiningDescNode;
    695            
    696            if((bdb_joiningDeviceList != NULL) && (JoiningExtAddr != NULL))
   \                     ??CrossCallReturnLabel_5:
   \   000013   7003         JNZ       $+5
   \   000015   02....       LJMP      ??bdb_TCjoiningDeviceComplete_0 & 0xFFFF
   \   000018   85..82       MOV       DPL,?XSP + 0
   \   00001B   85..83       MOV       DPH,?XSP + 1
   \   00001E   12....       LCALL     ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   000021   7003         JNZ       $+5
   \   000023   02....       LJMP      ??bdb_TCjoiningDeviceComplete_0 & 0xFFFF
    697            {
    698              tempJoiningDescNode = bdb_joiningDeviceList;
   \   000026   12....       LCALL     ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_90:
   \   000029   8E82         MOV       DPL,R6
   \   00002B   8F83         MOV       DPH,R7
   \   00002D   A3           INC       DPTR
   \   00002E   A3           INC       DPTR
   \   00002F   A982         MOV       R1,DPL
   \   000031   AA83         MOV       R2,DPH
   \   000033   89..         MOV       ?V0,R1
   \   000035   8A..         MOV       ?V1,R2
   \   000037   75..00       MOV       ?V2,#0x0
   \   00003A                ; Setup parameters for call to function osal_memcmp
   \   00003A   85..82       MOV       DPL,?XSP + 0
   \   00003D   85..83       MOV       DPH,?XSP + 1
   \   000040   E0           MOVX      A,@DPTR
   \   000041   F5..         MOV       ?V4,A
   \   000043   A3           INC       DPTR
   \   000044   E0           MOVX      A,@DPTR
   \   000045   F5..         MOV       ?V5,A
   \   000047   75..00       MOV       ?V6,#0x0
   \   00004A   78..         MOV       R0,#?V4
   \   00004C   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00004F   7C08         MOV       R4,#0x8
   \   000051   7D00         MOV       R5,#0x0
   \   000053   AB..         MOV       R3,?V2
    699              
    700              while(tempJoiningDescNode != NULL)
    701              {
    702                if(osal_memcmp(tempJoiningDescNode->bdbJoiningNodeEui64,JoiningExtAddr,Z_EXTADDR_LEN))
   \   000055   12....       LCALL     `??osal_memcmp::?relay`; Banked call to: osal_memcmp
   \   000058   7403         MOV       A,#0x3
   \   00005A   12....       LCALL     ?DEALLOC_XSTACK8
   \   00005D   E9           MOV       A,R1
   \   00005E   6053         JZ        ??bdb_TCjoiningDeviceComplete_1
    703                {
    704                  if(pfnTCLinkKeyExchangeProcessCB)
   \   000060   90....       MOV       DPTR,#pfnTCLinkKeyExchangeProcessCB
   \   000063   12....       LCALL     ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   000066   6042         JZ        ??bdb_TCjoiningDeviceComplete_2
    705                  {
    706                    bdb_TCLinkKeyExchProcess_t bdb_TCLinkKeyExchProcess;
    707                    osal_memcpy(bdb_TCLinkKeyExchProcess.extAddr,tempJoiningDescNode->bdbJoiningNodeEui64, Z_EXTADDR_LEN);
   \   000068                ; Setup parameters for call to function osal_memcpy
   \   000068   78..         MOV       R0,#?V0
   \   00006A   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00006D   7C08         MOV       R4,#0x8
   \   00006F   7D00         MOV       R5,#0x0
   \   000071   7406         MOV       A,#0x6
   \   000073   12....       LCALL     ?XSTACK_DISP0_8
   \   000076   AA82         MOV       R2,DPL
   \   000078   AB83         MOV       R3,DPH
   \   00007A   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   00007D   7403         MOV       A,#0x3
   \   00007F   12....       LCALL     ?DEALLOC_XSTACK8
    708                    bdb_TCLinkKeyExchProcess.status = BDB_TC_LK_EXCH_PROCESS_EXCH_SUCCESS;
   \   000082   7402         MOV       A,#0x2
   \   000084   12....       LCALL     ?XSTACK_DISP0_8
   \   000087   7401         MOV       A,#0x1
   \   000089   F0           MOVX      @DPTR,A
    709                    
    710                    bdb_SendMsg(bdb_TaskID, BDB_TC_LINK_KEY_EXCHANGE_PROCESS, BDB_MSG_EVENT_SUCCESS,sizeof(bdb_TCLinkKeyExchProcess_t),(uint8*)&bdb_TCLinkKeyExchProcess);
   \   00008A                ; Setup parameters for call to function bdb_SendMsg
   \   00008A   04           INC       A
   \   00008B   12....       LCALL     ?XSTACK_DISP100_8
   \   00008E   88..         MOV       ?V0,R0
   \   000090   89..         MOV       ?V1,R1
   \   000092   78..         MOV       R0,#?V0
   \   000094   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000097   7C09         MOV       R4,#0x9
   \   000099   7B00         MOV       R3,#0x0
   \   00009B   7A09         MOV       R2,#0x9
   \   00009D   90....       MOV       DPTR,#bdb_TaskID
   \   0000A0   E0           MOVX      A,@DPTR
   \   0000A1   F9           MOV       R1,A
   \   0000A2   12....       LCALL     `??bdb_SendMsg::?relay`; Banked call to: bdb_SendMsg
   \   0000A5   7402         MOV       A,#0x2
   \   0000A7   12....       LCALL     ?DEALLOC_XSTACK8
    711                  }        
    712                  
    713                  bdb_TCJoiningDeviceFree(tempJoiningDescNode);
   \                     ??bdb_TCjoiningDeviceComplete_2:
   \   0000AA                ; Setup parameters for call to function bdb_TCJoiningDeviceFree
   \   0000AA   EE           MOV       A,R6
   \   0000AB   FA           MOV       R2,A
   \   0000AC   EF           MOV       A,R7
   \   0000AD   FB           MOV       R3,A
   \   0000AE   12....       LCALL     `??bdb_TCJoiningDeviceFree::?relay`; Banked call to: bdb_TCJoiningDeviceFree
    714                  break;
   \   0000B1   800D         SJMP      ??bdb_TCjoiningDeviceComplete_3
    715                }
    716                tempJoiningDescNode = tempJoiningDescNode->nextDev;
   \                     ??bdb_TCjoiningDeviceComplete_1:
   \   0000B3   12....       LCALL     ?Subroutine29 & 0xFFFF
    717              }
   \                     ??CrossCallReturnLabel_36:
   \   0000B6   12....       LCALL     ??Subroutine50_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_87:
   \   0000B9   EE           MOV       A,R6
   \   0000BA   4F           ORL       A,R7
   \   0000BB   6003         JZ        $+5
   \   0000BD   02....       LJMP      ??CrossCallReturnLabel_90 & 0xFFFF
    718             
    719              if(bdb_joiningDeviceList == NULL)
   \                     ??bdb_TCjoiningDeviceComplete_3:
   \   0000C0   90....       MOV       DPTR,#bdb_joiningDeviceList
   \   0000C3   12....       LCALL     ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   0000C6   700C         JNZ       ??bdb_TCjoiningDeviceComplete_0
    720              {
    721                osal_stop_timerEx(bdb_TaskID,BDB_TC_JOIN_TIMEOUT);
   \   0000C8                ; Setup parameters for call to function osal_stop_timerEx
   \   0000C8   7A00         MOV       R2,#0x0
   \   0000CA   7B08         MOV       R3,#0x8
   \   0000CC   90....       MOV       DPTR,#bdb_TaskID
   \   0000CF   E0           MOVX      A,@DPTR
   \   0000D0   F9           MOV       R1,A
   \   0000D1   12....       LCALL     `??osal_stop_timerEx::?relay`; Banked call to: osal_stop_timerEx
    722              }
    723            }
    724          }
   \                     ??bdb_TCjoiningDeviceComplete_0:
   \   0000D4   02....       LJMP      ?Subroutine5 & 0xFFFF
    725          
    726          
    727          
    728          /****************************************************************************
    729           * @fn          bdb_TCJoiningDeviceFree
    730           *
    731           * @brief       This function frees a joining device from the list.
    732           *
    733           * @param       ZSuccess - If the device was found and erased
    734           * @param       ZInvalidParameter - Not found
    735           *
    736           * @return      none
    737           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    738          ZStatus_t bdb_TCJoiningDeviceFree(bdb_joiningDeviceList_t* JoiningDeviceToRemove)
   \                     bdb_TCJoiningDeviceFree:
    739          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV       A,#-0xe
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V4,R2
   \   000007   8B..         MOV       ?V5,R3
   \   000009   8A82         MOV       DPL,R2
   \   00000B   8B83         MOV       DPH,R3
   \   00000D   A3           INC       DPTR
   \   00000E   A3           INC       DPTR
   \   00000F   A982         MOV       R1,DPL
   \   000011   AA83         MOV       R2,DPH
   \   000013   89..         MOV       ?V0,R1
   \   000015   8A..         MOV       ?V1,R2
   \   000017   75..00       MOV       ?V2,#0x0
   \   00001A                ; Setup parameters for call to function osal_memcmp
   \   00001A   78..         MOV       R0,#?V0
   \   00001C   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   00001F   7C08         MOV       R4,#0x8
   \   000021   7D00         MOV       R5,#0x0
   \   000023   90....       MOV       DPTR,#bdb_joiningDeviceList
   \   000026   12....       LCALL     ?Subroutine23 & 0xFFFF
    740            bdb_joiningDeviceList_t* descCurrent;
    741            bdb_joiningDeviceList_t* descPrev;
    742            
    743            //validate empty list?
    744            
    745            //Is it the first?
    746            if(osal_memcmp(bdb_joiningDeviceList->bdbJoiningNodeEui64, JoiningDeviceToRemove->bdbJoiningNodeEui64, Z_EXTADDR_LEN))
   \                     ??CrossCallReturnLabel_23:
   \   000029   12....       LCALL     `??osal_memcmp::?relay`; Banked call to: osal_memcmp
   \   00002C   7403         MOV       A,#0x3
   \   00002E   12....       LCALL     ?DEALLOC_XSTACK8
   \   000031   E9           MOV       A,R1
   \   000032   90....       MOV       DPTR,#bdb_joiningDeviceList
   \   000035   6011         JZ        ??bdb_TCJoiningDeviceFree_0
    747            {
    748              descCurrent = bdb_joiningDeviceList;
   \   000037   12....       LCALL     ??Subroutine51_0 & 0xFFFF
    749              bdb_joiningDeviceList = bdb_joiningDeviceList->nextDev;
   \                     ??CrossCallReturnLabel_92:
   \   00003A   90....       MOV       DPTR,#bdb_joiningDeviceList
   \   00003D   12....       LCALL     ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   000040   90....       MOV       DPTR,#bdb_joiningDeviceList
   \   000043   12....       LCALL     ??Subroutine52_0 & 0xFFFF
    750              osal_mem_free( descCurrent );
   \                     ??CrossCallReturnLabel_99:
   \   000046                ; Setup parameters for call to function osal_mem_free
   \   000046   8035         SJMP      ??bdb_TCJoiningDeviceFree_1
    751              return ZSuccess;
    752            }
    753            
    754            descPrev = NULL;
    755            descCurrent = bdb_joiningDeviceList;
    756            
    757            while(descCurrent != NULL)
    758            {
    759              if(osal_memcmp(descCurrent->nextDev->bdbJoiningNodeEui64, JoiningDeviceToRemove->bdbJoiningNodeEui64, Z_EXTADDR_LEN))
    760              {
    761                descPrev = descCurrent;
    762                break;
    763              }
    764              descCurrent = descCurrent->nextDev;
   \                     ??bdb_TCJoiningDeviceFree_0:
   \   000048   12....       LCALL     ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   00004B   6037         JZ        ??bdb_TCJoiningDeviceFree_2
   \   00004D   EA           MOV       A,R2
   \   00004E   240B         ADD       A,#0xb
   \   000050   FE           MOV       R6,A
   \   000051   E4           CLR       A
   \   000052   3B           ADDC      A,R3
   \   000053   FF           MOV       R7,A
   \   000054                ; Setup parameters for call to function osal_memcmp
   \   000054   78..         MOV       R0,#?V0
   \   000056   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000059   7C08         MOV       R4,#0x8
   \   00005B   7D00         MOV       R5,#0x0
   \   00005D   8E82         MOV       DPL,R6
   \   00005F   8F83         MOV       DPH,R7
   \   000061   12....       LCALL     ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   000064   12....       LCALL     `??osal_memcmp::?relay`; Banked call to: osal_memcmp
   \   000067   7403         MOV       A,#0x3
   \   000069   12....       LCALL     ?DEALLOC_XSTACK8
   \   00006C   E9           MOV       A,R1
   \   00006D   8E82         MOV       DPL,R6
   \   00006F   8F83         MOV       DPH,R7
   \   000071   60D5         JZ        ??bdb_TCJoiningDeviceFree_0
    765            }
    766            if(descPrev == NULL)
    767            {
    768              //Not found
    769              return ZInvalidParameter;
    770            }
    771            
    772            descPrev->nextDev = descPrev->nextDev->nextDev;
   \   000073   12....       LCALL     ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   000076   12....       LCALL     ?Subroutine31 & 0xFFFF
    773              
    774            osal_mem_free( JoiningDeviceToRemove );
   \                     ??CrossCallReturnLabel_103:
   \   000079                ; Setup parameters for call to function osal_mem_free
   \   000079   AA..         MOV       R2,?V4
   \   00007B   AB..         MOV       R3,?V5
   \                     ??bdb_TCJoiningDeviceFree_1:
   \   00007D   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
    775            return ZSuccess;
   \   000080   7900         MOV       R1,#0x0
   \   000082   8002         SJMP      ??bdb_TCJoiningDeviceFree_3
   \                     ??bdb_TCJoiningDeviceFree_2:
   \   000084   7902         MOV       R1,#0x2
   \                     ??bdb_TCJoiningDeviceFree_3:
   \   000086   02....       LJMP      ?Subroutine3 & 0xFFFF
    776          
    777          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   12....       LCALL     ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_41:
   \   000003   A982         MOV       R1,DPL
   \   000005   AA83         MOV       R2,DPH
   \   000007   7B00         MOV       R3,#0x0
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   C8           XCH       A,R0
   \   000005   240B         ADD       A,#0xb
   \   000007   F582         MOV       DPL,A
   \   000009   E4           CLR       A
   \   00000A   38           ADDC      A,R0
   \   00000B   F583         MOV       DPH,A
   \   00000D   12....       LCALL     ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   000010   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F583         MOV       DPH,A
   \   000006   8882         MOV       DPL,R0
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   12....       LCALL     ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_44:
   \   000003   A3           INC       DPTR
   \   000004   A3           INC       DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   FB           MOV       R3,A
   \   000005   EA           MOV       A,R2
   \   000006   4B           ORL       A,R3
   \   000007   22           RET
    778          
    779           /*********************************************************************
    780           * @fn          bdb_setJoinUsesInstallCodeKey
    781           *
    782           * @brief       Set BDB attribute bdbJoinUsesInstallCodeKey.
    783           *
    784           * @param       set - If TRUE only devices with IC register in TC can join the 
    785           *              nwk, otherwise devices may or not have a IC register
    786           *
    787           * @return      none
    788           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    789          void bdb_setJoinUsesInstallCodeKey(bool set)
   \                     bdb_setJoinUsesInstallCodeKey:
    790          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    791            bdbAttributes.bdbJoinUsesInstallCodeKey = set;
   \   000004   E9           MOV       A,R1
   \   000005   90....       MOV       DPTR,#bdbAttributes + 15
   \   000008   F0           MOVX      @DPTR,A
    792            if(set)
   \   000009   90....       MOV       DPTR,#zgAllowInstallCodes
   \   00000C   6004         JZ        ??bdb_setJoinUsesInstallCodeKey_0
    793            {
    794              zgAllowInstallCodes = ZG_IC_MUST_USED;
   \   00000E   7402         MOV       A,#0x2
   \   000010   8002         SJMP      ??bdb_setJoinUsesInstallCodeKey_1
    795            }
    796            else
    797            {
    798              zgAllowInstallCodes = ZG_IC_SUPPORTED_NOT_REQUIRED;
   \                     ??bdb_setJoinUsesInstallCodeKey_0:
   \   000012   7401         MOV       A,#0x1
    799            }
   \                     ??bdb_setJoinUsesInstallCodeKey_1:
   \   000014   02....       LJMP      ??Subroutine39_0 & 0xFFFF
    800          }
    801          #endif
    802          
    803           /*********************************************************************
    804           * @fn          bdb_StartCommissioning
    805           *
    806           * @brief       Start the commissioning process setting the commissioning mode given.
    807           *
    808           * @param       mode - refer to bdbCommissioningMode
    809           *
    810           * @return      none
    811           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    812          void bdb_StartCommissioning(uint8 mode)
   \                     bdb_StartCommissioning:
    813          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 20
   \   000005   74EC         MOV       A,#-0x14
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   89..         MOV       ?V0,R1
    814            //Application cannot request to set the device in initialization mode or parent lost
    815            mode &= ~(BDB_COMMISSIONING_MODE_INITIALIZATION | BDB_COMMISSIONING_MODE_PARENT_LOST);
    816              
    817          #ifdef BDB_TL_INITIATOR
    818            if ( touchlinkFNReset == TRUE )
    819            {
    820              return;
    821            }
    822          #else
    823            //Commissioning mode used only for initiator
    824            mode &= ~BDB_COMMISSIONING_MODE_INITIATOR_TL;
   \   00000C   53..CE       ANL       ?V0,#0xce
    825          #endif
    826            
    827          #if (BDB_FINDING_BINDING_CAPABILITY_ENABLED==0)    
    828            //Commissioning mode used only for devices with F&B
    829            mode &= ~BDB_COMMISSIONING_MODE_FINDING_BINDING;
    830          #endif
    831           
    832            //If we have running process or the machine state is triggered, then just append and it will be excecuted
    833            if((bdbAttributes.bdbCommissioningMode) || (osal_get_timeoutEx(bdb_TaskID,BDB_CHANGE_COMMISSIONING_STATE)))
   \   00000F   90....       MOV       DPTR,#bdbAttributes + 11
   \   000012   E0           MOVX      A,@DPTR
   \   000013   7012         JNZ       ??bdb_StartCommissioning_0
   \   000015                ; Setup parameters for call to function osal_get_timeoutEx
   \   000015   7A04         MOV       R2,#0x4
   \   000017   7B00         MOV       R3,#0x0
   \   000019   90....       MOV       DPTR,#bdb_TaskID
   \   00001C   E0           MOVX      A,@DPTR
   \   00001D   F9           MOV       R1,A
   \   00001E   12....       LCALL     `??osal_get_timeoutEx::?relay`; Banked call to: osal_get_timeoutEx
   \   000021   EA           MOV       A,R2
   \   000022   4B           ORL       A,R3
   \   000023   4C           ORL       A,R4
   \   000024   4D           ORL       A,R5
   \   000025   6027         JZ        ??bdb_StartCommissioning_1
    834            {
    835              
    836              //If we are on the network and got requested to do nwk steering, we do not need to wait other process, 
    837              // just send permit joining and report the application
    838              if((bdbAttributes.bdbNodeIsOnANetwork) && (mode & BDB_COMMISSIONING_MODE_NWK_STEERING))
   \                     ??bdb_StartCommissioning_0:
   \   000027   90....       MOV       DPTR,#bdbAttributes + 14
   \   00002A   E0           MOVX      A,@DPTR
   \   00002B   6013         JZ        ??bdb_StartCommissioning_2
   \   00002D   E5..         MOV       A,?V0
   \   00002F   A2E1         MOV       C,0xE0 /* A   */.1
   \   000031   500D         JNC       ??bdb_StartCommissioning_2
    839              {
    840                bdb_nwkSteeringDeviceOnNwk();
   \   000033                ; Setup parameters for call to function bdb_nwkSteeringDeviceOnNwk
   \   000033   12....       LCALL     `??bdb_nwkSteeringDeviceOnNwk::?relay`; Banked call to: bdb_nwkSteeringDeviceOnNwk
    841                bdb_reportCommissioningState(BDB_COMMISSIONING_STATE_STEERING_ON_NWK, TRUE);
   \   000036                ; Setup parameters for call to function bdb_reportCommissioningState
   \   000036   7A01         MOV       R2,#0x1
   \   000038   7904         MOV       R1,#0x4
   \   00003A   12....       LCALL     `??bdb_reportCommissioningState::?relay`; Banked call to: bdb_reportCommissioningState
    842                
    843                //Clean nwk steering
    844                mode ^= BDB_COMMISSIONING_MODE_NWK_STEERING; 
   \   00003D   63..02       XRL       ?V0,#0x2
    845              }
    846              
    847              //add the remaining valid commissioning modes requested, those will be process when bdb finish its current process
    848              bdbAttributes.bdbCommissioningMode |= mode & BDB_COMMISSIONING_MODES;
   \                     ??bdb_StartCommissioning_2:
   \   000040   743F         MOV       A,#0x3f
   \   000042   55..         ANL       A,?V0
   \   000044   F8           MOV       R0,A
   \   000045   90....       MOV       DPTR,#bdbAttributes + 11
   \   000048   E0           MOVX      A,@DPTR
   \   000049   48           ORL       A,R0
   \   00004A   F0           MOVX      @DPTR,A
    849              return;      
   \   00004B   02....       LJMP      ??bdb_StartCommissioning_3 & 0xFFFF
    850            }
    851          
    852            //Save the commissioning modes valid requested
    853            bdbAttributes.bdbCommissioningMode |= mode & BDB_COMMISSIONING_MODES;
   \                     ??bdb_StartCommissioning_1:
   \   00004E   743F         MOV       A,#0x3f
   \   000050   55..         ANL       A,?V0
   \   000052   FE           MOV       R6,A
   \   000053   90....       MOV       DPTR,#bdbAttributes + 11
   \   000056   E0           MOVX      A,@DPTR
   \   000057   4E           ORL       A,R6
   \   000058   F0           MOVX      @DPTR,A
    854            
    855            
    856            //Start processing the initialization, once per power cycle.
    857            if(!bdb_initialization)
   \   000059   90....       MOV       DPTR,#bdb_initialization
   \   00005C   E0           MOVX      A,@DPTR
   \   00005D   6003         JZ        $+5
   \   00005F   02....       LJMP      ??bdb_StartCommissioning_4 & 0xFFFF
    858            {
    859              bdb_initialization = TRUE;
   \   000062   7401         MOV       A,#0x1
   \   000064   12....       LCALL     ?Subroutine14 & 0xFFFF
    860              
    861          #ifdef BDB_REPORTING
    862              //Delete NV data if startup was with factory reset
    863              if(ZDO_INITDEV_NEW_NETWORK_STATE == ZDApp_ReadNetworkRestoreState())
    864              {
    865                //Factory reset bdb reporting NV data
    866                uint16 attrRepNvLen = osal_nv_item_len( ZCD_NV_BDBREPORTINGCONFIG );
    867                if ( attrRepNvLen > 0 )
    868                {
    869                  osal_nv_delete( ZCD_NV_BDBREPORTINGCONFIG, attrRepNvLen );
    870                }
    871              }
    872          
    873              //Construct the Endpoint-cluster array
    874              bdb_RepConstructReportingData();
    875          #endif //BDB_REPORTING
    876              
    877              osal_nv_read(ZCD_NV_BDBNODEISONANETWORK,0,sizeof(bdbAttributes.bdbNodeIsOnANetwork),&bdbAttributes.bdbNodeIsOnANetwork);
   \                     ??CrossCallReturnLabel_8:
   \   000067   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00006A   75..01       MOV       ?V2,#0x1
   \   00006D   75..00       MOV       ?V3,#0x0
   \   000070   78..         MOV       R0,#?V2
   \   000072   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000075   7C00         MOV       R4,#0x0
   \   000077   7D00         MOV       R5,#0x0
   \   000079   7A55         MOV       R2,#0x55
   \   00007B   7B00         MOV       R3,#0x0
   \   00007D   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000080   7404         MOV       A,#0x4
   \   000082   12....       LCALL     ?DEALLOC_XSTACK8
    878              
    879              //Are we on a network
    880              if(bdbAttributes.bdbNodeIsOnANetwork == TRUE)
   \   000085   90....       MOV       DPTR,#bdbAttributes + 14
   \   000088   E0           MOVX      A,@DPTR
   \   000089   6401         XRL       A,#0x1
   \   00008B   6003         JZ        $+5
   \   00008D   02....       LJMP      ??bdb_StartCommissioning_4 & 0xFFFF
    881              {
    882          #ifdef ZG_BUILD_JOINING_TYPE
    883                //Only for joining devices validate the joining procedure
    884                if(ZG_DEVICE_JOINING_TYPE)
   \   000090   90....       MOV       DPTR,#zgDeviceLogicalType
   \   000093   E0           MOVX      A,@DPTR
   \   000094   6401         XRL       A,#0x1
   \   000096   6008         JZ        ??bdb_StartCommissioning_5
   \   000098   E0           MOVX      A,@DPTR
   \   000099   6402         XRL       A,#0x2
   \   00009B   6003         JZ        $+5
   \   00009D   02....       LJMP      ??bdb_StartCommissioning_6 & 0xFFFF
    885                {
    886                  //If we got into a network
    887                  if(!osal_isbufset( AIB_apsTrustCenterAddress, 0x00, Z_EXTADDR_LEN ))
   \                     ??bdb_StartCommissioning_5:
   \   0000A0                ; Setup parameters for call to function osal_isbufset
   \   0000A0   7C08         MOV       R4,#0x8
   \   0000A2   7900         MOV       R1,#0x0
   \   0000A4   90....       MOV       DPTR,#AIB_apsTrustCenterAddress
   \   0000A7   12....       LCALL     ??Subroutine51_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_93:
   \   0000AA   12....       LCALL     `??osal_isbufset::?relay`; Banked call to: osal_isbufset
   \   0000AD   E9           MOV       A,R1
   \   0000AE   6003         JZ        $+5
   \   0000B0   02....       LJMP      ??bdb_StartCommissioning_6 & 0xFFFF
    888                  {
    889                    //Which is not distributed
    890                    if(!APSME_IsDistributedSecurity())
   \   0000B3                ; Setup parameters for call to function APSME_IsDistributedSecurity
   \   0000B3   12....       LCALL     `??APSME_IsDistributedSecurity::?relay`; Banked call to: APSME_IsDistributedSecurity
   \   0000B6   E9           MOV       A,R1
   \   0000B7   6003         JZ        $+5
   \   0000B9   02....       LJMP      ??bdb_StartCommissioning_6 & 0xFFFF
    891                    {
    892                      uint8 keyAttributes;
    893                      osal_nv_read(ZCD_NV_TCLK_TABLE_START, osal_offsetof(APSME_TCLKDevEntry_t,keyAttributes), sizeof(uint8), &keyAttributes);
   \   0000BC                ; Setup parameters for call to function osal_nv_read
   \   0000BC   A8..         MOV       R0,?XSP + 0
   \   0000BE   A9..         MOV       R1,?XSP + 1
   \   0000C0   88..         MOV       ?V2,R0
   \   0000C2   89..         MOV       ?V3,R1
   \   0000C4   78..         MOV       R0,#?V2
   \   0000C6   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000C9   75..01       MOV       ?V2,#0x1
   \   0000CC   75..00       MOV       ?V3,#0x0
   \   0000CF   78..         MOV       R0,#?V2
   \   0000D1   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000D4   7C10         MOV       R4,#0x10
   \   0000D6   7D00         MOV       R5,#0x0
   \   0000D8   7A11         MOV       R2,#0x11
   \   0000DA   7B01         MOV       R3,#0x1
   \   0000DC   12....       LCALL     `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   0000DF   7404         MOV       A,#0x4
   \   0000E1   12....       LCALL     ?DEALLOC_XSTACK8
    894                      //If we must perform the TCLK exchange and we didn't complete it, then reset to FN
    895                      if(requestNewTrustCenterLinkKey && (keyAttributes != ZG_NON_R21_NWK_JOINED) && (keyAttributes != ZG_VERIFIED_KEY))
   \   0000E4   90....       MOV       DPTR,#requestNewTrustCenterLinkKey
   \   0000E7   E0           MOVX      A,@DPTR
   \   0000E8   7003         JNZ       $+5
   \   0000EA   02....       LJMP      ??bdb_StartCommissioning_6 & 0xFFFF
   \   0000ED   85..82       MOV       DPL,?XSP + 0
   \   0000F0   85..83       MOV       DPH,?XSP + 1
   \   0000F3   E0           MOVX      A,@DPTR
   \   0000F4   64FD         XRL       A,#0xfd
   \   0000F6   607B         JZ        ??bdb_StartCommissioning_6
   \   0000F8   E0           MOVX      A,@DPTR
   \   0000F9   6402         XRL       A,#0x2
   \   0000FB   6076         JZ        ??bdb_StartCommissioning_6
    896                      {
    897                        //Force to initialize the entry
    898                        APSME_TCLKDevEntry_t APSME_TCLKDevEntry;
    899                        
    900                        osal_memset(&APSME_TCLKDevEntry,0,sizeof(APSME_TCLKDevEntry_t));
   \   0000FD                ; Setup parameters for call to function osal_memset
   \   0000FD   7C13         MOV       R4,#0x13
   \   0000FF   7D00         MOV       R5,#0x0
   \   000101   7900         MOV       R1,#0x0
   \   000103   7401         MOV       A,#0x1
   \   000105   12....       LCALL     ?XSTACK_DISP101_8
   \   000108   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
    901                        APSME_TCLKDevEntry.keyAttributes = ZG_DEFAULT_KEY;
   \   00010B   7411         MOV       A,#0x11
   \   00010D   12....       LCALL     ?XSTACK_DISP0_8
   \   000110   74FF         MOV       A,#-0x1
   \   000112   F0           MOVX      @DPTR,A
    902                        osal_nv_write(ZCD_NV_TCLK_TABLE_START, 0, sizeof(APSME_TCLKDevEntry_t), &APSME_TCLKDevEntry);
   \   000113                ; Setup parameters for call to function osal_nv_write
   \   000113   7401         MOV       A,#0x1
   \   000115   12....       LCALL     ?XSTACK_DISP100_8
   \   000118   88..         MOV       ?V2,R0
   \   00011A   89..         MOV       ?V3,R1
   \   00011C   78..         MOV       R0,#?V2
   \   00011E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000121   75..13       MOV       ?V2,#0x13
   \   000124   75..00       MOV       ?V3,#0x0
   \   000127   78..         MOV       R0,#?V2
   \   000129   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00012C   7C00         MOV       R4,#0x0
   \   00012E   7D00         MOV       R5,#0x0
   \   000130   7A11         MOV       R2,#0x11
   \   000132   7B01         MOV       R3,#0x1
   \   000134   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000137   7404         MOV       A,#0x4
   \   000139   12....       LCALL     ?DEALLOC_XSTACK8
    903                        TCLinkKeyFrmCntr[0].txFrmCntr = 0;
   \   00013C   90....       MOV       DPTR,#TCLinkKeyFrmCntr
   \   00013F   12....       LCALL     ?Subroutine10 & 0xFFFF
    904                        TCLinkKeyFrmCntr[0].rxFrmCntr = 0;
   \                     ??CrossCallReturnLabel_48:
   \   000142   A3           INC       DPTR
   \   000143   12....       LCALL     ??Subroutine38_0 & 0xFFFF
    905                        
    906                        
    907                        //reset the device parameters to FN
    908                        bdbAttributes.bdbNodeIsOnANetwork = FALSE;
   \                     ??CrossCallReturnLabel_46:
   \   000146   90....       MOV       DPTR,#bdbAttributes + 14
   \   000149   12....       LCALL     ?Subroutine14 & 0xFFFF
    909                        osal_nv_write(ZCD_NV_BDBNODEISONANETWORK,0,sizeof(bdbAttributes.bdbNodeIsOnANetwork),&bdbAttributes.bdbNodeIsOnANetwork);
   \                     ??CrossCallReturnLabel_9:
   \   00014C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00014F   75..01       MOV       ?V2,#0x1
   \   000152   75..00       MOV       ?V3,#0x0
   \   000155   78..         MOV       R0,#?V2
   \   000157   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00015A   7C00         MOV       R4,#0x0
   \   00015C   7D00         MOV       R5,#0x0
   \   00015E   7A55         MOV       R2,#0x55
   \   000160   7B00         MOV       R3,#0x0
   \   000162   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000165   7404         MOV       A,#0x4
   \   000167   12....       LCALL     ?DEALLOC_XSTACK8
    910                        zgWriteStartupOptions(ZG_STARTUP_SET, ZCD_STARTOPT_DEFAULT_CONFIG_STATE | ZCD_STARTOPT_DEFAULT_NETWORK_STATE);
   \   00016A                ; Setup parameters for call to function zgWriteStartupOptions
   \   00016A   7A03         MOV       R2,#0x3
   \   00016C   79FF         MOV       R1,#-0x1
   \   00016E   12....       LCALL     `??zgWriteStartupOptions::?relay`; Banked call to: zgWriteStartupOptions
    911                        
    912                        //Then start the commissioning process requested
    913                        bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_START_RESUME;
   \   000171   803B         SJMP      ??bdb_StartCommissioning_7
    914                        osal_set_event( bdb_TaskID, BDB_CHANGE_COMMISSIONING_STATE );
    915                        return;
    916                      }
    917                    }
    918                  }
    919                }
    920          #endif //ZG_BUILD_JOINING_TYPE
    921                
    922                //Set the initialization
    923                bdbAttributes.bdbCommissioningMode |= BDB_COMMISSIONING_MODE_INITIALIZATION;
    924                bdbCommissioningProcedureState.bdbCommissioningState = BDB_INITIALIZATION;
   \                     ??bdb_StartCommissioning_6:
   \   000173   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   000176   7407         MOV       A,#0x7
   \   000178   F0           MOVX      @DPTR,A
    925                bdbAttributes.bdbCommissioningMode |= mode & BDB_COMMISSIONING_MODES;
   \   000179   7410         MOV       A,#0x10
   \   00017B   4E           ORL       A,R6
   \   00017C   F8           MOV       R0,A
   \   00017D   90....       MOV       DPTR,#bdbAttributes + 11
   \   000180   E0           MOVX      A,@DPTR
   \   000181   48           ORL       A,R0
   \   000182   F0           MOVX      @DPTR,A
    926                
    927                if(ZDOInitDevice(0) == ZDO_INITDEV_RESTORED_NETWORK_STATE)
   \   000183                ; Setup parameters for call to function ZDOInitDeviceEx
   \   000183   7900         MOV       R1,#0x0
   \   000185   7A00         MOV       R2,#0x0
   \   000187   7B00         MOV       R3,#0x0
   \   000189   12....       LCALL     `??ZDOInitDeviceEx::?relay`; Banked call to: ZDOInitDeviceEx
   \   00018C   E9           MOV       A,R1
   \   00018D   602F         JZ        ??bdb_StartCommissioning_3
    928                {
    929          #ifdef BDB_REPORTING
    930                  //Mark the clusterEndpoint entries that have binding, starts reporting if at least one entry was marked
    931                  bdb_RepUpdateMarkBindings();
    932          #endif
    933                  return;
    934                }
    935                bdb_setNodeIsOnANetwork(FALSE);  
   \   00018F                ; Setup parameters for call to function bdb_setNodeIsOnANetwork
   \   00018F   7900         MOV       R1,#0x0
   \   000191   12....       LCALL     `??bdb_setNodeIsOnANetwork::?relay`; Banked call to: bdb_setNodeIsOnANetwork
    936                //Not in the network
    937                bdb_reportCommissioningState(BDB_INITIALIZATION,FALSE);
   \   000194                ; Setup parameters for call to function bdb_reportCommissioningState
   \   000194   7A00         MOV       R2,#0x0
   \   000196   7907         MOV       R1,#0x7
   \   000198   800F         SJMP      ??bdb_StartCommissioning_8
    938                return;
    939              }
    940            }
    941          
    942            //Got requested only to initialize, if so, report that it failed
    943            if(bdbAttributes.bdbCommissioningMode == 0)
   \                     ??bdb_StartCommissioning_4:
   \   00019A   90....       MOV       DPTR,#bdbAttributes + 11
   \   00019D   E0           MOVX      A,@DPTR
   \   00019E   700E         JNZ       ??bdb_StartCommissioning_7
    944            {
    945              //Set the initialization state and report it to fail
    946              bdbCommissioningProcedureState.bdbCommissioningState = BDB_INITIALIZATION;
   \   0001A0   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   0001A3   7407         MOV       A,#0x7
   \   0001A5   F0           MOVX      @DPTR,A
    947              bdb_reportCommissioningState(BDB_INITIALIZATION,FALSE);
   \   0001A6                ; Setup parameters for call to function bdb_reportCommissioningState
   \   0001A6   7A00         MOV       R2,#0x0
   \   0001A8   F9           MOV       R1,A
   \                     ??bdb_StartCommissioning_8:
   \   0001A9   12....       LCALL     `??bdb_reportCommissioningState::?relay`; Banked call to: bdb_reportCommissioningState
    948              return;
   \   0001AC   8010         SJMP      ??bdb_StartCommissioning_3
    949            }
    950          
    951            
    952            //Start the commissioning process
    953            bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_START_RESUME;
   \                     ??bdb_StartCommissioning_7:
   \   0001AE   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   0001B1   E4           CLR       A
   \   0001B2   F0           MOVX      @DPTR,A
    954            osal_set_event( bdb_TaskID, BDB_CHANGE_COMMISSIONING_STATE );
   \   0001B3                ; Setup parameters for call to function osal_set_event
   \   0001B3   7A04         MOV       R2,#0x4
   \   0001B5   FB           MOV       R3,A
   \   0001B6   90....       MOV       DPTR,#bdb_TaskID
   \   0001B9   E0           MOVX      A,@DPTR
   \   0001BA   F9           MOV       R1,A
   \   0001BB   12....       LCALL     `??osal_set_event::?relay`; Banked call to: osal_set_event
    955          }
   \                     ??bdb_StartCommissioning_3:
   \   0001BE   7414         MOV       A,#0x14
   \   0001C0   02....       LJMP      ??Subroutine42_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   F0           MOVX      @DPTR,A
   \   000001                ; Setup parameters for call to function osal_nv_read
   \   000001                ; Setup parameters for call to function osal_nv_write
   \   000001   75....       MOV       ?V2,#(bdbAttributes + 14) & 0xff
   \   000004   75....       MOV       ?V3,#((bdbAttributes + 14) >> 8) & 0xff
   \   000007   78..         MOV       R0,#?V2
   \   000009   22           RET
    956          
    957          
    958           /*********************************************************************
    959           * @fn          bdb_NotifyCommissioningModeStart
    960           *
    961           * @brief       Notify the user about a commissioning method just started
    962           *
    963           * @param       commissioningMode
    964           *
    965           * @return      none
    966           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine37_0
   \   000003                ; // Fall through to label ??Subroutine37_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    967          void bdb_NotifyCommissioningModeStart(uint8 commissioningMode)
   \                     bdb_NotifyCommissioningModeStart:
    968          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 3
   \   000005   74FD         MOV       A,#-0x3
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
    969            bdbCommissioningModeMsg_t bdbCommissioningModeMsg;
    970          
    971            bdbCommissioningModeMsg.bdbCommissioningMode = commissioningMode;
   \   00000A   7401         MOV       A,#0x1
   \   00000C   12....       LCALL     ?XSTACK_DISP0_8
   \   00000F   E9           MOV       A,R1
   \   000010   12....       LCALL     ??Subroutine47_0 & 0xFFFF
    972            bdbCommissioningModeMsg.bdbCommissioningStatus = BDB_COMMISSIONING_IN_PROGRESS;
   \                     ??CrossCallReturnLabel_77:
   \   000013   7401         MOV       A,#0x1
   \   000015   12....       LCALL     ?Subroutine9 & 0xFFFF
    973            //Remaining commissioning modes are set just before the call to the application to avoid race conditions
    974          
    975            bdb_NotifyApp((uint8*)&bdbCommissioningModeMsg);
   \                     ??CrossCallReturnLabel_0:
   \   000018   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001B   7C03         MOV       R4,#0x3
   \   00001D   7B00         MOV       R3,#0x0
   \   00001F   7A0A         MOV       R2,#0xa
   \   000021   90....       MOV       DPTR,#bdb_TaskID
   \   000024   E0           MOVX      A,@DPTR
   \   000025   F9           MOV       R1,A
   \   000026   12....       LCALL     `??bdb_SendMsg::?relay`; Banked call to: bdb_SendMsg
   \   000029   7402         MOV       A,#0x2
   \   00002B   12....       LCALL     ?DEALLOC_XSTACK8
    976          }
   \   00002E   7403         MOV       A,#0x3
   \   000030   02....       LJMP      ?Subroutine1 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   F0           MOVX      @DPTR,A
   \   000001                ; Setup parameters for call to function bdb_SendMsg
   \   000001                ; Setup parameters for call to function bdb_SendMsg
   \   000001                ; Setup parameters for call to function bdb_SendMsg
   \   000001                ; Setup parameters for call to function bdb_SendMsg
   \   000001   A8..         MOV       R0,?XSP + 0
   \   000003   A9..         MOV       R1,?XSP + 1
   \   000005   88..         MOV       ?V0,R0
   \   000007   89..         MOV       ?V1,R1
   \   000009   78..         MOV       R0,#?V0
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine47_0:
   \   000000   F0           MOVX      @DPTR,A
   \   000001   85..82       MOV       DPL,?XSP + 0
   \   000004   85..83       MOV       DPH,?XSP + 1
   \   000007   22           RET
    977          
    978          
    979          
    980          #if (ZG_BUILD_JOINING_TYPE)
    981           /*********************************************************************
    982           * @fn          bdb_setNodeJoinLinkKeyType
    983           *
    984           * @brief       Set the key type in use in the network joined. Global centralized key is used by default
    985           *
    986           * @param       none
    987           *
    988           * @return      none
    989           */
    990          void bdb_setNodeJoinLinkKeyType(uint8 KeyType)
    991          {
    992            bdbAttributes.bdbNodeJoinLinkKeyType = KeyType;
    993          }
    994          #endif
    995          
    996           /*********************************************************************
    997           * @fn          bdb_setFN
    998           *
    999           * @brief       Set configuration for FN. This FN configuration will be perfome 
   1000           *              upon call to ZDOInitDevice
   1001           *
   1002           * @param       none
   1003           *
   1004           * @return      none
   1005           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1006          void bdb_setFN(void)
   \                     bdb_setFN:
   1007          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1008            bdb_setNodeIsOnANetwork(FALSE);
   \   000004                ; Setup parameters for call to function bdb_setNodeIsOnANetwork
   \   000004   7900         MOV       R1,#0x0
   \   000006   12....       LCALL     `??bdb_setNodeIsOnANetwork::?relay`; Banked call to: bdb_setNodeIsOnANetwork
   1009          
   1010          #if defined ( INTER_PAN ) && defined ( BDB_TL_INITIATOR )
   1011              touchLink_InitFreeRanges( TRUE );
   1012              touchLink_UpdateNV( TOUCHLINK_UPDATE_NV_RANGES );
   1013          #endif
   1014          #if defined ( INTER_PAN ) && defined ( BDB_TL_TARGET ) 
   1015              touchLink_InitFreeRanges( FALSE );
   1016              touchLink_UpdateNV( TOUCHLINK_UPDATE_NV_RANGES );
   1017          #endif
   1018          
   1019            //Set the device as factory new
   1020            zgWriteStartupOptions(ZG_STARTUP_SET, ZCD_STARTOPT_DEFAULT_CONFIG_STATE | ZCD_STARTOPT_DEFAULT_NETWORK_STATE);
   \   000009                ; Setup parameters for call to function zgWriteStartupOptions
   \   000009   7A03         MOV       R2,#0x3
   \   00000B   79FF         MOV       R1,#-0x1
   \   00000D   12....       LCALL     `??zgWriteStartupOptions::?relay`; Banked call to: zgWriteStartupOptions
   1021          }
   \   000010   80..         SJMP      ??Subroutine40_0
   1022          
   1023           /*********************************************************************
   1024           * @fn          bdb_resetLocalAction
   1025           *
   1026           * @brief       Application interface to perform BDB Reset to FN.
   1027           *
   1028           * @param       none
   1029           *
   1030           * @return      none
   1031           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1032          void bdb_resetLocalAction(void)
   \                     bdb_resetLocalAction:
   1033          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1034            //Process reset as nwk leave if the device is on the network and is able to process it
   1035            if((ZG_BUILD_JOINING_TYPE) && (bdbAttributes.bdbNodeIsOnANetwork) && (!(bdbAttributes.bdbCommissioningMode & BDB_COMMISSIONING_MODE_PARENT_LOST)))
   1036            {
   1037              NLME_LeaveReq_t leaveReq;
   1038              // Set every field to 0
   1039              osal_memset( &leaveReq, 0, sizeof( NLME_LeaveReq_t ) );
   1040              
   1041              bdb_setFN();
   1042                
   1043              NLME_LeaveReq( &leaveReq );
   1044              
   1045              return;
   1046            }
   1047            else
   1048            {
   1049              bdb_setFN();
   \   000004                ; Setup parameters for call to function bdb_setFN
   \   000004   12....       LCALL     `??bdb_setFN::?relay`; Banked call to: bdb_setFN
   1050              
   1051              ZDApp_ResetTimerStart( 500 );
   \   000007                ; Setup parameters for call to function ZDApp_ResetTimerStart
   \   000007   7AF4         MOV       R2,#-0xc
   \   000009   7B01         MOV       R3,#0x1
   \   00000B   12....       LCALL     `??ZDApp_ResetTimerStart::?relay`; Banked call to: ZDApp_ResetTimerStart
   1052            }
   1053          }
   \   00000E   80..         SJMP      ??Subroutine40_0
   1054          
   1055          
   1056           /*********************************************************************
   1057           * @fn          bdb_parentLost
   1058           *
   1059           * @brief       Notify bdb that connection with parent is lost
   1060           *
   1061           * @return      none
   1062           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1063          void bdb_parentLost(void)
   \                     bdb_parentLost:
   1064          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1065          #if ZG_BUILD_ENDDEVICE_TYPE
   1066            if(ZG_DEVICE_ENDDEVICE_TYPE)
   1067            {
   1068              while(pBDBListNwk)
   1069              {
   1070                bdb_nwkDescFree(pBDBListNwk);
   1071              }
   1072              
   1073              nwk_desc_list_free();  
   1074              if(bdbCommissioningProcedureState.bdbCommissioningState != BDB_PARENT_LOST)
   1075              {
   1076                //If parent lost during TCLK exchange, then report TCLK exchange fail
   1077                if(bdbCommissioningProcedureState.bdbCommissioningState == BDB_COMMISSIONING_STATE_TC_LINK_KEY_EXCHANGE)
   1078                {
   1079                  bdb_reportCommissioningState(BDB_COMMISSIONING_STATE_TC_LINK_KEY_EXCHANGE, FALSE);
   1080                  return;
   1081                }
   1082                bdbCommissioningProcedureState.bdb_ParentLostSavedState = bdbCommissioningProcedureState.bdbCommissioningState;
   1083                
   1084              }
   1085              bdbCommissioningProcedureState.bdbCommissioningState = BDB_PARENT_LOST;
   1086              NLME_OrphanStateSet();
   1087              ZDApp_ChangeState( DEV_NWK_ORPHAN );
   1088              bdb_reportCommissioningState(BDB_PARENT_LOST,FALSE);
   1089            }
   1090          #endif
   1091          }
   \   000000   02....       LJMP      ?BRET
   1092          
   1093          
   1094          
   1095          
   1096          
   1097           /*********************************************************************
   1098           * @fn          bdb_NetworkRestoredResumeState
   1099           *
   1100           * @brief       Restore the state of child device after parent lost
   1101           *
   1102           * @return      none
   1103           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1104          void bdb_NetworkRestoredResumeState(void)
   \                     bdb_NetworkRestoredResumeState:
   1105          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1106          #if (BDB_FINDING_BINDING_CAPABILITY_ENABLED==1)   
   1107          #if ZG_BUILD_ENDDEVICE_TYPE
   1108            if(ZG_DEVICE_ENDDEVICE_TYPE)
   1109            {
   1110              uint8 restoreSimpleDesc = FALSE;
   1111              //If restored when F&B still enabled, then restore the simple descriptors attempts
   1112              if(bdbCommissioningProcedureState.bdbCommissioningState == BDB_COMMISSIONING_STATE_FINDING_BINDING)
   1113              {
   1114                bdbFindingBindingRespondent_t  *pRespondentTemp = NULL;
   1115                
   1116                pRespondentTemp = pRespondentHead;
   1117                
   1118                while(pRespondentTemp != NULL)
   1119                {
   1120                  if(pRespondentTemp->attempts & FINDING_AND_BINDING_PARENT_LOST)
   1121                  {
   1122                    pRespondentTemp->attempts &= ~FINDING_AND_BINDING_PARENT_LOST;
   1123                    restoreSimpleDesc = TRUE;
   1124                  }
   1125                  pRespondentTemp = pRespondentTemp->pNext;
   1126                }
   1127              }
   1128              if(restoreSimpleDesc)
   1129              {
   1130                //Restore the simple Descriptor sending after 1 second of restoring the network
   1131                osal_start_timerEx(bdb_TaskID,BDB_RESPONDENT_PROCESS_TIMEOUT, 1000);
   1132              }
   1133            }
   1134          #endif
   1135          #endif
   1136          }
   \   000000   02....       LJMP      ?BRET
   1137          
   1138          #if ZG_BUILD_ENDDEVICE_TYPE
   1139           /*********************************************************************
   1140           * @fn          bdb_ZedAttemptRecoverNwk
   1141           *
   1142           * @brief       Instruct the ZED to try to rejoin its previews network
   1143           *
   1144           * @return      success if the attempt is being excecuted
   1145           *              False if device do not have nwk parameters to perform this action
   1146           */
   1147          uint8 bdb_ZedAttemptRecoverNwk(void)
   1148          {
   1149            if(ZG_DEVICE_ENDDEVICE_TYPE)
   1150            {
   1151              if(bdbAttributes.bdbNodeIsOnANetwork)
   1152              {
   1153                if(bdbCommissioningProcedureState.bdbCommissioningState == BDB_PARENT_LOST)
   1154                {
   1155                  if(ZDOInitDevice(0) == ZDO_INITDEV_RESTORED_NETWORK_STATE)
   1156                  {
   1157                    return ZSuccess;
   1158                  }
   1159                }
   1160              }
   1161            }
   1162            return ZFailure;
   1163          }
   1164          
   1165          #endif
   1166          
   1167           /*********************************************************************
   1168           * @fn          bdb_reportCommissioningState
   1169           *
   1170           * @brief       Process the result of a BDB main state attempt.
   1171           *
   1172           * @param       bdbCommissioningState - MainState that is issuing fail
   1173           * @param       didSuccess - TRUE if the main state were success, FALSE otherwise
   1174           *
   1175           * @return      none
   1176           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1177          void bdb_reportCommissioningState(uint8 bdbCommissioningState,bool didSuccess)
   \                     bdb_reportCommissioningState:
   1178          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
   \   00000C   EA           MOV       A,R2
   \   00000D   FF           MOV       R7,A
   1179            bdbCommissioningModeMsg_t bdbCommissioningModeMsg;
   1180            //Process only if we are in that state, or if we are on parent lost and processing F&B
   1181            if((bdbCommissioningProcedureState.bdbCommissioningState == bdbCommissioningState)
   1182               || ((bdbCommissioningProcedureState.bdbCommissioningState == BDB_PARENT_LOST) && (bdbCommissioningProcedureState.bdb_ParentLostSavedState == BDB_COMMISSIONING_STATE_FINDING_BINDING)))
   \   00000E   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   000011   E0           MOVX      A,@DPTR
   \   000012   6E           XRL       A,R6
   \   000013   6013         JZ        ??bdb_reportCommissioningState_0
   \   000015   E0           MOVX      A,@DPTR
   \   000016   6408         XRL       A,#0x8
   \   000018   6003         JZ        $+5
   \   00001A   02....       LJMP      ??bdb_reportCommissioningState_1 & 0xFFFF
   \   00001D   90....       MOV       DPTR,#bdbCommissioningProcedureState + 3
   \   000020   E0           MOVX      A,@DPTR
   \   000021   6406         XRL       A,#0x6
   \   000023   6003         JZ        $+5
   \   000025   02....       LJMP      ??bdb_reportCommissioningState_1 & 0xFFFF
   1183            {
   1184              switch(bdbCommissioningState)
   \                     ??bdb_reportCommissioningState_0:
   \   000028   EE           MOV       A,R6
   \   000029   24FE         ADD       A,#-0x2
   \   00002B   7003         JNZ       $+5
   \   00002D   02....       LJMP      ??bdb_reportCommissioningState_2 & 0xFFFF
   \   000030   24FE         ADD       A,#-0x2
   \   000032   6012         JZ        ??bdb_reportCommissioningState_3
   \   000034   14           DEC       A
   \   000035   6056         JZ        ??bdb_reportCommissioningState_4
   \   000037   14           DEC       A
   \   000038   7003         JNZ       $+5
   \   00003A   02....       LJMP      ??bdb_reportCommissioningState_5 & 0xFFFF
   \   00003D   14           DEC       A
   \   00003E   7003         JNZ       $+5
   \   000040   02....       LJMP      ??bdb_reportCommissioningState_6 & 0xFFFF
   \   000043   02....       LJMP      ??bdb_reportCommissioningState_7 & 0xFFFF
   1185              {
   1186          #if (ZG_BUILD_JOINING_TYPE)
   1187                case BDB_COMMISSIONING_STATE_JOINING:
   1188                  if(ZG_DEVICE_JOINING_TYPE)
   1189                  {
   1190                    //Prepare for the next state or commissioning mode to be excecuted
   1191                    osal_start_timerEx(bdb_TaskID,BDB_CHANGE_COMMISSIONING_STATE,50);
   1192          
   1193                    if(didSuccess)
   1194                    {
   1195                      //Next state is TC link key exchange
   1196                      bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_TC_LINK_KEY_EXCHANGE;
   1197                      //Free the list of nwk discovered
   1198                      while(pBDBListNwk)
   1199                      {
   1200                        bdb_nwkDescFree(pBDBListNwk);
   1201                      }
   1202                      
   1203                      //Set the poll rate of the ZED joining device to 1 second to allow TCLK 
   1204                      //exchange be perfomed successfully in cases in which application has a 
   1205                      //slow pollrate
   1206                      NLME_SetPollRate(TCLK_POLL_RATE);
   1207                      
   1208                      //No notification in this step
   1209                      return;
   1210                    } 
   1211                    else
   1212                    {
   1213                      uint8 temp = FALSE;
   1214                      //If fail, then restore poll rate
   1215                      NLME_SetPollRate(POLL_RATE);
   1216                      bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_NO_NETWORK;
   1217                      bdbCommissioningModeMsg.bdbCommissioningMode = BDB_COMMISSIONING_NWK_STEERING;
   1218                      bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_START_RESUME;
   1219                      bdbAttributes.bdbCommissioningMode &= ~BDB_COMMISSIONING_MODE_NWK_STEERING;
   1220                      
   1221                      //Turn off the radio
   1222                      ZMacSetReq(ZMacRxOnIdle, &temp);
   1223                      //Set the device to FN, to start as new for subsequent attempts
   1224                      bdb_setFN();
   1225                      NLME_ResetRequest();
   1226                      ZDApp_ChangeState( DEV_HOLD );
   1227                      
   1228                      //Free the list of nwk discovered
   1229                      while(pBDBListNwk)
   1230                      {
   1231                        bdb_nwkDescFree(pBDBListNwk);
   1232                      }
   1233                    }
   1234                  }
   1235                break;
   1236          
   1237                case BDB_COMMISSIONING_STATE_TC_LINK_KEY_EXCHANGE:
   1238                  if(ZG_DEVICE_JOINING_TYPE)
   1239                  {
   1240                    if(didSuccess)
   1241                    {
   1242                      //Clear any setting that would set the device as FN
   1243                      zgWriteStartupOptions(ZG_STARTUP_CLEAR, ZCD_STARTOPT_DEFAULT_CONFIG_STATE | ZCD_STARTOPT_DEFAULT_NETWORK_STATE);            
   1244                      
   1245                      //Next state is nwk steering on the nwk (permit joining)
   1246                      bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_STEERING_ON_NWK;
   1247                      osal_start_timerEx(bdb_TaskID,BDB_CHANGE_COMMISSIONING_STATE, 50);
   1248                      
   1249                      //Set the poll rate to the application default after TCLK success
   1250                      NLME_SetPollRate(POLL_RATE);
   1251          
   1252                      osal_stop_timerEx( bdb_TaskID, BDB_PROCESS_TIMEOUT );
   1253                      //No notification to the user is needed
   1254                      return;
   1255                    }
   1256                    else
   1257                    {
   1258                      bdbCommissioningModeMsg.bdbCommissioningMode = BDB_COMMISSIONING_NWK_STEERING;
   1259                      bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_TCLK_EX_FAILURE;
   1260                      
   1261                      osal_stop_timerEx( bdb_TaskID, BDB_PROCESS_TIMEOUT);
   1262                     
   1263                      //No process shall be attempted after this fail
   1264                      bdbAttributes.bdbCommissioningMode = 0;
   1265                      
   1266                      //Fill the context for the user notification
   1267                      osal_start_timerEx(bdb_TaskID,BDB_TC_LINK_KEY_EXCHANGE_FAIL,BDB_TC_LINK_KEY_EXCHANGE_FAIL_LEAVE_TIMEOUT);
   1268                    }
   1269                  }
   1270                break;
   1271          #endif
   1272                
   1273                case BDB_COMMISSIONING_STATE_STEERING_ON_NWK:
   1274                  bdbCommissioningModeMsg.bdbCommissioningMode = BDB_COMMISSIONING_NWK_STEERING;
   \                     ??bdb_reportCommissioningState_3:
   \   000046   7401         MOV       A,#0x1
   \   000048   12....       LCALL     ?XSTACK_DISP0_8
   \   00004B   7401         MOV       A,#0x1
   \   00004D   F0           MOVX      @DPTR,A
   1275                  if(didSuccess)
   \   00004E   EF           MOV       A,R7
   \   00004F   90....       MOV       DPTR,#bdbAttributes + 10
   \   000052   6011         JZ        ??bdb_reportCommissioningState_8
   1276                  {
   1277                    bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_SUCCESS;
   \   000054   E4           CLR       A
   \   000055   F0           MOVX      @DPTR,A
   1278                    
   1279          #if (ZG_BUILD_RTR_TYPE)          
   1280                    //Update ZDApp state
   1281                    if(ZG_DEVICE_RTRONLY_TYPE)
   \   000056   90....       MOV       DPTR,#zgDeviceLogicalType
   \   000059   E0           MOVX      A,@DPTR
   \   00005A   6401         XRL       A,#0x1
   \   00005C   700A         JNZ       ??bdb_reportCommissioningState_9
   1282                    {          
   1283                      ZDApp_ChangeState( DEV_ROUTER );
   \   00005E                ; Setup parameters for call to function ZDApp_ChangeState
   \   00005E   7907         MOV       R1,#0x7
   \   000060   12....       LCALL     `??ZDApp_ChangeState::?relay`; Banked call to: ZDApp_ChangeState
   \   000063   8003         SJMP      ??bdb_reportCommissioningState_9
   1284                    }
   1285          #endif
   1286          #if (ZG_BUILD_ENDDEVICE_TYPE)
   1287                    if(ZG_DEVICE_ENDDEVICE_TYPE)
   1288                    {
   1289                      ZDApp_ChangeState( DEV_END_DEVICE );
   1290                    }
   1291          #endif
   1292                  }
   1293          #if (ZG_BUILD_COORDINATOR_TYPE)
   1294                  else
   1295                  {
   1296                    if(ZG_DEVICE_COORDINATOR_TYPE)
   1297                    {
   1298                      bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_NO_NETWORK;
   \                     ??bdb_reportCommissioningState_8:
   \   000065   7402         MOV       A,#0x2
   \   000067   F0           MOVX      @DPTR,A
   1299                    }
   1300                  }
   1301          #endif
   1302                  
   1303                  bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_START_RESUME;
   \                     ??bdb_reportCommissioningState_9:
   \   000068   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   00006B   E4           CLR       A
   \   00006C   F0           MOVX      @DPTR,A
   1304                  osal_start_timerEx(bdb_TaskID,BDB_CHANGE_COMMISSIONING_STATE,50);
   \   00006D                ; Setup parameters for call to function osal_start_timerEx
   \   00006D   90....       MOV       DPTR,#__Constant_32
   \   000070   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   000073   7A04         MOV       R2,#0x4
   \   000075   7B00         MOV       R3,#0x0
   \   000077   90....       MOV       DPTR,#bdb_TaskID
   \   00007A   E0           MOVX      A,@DPTR
   \   00007B   F9           MOV       R1,A
   \   00007C   12....       LCALL     `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   00007F   7404         MOV       A,#0x4
   \   000081   12....       LCALL     ?DEALLOC_XSTACK8
   1305                  bdbAttributes.bdbCommissioningMode &= ~BDB_COMMISSIONING_MODE_NWK_STEERING;
   \   000084   90....       MOV       DPTR,#bdbAttributes + 11
   \   000087   E0           MOVX      A,@DPTR
   \   000088   C2E1         CLR       0xE0 /* A   */.1
   \   00008A   02....       LJMP      ??bdb_reportCommissioningState_10 & 0xFFFF
   1306                break;
   1307                
   1308                case BDB_COMMISSIONING_STATE_FORMATION:
   1309                  bdbCommissioningModeMsg.bdbCommissioningMode = BDB_COMMISSIONING_FORMATION;
   \                     ??bdb_reportCommissioningState_4:
   \   00008D   7401         MOV       A,#0x1
   \   00008F   12....       LCALL     ?XSTACK_DISP0_8
   \   000092   7402         MOV       A,#0x2
   \   000094   F0           MOVX      @DPTR,A
   1310          
   1311                  if(didSuccess)
   \   000095   EF           MOV       A,R7
   \   000096   90....       MOV       DPTR,#bdbAttributes + 10
   \   000099   6019         JZ        ??bdb_reportCommissioningState_11
   1312                  {
   1313                    bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_SUCCESS;
   \   00009B   E4           CLR       A
   \   00009C   F0           MOVX      @DPTR,A
   1314          
   1315                    //Clear any setting that would set the device as FN
   1316                    zgWriteStartupOptions(ZG_STARTUP_CLEAR, ZCD_STARTOPT_DEFAULT_CONFIG_STATE | ZCD_STARTOPT_DEFAULT_NETWORK_STATE);          
   \   00009D                ; Setup parameters for call to function zgWriteStartupOptions
   \   00009D   7A03         MOV       R2,#0x3
   \   00009F   F9           MOV       R1,A
   \   0000A0   12....       LCALL     `??zgWriteStartupOptions::?relay`; Banked call to: zgWriteStartupOptions
   1317                    
   1318                     //Update ZDApp State
   1319          #if (ZG_BUILD_RTR_TYPE)
   1320                    if(ZG_DEVICE_RTRONLY_TYPE)
   \   0000A3   90....       MOV       DPTR,#zgDeviceLogicalType
   \   0000A6   E0           MOVX      A,@DPTR
   \   0000A7   6401         XRL       A,#0x1
   \   0000A9   7005         JNZ       ??bdb_reportCommissioningState_12
   1321                    {          
   1322                      ZDApp_ChangeState( DEV_ROUTER );
   \   0000AB                ; Setup parameters for call to function ZDApp_ChangeState
   \   0000AB   7907         MOV       R1,#0x7
   \   0000AD   12....       LCALL     `??ZDApp_ChangeState::?relay`; Banked call to: ZDApp_ChangeState
   1323                    }
   1324          #endif    
   1325          #if (ZG_BUILD_COORDINATOR_TYPE)
   1326                    if(ZG_DEVICE_COORDINATOR_TYPE)
   1327                    {          
   1328                      ZDApp_ChangeState( DEV_ZB_COORD );
   \                     ??bdb_reportCommissioningState_12:
   \   0000B0                ; Setup parameters for call to function ZDApp_ChangeState
   \   0000B0   7909         MOV       R1,#0x9
   \   0000B2   802C         SJMP      ??bdb_reportCommissioningState_13
   1329                    }     
   1330          #endif
   1331                  }
   1332                  else
   1333                  {
   1334                    bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_FORMATION_FAILURE;
   \                     ??bdb_reportCommissioningState_11:
   \   0000B4   7408         MOV       A,#0x8
   \   0000B6   F0           MOVX      @DPTR,A
   1335                    //If not on the nwk, then restart the nwk parameters
   1336          #if (ZG_BUILD_RTR_TYPE)
   1337                    if(ZG_DEVICE_RTR_TYPE)
   \   0000B7   90....       MOV       DPTR,#zgDeviceLogicalType
   \   0000BA   E0           MOVX      A,@DPTR
   \   0000BB   6004         JZ        ??bdb_reportCommissioningState_14
   \   0000BD   6401         XRL       A,#0x1
   \   0000BF   7022         JNZ       ??bdb_reportCommissioningState_15
   1338                    {           
   1339                      if(!bdbAttributes.bdbNodeIsOnANetwork)
   \                     ??bdb_reportCommissioningState_14:
   \   0000C1   90....       MOV       DPTR,#bdbAttributes + 14
   \   0000C4   E0           MOVX      A,@DPTR
   \   0000C5   701C         JNZ       ??bdb_reportCommissioningState_15
   1340                      {
   1341                        uint8 temp = FALSE;
   \   0000C7   7403         MOV       A,#0x3
   \   0000C9   12....       LCALL     ?XSTACK_DISP0_8
   \   0000CC   E4           CLR       A
   \   0000CD   F0           MOVX      @DPTR,A
   1342                        //Turn off the radio
   1343                        ZMacSetReq(ZMacRxOnIdle, &temp);
   \   0000CE                ; Setup parameters for call to function ZMacSetReq
   \   0000CE   7403         MOV       A,#0x3
   \   0000D0   12....       LCALL     ?XSTACK_DISP101_8
   \   0000D3   7952         MOV       R1,#0x52
   \   0000D5   12....       LCALL     `??ZMacSetReq::?relay`; Banked call to: ZMacSetReq
   1344                        //Set the device to FN, to start as new for subsequent attempts
   1345                        bdb_setFN();
   \   0000D8                ; Setup parameters for call to function bdb_setFN
   \   0000D8   12....       LCALL     `??bdb_setFN::?relay`; Banked call to: bdb_setFN
   1346                        NLME_ResetRequest();
   \   0000DB                ; Setup parameters for call to function NLME_ResetRequest
   \   0000DB   12....       LCALL     `??NLME_ResetRequest::?relay`; Banked call to: NLME_ResetRequest
   1347                        ZDApp_ChangeState( DEV_HOLD );
   \   0000DE                ; Setup parameters for call to function ZDApp_ChangeState
   \   0000DE   7900         MOV       R1,#0x0
   \                     ??bdb_reportCommissioningState_13:
   \   0000E0   12....       LCALL     `??ZDApp_ChangeState::?relay`; Banked call to: ZDApp_ChangeState
   1348                      }
   1349                    }
   1350          #endif
   1351                  }
   1352                  bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_START_RESUME;
   \                     ??bdb_reportCommissioningState_15:
   \   0000E3   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   0000E6   E4           CLR       A
   \   0000E7   F0           MOVX      @DPTR,A
   1353                  osal_start_timerEx(bdb_TaskID,BDB_CHANGE_COMMISSIONING_STATE,50);
   \   0000E8                ; Setup parameters for call to function osal_start_timerEx
   \   0000E8   90....       MOV       DPTR,#__Constant_32
   \   0000EB   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   0000EE   7A04         MOV       R2,#0x4
   \   0000F0   7B00         MOV       R3,#0x0
   \   0000F2   90....       MOV       DPTR,#bdb_TaskID
   \   0000F5   E0           MOVX      A,@DPTR
   \   0000F6   F9           MOV       R1,A
   \   0000F7   12....       LCALL     `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   0000FA   7404         MOV       A,#0x4
   \   0000FC   12....       LCALL     ?DEALLOC_XSTACK8
   1354                  bdbAttributes.bdbCommissioningMode &= ~BDB_COMMISSIONING_MODE_NWK_FORMATION;
   \   0000FF   90....       MOV       DPTR,#bdbAttributes + 11
   \   000102   E0           MOVX      A,@DPTR
   \   000103   C2E2         CLR       0xE0 /* A   */.2
   \   000105   02....       LJMP      ??bdb_reportCommissioningState_10 & 0xFFFF
   1355                break;  
   1356                
   1357          
   1358                case BDB_COMMISSIONING_STATE_FINDING_BINDING:
   1359          #if (BDB_FINDING_BINDING_CAPABILITY_ENABLED==1) 
   1360                  bdbCommissioningModeMsg.bdbCommissioningMode = BDB_COMMISSIONING_FINDING_BINDING;
   \                     ??bdb_reportCommissioningState_5:
   \   000108   7401         MOV       A,#0x1
   \   00010A   12....       LCALL     ?XSTACK_DISP0_8
   \   00010D   7403         MOV       A,#0x3
   \   00010F   F0           MOVX      @DPTR,A
   1361          
   1362                  //Do not notify the status if we have another identify to send
   1363                  if(bdbAttributes.bdbCommissioningStatus == BDB_COMMISSIONING_SUCCESS)
   \   000110   90....       MOV       DPTR,#bdbAttributes + 10
   \   000113   E0           MOVX      A,@DPTR
   \   000114   7006         JNZ       ??bdb_reportCommissioningState_16
   1364                  {
   1365                    //Success at least once during F&B as initiator, mark it
   1366                    bdb_FBStateSuccessLatch = TRUE;
   \   000116   90....       MOV       DPTR,#bdb_FBStateSuccessLatch
   \   000119   7401         MOV       A,#0x1
   \   00011B   F0           MOVX      @DPTR,A
   1367                  }        
   1368                  
   1369                  //Will we process another indentify?
   1370                  if(((FINDING_AND_BINDING_PERIODIC_ENABLE == FALSE) || (bdb_FB_InitiatorCurrentCyclesNumber == 0)) && (bdb_getRespondentRetry(pRespondentHead) == NULL) && (osal_get_timeoutEx( bdb_TaskID, BDB_RESPONDENT_PROCESS_TIMEOUT) == 0))
   \                     ??bdb_reportCommissioningState_16:
   \   00011C   90....       MOV       DPTR,#bdb_FB_InitiatorCurrentCyclesNumber
   \   00011F   E0           MOVX      A,@DPTR
   \   000120   6003         JZ        $+5
   \   000122   02....       LJMP      ??bdb_reportCommissioningState_1 & 0xFFFF
   \   000125                ; Setup parameters for call to function bdb_getRespondentRetry
   \   000125   12....       LCALL     ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_96:
   \   000128   12....       LCALL     `??bdb_getRespondentRetry::?relay`; Banked call to: bdb_getRespondentRetry
   \   00012B   8B..         MOV       ?V1,R3
   \   00012D   EA           MOV       A,R2
   \   00012E   45..         ORL       A,?V1
   \   000130   6003         JZ        $+5
   \   000132   02....       LJMP      ??bdb_reportCommissioningState_1 & 0xFFFF
   \   000135                ; Setup parameters for call to function osal_get_timeoutEx
   \   000135   7A00         MOV       R2,#0x0
   \   000137   7B40         MOV       R3,#0x40
   \   000139   90....       MOV       DPTR,#bdb_TaskID
   \   00013C   E0           MOVX      A,@DPTR
   \   00013D   F9           MOV       R1,A
   \   00013E   12....       LCALL     `??osal_get_timeoutEx::?relay`; Banked call to: osal_get_timeoutEx
   \   000141   EA           MOV       A,R2
   \   000142   4B           ORL       A,R3
   \   000143   4C           ORL       A,R4
   \   000144   4D           ORL       A,R5
   \   000145   6003         JZ        $+5
   \   000147   02....       LJMP      ??bdb_reportCommissioningState_1 & 0xFFFF
   1371                  {
   1372                    // Dealocate respondent list and clean all the F&B process
   1373                    pRespondentCurr = NULL;
   \   00014A   90....       MOV       DPTR,#pRespondentCurr
   \   00014D   E4           CLR       A
   \   00014E   F0           MOVX      @DPTR,A
   \   00014F   A3           INC       DPTR
   \   000150   F0           MOVX      @DPTR,A
   1374                    pRespondentNext = NULL;
   \   000151   90....       MOV       DPTR,#pRespondentNext
   \   000154   F0           MOVX      @DPTR,A
   \   000155   A3           INC       DPTR
   \   000156   F0           MOVX      @DPTR,A
   1375                    bdb_zclRespondentListClean( &pRespondentHead );
   \   000157                ; Setup parameters for call to function bdb_zclRespondentListClean
   \   000157   7A..         MOV       R2,#pRespondentHead & 0xff
   \   000159   7B..         MOV       R3,#(pRespondentHead >> 8) & 0xff
   \   00015B   12....       LCALL     `??bdb_zclRespondentListClean::?relay`; Banked call to: bdb_zclRespondentListClean
   1376                    osal_stop_timerEx( bdb_TaskID, BDB_RESPONDENT_PROCESS_TIMEOUT );
   \   00015E                ; Setup parameters for call to function osal_stop_timerEx
   \   00015E   7A00         MOV       R2,#0x0
   \   000160   7B40         MOV       R3,#0x40
   \   000162   90....       MOV       DPTR,#bdb_TaskID
   \   000165   E0           MOVX      A,@DPTR
   \   000166   F9           MOV       R1,A
   \   000167   12....       LCALL     `??osal_stop_timerEx::?relay`; Banked call to: osal_stop_timerEx
   1377                    
   1378                    //Report success if in any of the attempts we got success, regardless that we did receive no rsp on the last attempt
   1379                    if(bdb_FBStateSuccessLatch && (bdbAttributes.bdbCommissioningStatus == BDB_COMMISSIONING_FB_NO_IDENTIFY_QUERY_RESPONSE))
   \   00016A   90....       MOV       DPTR,#bdb_FBStateSuccessLatch
   \   00016D   E0           MOVX      A,@DPTR
   \   00016E   600A         JZ        ??bdb_reportCommissioningState_17
   \   000170   90....       MOV       DPTR,#bdbAttributes + 10
   \   000173   E0           MOVX      A,@DPTR
   \   000174   640B         XRL       A,#0xb
   \   000176   7002         JNZ       ??bdb_reportCommissioningState_17
   1380                    {
   1381                      bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_SUCCESS;
   \   000178   E4           CLR       A
   \   000179   F0           MOVX      @DPTR,A
   1382                    }
   1383                    
   1384                    //Set default state
   1385                    bdb_FBStateSuccessLatch = FALSE;
   \                     ??bdb_reportCommissioningState_17:
   \   00017A   90....       MOV       DPTR,#bdb_FBStateSuccessLatch
   \   00017D   E4           CLR       A
   \   00017E   F0           MOVX      @DPTR,A
   1386                    
   1387                    //Resume BDB machine state only if we were in F&B, if we were on parent lost, only clean the commissioning mode and remove from bdb_ParentLostSavedState
   1388                    if(bdbCommissioningProcedureState.bdbCommissioningState == BDB_COMMISSIONING_STATE_FINDING_BINDING)
   \   00017F   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   000182   E0           MOVX      A,@DPTR
   \   000183   6406         XRL       A,#0x6
   \   000185   701B         JNZ       ??bdb_reportCommissioningState_18
   1389                    {
   1390                      bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_START_RESUME;
   \   000187   E4           CLR       A
   \   000188   F0           MOVX      @DPTR,A
   1391                      osal_start_timerEx(bdb_TaskID,BDB_CHANGE_COMMISSIONING_STATE,50); 
   \   000189                ; Setup parameters for call to function osal_start_timerEx
   \   000189   90....       MOV       DPTR,#__Constant_32
   \   00018C   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   00018F   7A04         MOV       R2,#0x4
   \   000191   7B00         MOV       R3,#0x0
   \   000193   90....       MOV       DPTR,#bdb_TaskID
   \   000196   E0           MOVX      A,@DPTR
   \   000197   F9           MOV       R1,A
   \   000198   12....       LCALL     `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   00019B   7404         MOV       A,#0x4
   \   00019D   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001A0   800A         SJMP      ??bdb_reportCommissioningState_19
   1392                    }
   1393                    else if(bdbCommissioningProcedureState.bdb_ParentLostSavedState == BDB_COMMISSIONING_STATE_FINDING_BINDING)
   \                     ??bdb_reportCommissioningState_18:
   \   0001A2   90....       MOV       DPTR,#bdbCommissioningProcedureState + 3
   \   0001A5   E0           MOVX      A,@DPTR
   \   0001A6   6406         XRL       A,#0x6
   \   0001A8   7002         JNZ       ??bdb_reportCommissioningState_19
   1394                    {
   1395                      bdbCommissioningProcedureState.bdb_ParentLostSavedState = BDB_COMMISSIONING_STATE_START_RESUME;
   \   0001AA   E4           CLR       A
   \   0001AB   F0           MOVX      @DPTR,A
   1396                    }
   1397                    
   1398                    bdbAttributes.bdbCommissioningMode &= ~BDB_COMMISSIONING_MODE_FINDING_BINDING;
   \                     ??bdb_reportCommissioningState_19:
   \   0001AC   90....       MOV       DPTR,#bdbAttributes + 11
   \   0001AF   E0           MOVX      A,@DPTR
   \   0001B0   C2E3         CLR       0xE0 /* A   */.3
   \   0001B2   02....       LJMP      ??bdb_reportCommissioningState_10 & 0xFFFF
   1399                  }
   1400                  else
   1401                  {
   1402                    return;
   1403                  }
   1404          
   1405          #endif
   1406                break;     
   1407                case BDB_COMMISSIONING_STATE_TL:
   1408                  // Set NWK task to run
   1409                  nwk_setStateIdle( FALSE );
   \                     ??bdb_reportCommissioningState_2:
   \   0001B5                ; Setup parameters for call to function nwk_setStateIdle
   \   0001B5   7900         MOV       R1,#0x0
   \   0001B7   12....       LCALL     `??nwk_setStateIdle::?relay`; Banked call to: nwk_setStateIdle
   1410                  bdbCommissioningModeMsg.bdbCommissioningMode = BDB_COMMISSIONING_TOUCHLINK;
   \   0001BA   7401         MOV       A,#0x1
   \   0001BC   12....       LCALL     ?XSTACK_DISP0_8
   \   0001BF   7404         MOV       A,#0x4
   \   0001C1   F0           MOVX      @DPTR,A
   1411                  if(didSuccess)
   \   0001C2   EF           MOV       A,R7
   \   0001C3   6014         JZ        ??bdb_reportCommissioningState_20
   1412                  {
   1413                    bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_SUCCESS;
   \   0001C5   90....       MOV       DPTR,#bdbAttributes + 10
   \   0001C8   E4           CLR       A
   \   0001C9   F0           MOVX      @DPTR,A
   1414                    bdbAttributes.bdbCommissioningMode = BDB_COMMISSIONING_MODE_IDDLE;
   \   0001CA   A3           INC       DPTR
   \   0001CB   F0           MOVX      @DPTR,A
   1415                    
   1416                    //Update ZDApp state
   1417          #if (ZG_BUILD_RTR_TYPE)
   1418                    if(ZG_DEVICE_RTRONLY_TYPE)
   \   0001CC   90....       MOV       DPTR,#zgDeviceLogicalType
   \   0001CF   E0           MOVX      A,@DPTR
   \   0001D0   6401         XRL       A,#0x1
   \   0001D2   7005         JNZ       ??bdb_reportCommissioningState_20
   1419                    {          
   1420                      ZDApp_ChangeState( DEV_ROUTER );
   \   0001D4                ; Setup parameters for call to function ZDApp_ChangeState
   \   0001D4   7907         MOV       R1,#0x7
   \   0001D6   12....       LCALL     `??ZDApp_ChangeState::?relay`; Banked call to: ZDApp_ChangeState
   1421                    }
   1422          #endif
   1423          #if (ZG_BUILD_ENDDEVICE_TYPE)
   1424                    if(ZG_DEVICE_ENDDEVICE_TYPE)
   1425                    {
   1426                      ZDApp_ChangeState( DEV_END_DEVICE );
   1427                    }
   1428          #endif          
   1429                  }
   1430                  //The fail status is already set from the calling function to report commissioning process
   1431                  
   1432                  // The commissioning FAIL status is set before calling the bdb_reportCommissioningState
   1433                  bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_START_RESUME;
   \                     ??bdb_reportCommissioningState_20:
   \   0001D9   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   0001DC   E4           CLR       A
   \   0001DD   F0           MOVX      @DPTR,A
   1434                  osal_start_timerEx(bdb_TaskID,BDB_CHANGE_COMMISSIONING_STATE,50); 
   \   0001DE                ; Setup parameters for call to function osal_start_timerEx
   \   0001DE   90....       MOV       DPTR,#__Constant_32
   \   0001E1   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   0001E4   7A04         MOV       R2,#0x4
   \   0001E6   7B00         MOV       R3,#0x0
   \   0001E8   90....       MOV       DPTR,#bdb_TaskID
   \   0001EB   E0           MOVX      A,@DPTR
   \   0001EC   F9           MOV       R1,A
   \   0001ED   12....       LCALL     `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   0001F0   7404         MOV       A,#0x4
   \   0001F2   12....       LCALL     ?DEALLOC_XSTACK8
   1435                  //Clear the event
   1436                  bdbAttributes.bdbCommissioningMode &= ~BDB_COMMISSIONING_MODE_INITIATOR_TL;
   \   0001F5   90....       MOV       DPTR,#bdbAttributes + 11
   \   0001F8   E0           MOVX      A,@DPTR
   \   0001F9   C2E0         CLR       0xE0 /* A   */.0
   \   0001FB   8042         SJMP      ??bdb_reportCommissioningState_10
   1437                  
   1438                break;
   1439                
   1440                case BDB_INITIALIZATION:
   1441                  //Notify user about successfull initialization
   1442                  bdbCommissioningModeMsg.bdbCommissioningMode = BDB_COMMISSIONING_INITIALIZATION;
   \                     ??bdb_reportCommissioningState_6:
   \   0001FD   7401         MOV       A,#0x1
   \   0001FF   12....       LCALL     ?XSTACK_DISP0_8
   \   000202   E4           CLR       A
   \   000203   F0           MOVX      @DPTR,A
   1443                  if(didSuccess)
   \   000204   EF           MOV       A,R7
   \   000205   602C         JZ        ??bdb_reportCommissioningState_21
   1444                  {
   1445                    //Update ZDApp state
   1446          #if (ZG_BUILD_COORDINATOR_TYPE)
   1447                    if(ZG_DEVICE_COORDINATOR_TYPE)
   1448                    {          
   1449                      ZDApp_ChangeState( DEV_ZB_COORD );
   \   000207                ; Setup parameters for call to function ZDApp_ChangeState
   \   000207   7909         MOV       R1,#0x9
   \   000209   12....       LCALL     `??ZDApp_ChangeState::?relay`; Banked call to: ZDApp_ChangeState
   1450                    }
   1451          #endif          
   1452          #if (ZG_BUILD_ENDDEVICE_TYPE)
   1453                    if(ZG_DEVICE_ENDDEVICE_TYPE)
   1454                    {
   1455                      uint32 pollrate = POLL_RATE;
   1456                      NLME_SetPollRate(pollrate);
   1457                      ZDApp_ChangeState( DEV_END_DEVICE );
   1458                      
   1459                    }
   1460          #endif          
   1461                    ZDApp_RestoreNwkSecMaterial();
   \   00020C                ; Setup parameters for call to function ZDApp_RestoreNwkSecMaterial
   \   00020C   12....       LCALL     `??ZDApp_RestoreNwkSecMaterial::?relay`; Banked call to: ZDApp_RestoreNwkSecMaterial
   1462                    bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_NETWORK_RESTORED;
   \   00020F   90....       MOV       DPTR,#bdbAttributes + 10
   \   000212   740D         MOV       A,#0xd
   \   000214   F0           MOVX      @DPTR,A
   1463                    bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_START_RESUME;
   \   000215   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   000218   E4           CLR       A
   \   000219   F0           MOVX      @DPTR,A
   1464                    osal_start_timerEx(bdb_TaskID,BDB_CHANGE_COMMISSIONING_STATE,200);
   \   00021A                ; Setup parameters for call to function osal_start_timerEx
   \   00021A   90....       MOV       DPTR,#__Constant_c8
   \   00021D   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   000220   7A04         MOV       R2,#0x4
   \   000222   7B00         MOV       R3,#0x0
   \   000224   90....       MOV       DPTR,#bdb_TaskID
   \   000227   E0           MOVX      A,@DPTR
   \   000228   F9           MOV       R1,A
   \   000229   12....       LCALL     `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   00022C   7404         MOV       A,#0x4
   \   00022E   12....       LCALL     ?DEALLOC_XSTACK8
   \   000231   8006         SJMP      ??bdb_reportCommissioningState_22
   1465                  }
   1466                  else
   1467                  {
   1468          #if (ZG_BUILD_ENDDEVICE_TYPE)                   
   1469                    if(ZG_DEVICE_ENDDEVICE_TYPE)
   1470                    {
   1471                      if(bdb_isDeviceNonFactoryNew())
   1472                      {
   1473                        //Notify the user about losing parent
   1474                        bdbCommissioningModeMsg.bdbCommissioningMode = BDB_COMMISSIONING_PARENT_LOST;
   1475                        bdbAttributes.bdbCommissioningMode |= BDB_COMMISSIONING_MODE_PARENT_LOST;
   1476                        
   1477                        //Update ZDApp state
   1478                        ZDApp_ChangeState( DEV_NWK_ORPHAN );
   1479                      }
   1480                    }
   1481          #endif
   1482                    bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_NO_NETWORK;
   \                     ??bdb_reportCommissioningState_21:
   \   000233   90....       MOV       DPTR,#bdbAttributes + 10
   \   000236   7402         MOV       A,#0x2
   \   000238   F0           MOVX      @DPTR,A
   1483                  }
   1484                  bdbAttributes.bdbCommissioningMode &= ~BDB_COMMISSIONING_MODE_INITIALIZATION;
   \                     ??bdb_reportCommissioningState_22:
   \   000239   90....       MOV       DPTR,#bdbAttributes + 11
   \   00023C   E0           MOVX      A,@DPTR
   \   00023D   C2E4         CLR       0xE0 /* A   */.4
   \                     ??bdb_reportCommissioningState_10:
   \   00023F   F0           MOVX      @DPTR,A
   1485          
   1486                break;
   1487          #if (ZG_BUILD_ENDDEVICE_TYPE)     
   1488                case BDB_PARENT_LOST:
   1489                  bdbCommissioningModeMsg.bdbCommissioningMode = BDB_COMMISSIONING_PARENT_LOST;
   1490                  if(ZG_DEVICE_ENDDEVICE_TYPE)
   1491                  {
   1492                    if(didSuccess)
   1493                    {
   1494                      uint32 pollrate = POLL_RATE;
   1495                      bdbCommissioningProcedureState.bdbCommissioningState = bdbCommissioningProcedureState.bdb_ParentLostSavedState;  
   1496                      bdbCommissioningProcedureState.bdb_ParentLostSavedState = 0;
   1497                      NLME_SetPollRate(pollrate);
   1498                      bdbAttributes.bdbCommissioningMode &= ~BDB_COMMISSIONING_MODE_PARENT_LOST;
   1499                      bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_NETWORK_RESTORED;
   1500                      //Update ZDApp state
   1501                      ZDApp_ChangeState( DEV_END_DEVICE );
   1502                      
   1503                      bdb_NetworkRestoredResumeState();
   1504                    }
   1505                    else
   1506                    {
   1507                      bdbAttributes.bdbCommissioningMode |= BDB_COMMISSIONING_MODE_PARENT_LOST;
   1508                      bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_NO_NETWORK;
   1509                    }
   1510                  }
   1511                break;
   1512          #endif
   1513              }
   1514          #ifdef MT_APP_CNF_FUNC
   1515              //Notify the user about the status, the main state which has failed
   1516              bdbCommissioningModeMsg.bdbCommissioningStatus = bdbAttributes.bdbCommissioningStatus;
   1517              
   1518              bdb_NotifyApp((uint8*)&bdbCommissioningModeMsg);
   1519          #else
   1520              if(pfnCommissioningStatusCB)
   \                     ??bdb_reportCommissioningState_7:
   \   000240   90....       MOV       DPTR,#pfnCommissioningStatusCB
   \   000243   12....       LCALL     ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_61:
   \   000246   6023         JZ        ??bdb_reportCommissioningState_1
   1521              {
   1522                //Notify the user about the status, the main state which has failed
   1523                bdbCommissioningModeMsg.bdbCommissioningStatus = bdbAttributes.bdbCommissioningStatus;
   \   000248   90....       MOV       DPTR,#bdbAttributes + 10
   \   00024B   E0           MOVX      A,@DPTR
   \   00024C   85..82       MOV       DPL,?XSP + 0
   \   00024F   85..83       MOV       DPH,?XSP + 1
   \   000252   12....       LCALL     ?Subroutine9 & 0xFFFF
   1524                
   1525                bdb_NotifyApp((uint8*)&bdbCommissioningModeMsg);
   1526              }
   1527          #endif
   1528            }  
   \                     ??CrossCallReturnLabel_1:
   \   000255   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000258   7C03         MOV       R4,#0x3
   \   00025A   7B00         MOV       R3,#0x0
   \   00025C   7A0A         MOV       R2,#0xa
   \   00025E   90....       MOV       DPTR,#bdb_TaskID
   \   000261   E0           MOVX      A,@DPTR
   \   000262   F9           MOV       R1,A
   \   000263   12....       LCALL     `??bdb_SendMsg::?relay`; Banked call to: bdb_SendMsg
   \   000266   7402         MOV       A,#0x2
   \   000268   12....       LCALL     ?DEALLOC_XSTACK8
   1529          }
   \                     ??bdb_reportCommissioningState_1:
   \   00026B   7404         MOV       A,#0x4
   \   00026D   02....       LJMP      ?Subroutine1 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   90....       MOV       DPTR,#pRespondentHead
   \   000003                REQUIRE ??Subroutine51_0
   \   000003                ; // Fall through to label ??Subroutine51_0
   1530          
   1531          
   1532           /*********************************************************************
   1533           * @fn          bdb_nwkFormationAttempt
   1534           *
   1535           * @brief       Process a nwk formation attempt.
   1536           *
   1537           * @param       didSuccess - TRUE if the nwk formation was success, FALSE 
   1538           *                         otherwise and try secondary channel
   1539           *
   1540           * @return      none
   1541           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1542          void bdb_nwkFormationAttempt(bool didSuccess)
   \                     bdb_nwkFormationAttempt:
   1543          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   1544            if(didSuccess)
   \   000006   6004         JZ        ??bdb_nwkFormationAttempt_0
   1545            {
   1546              bdb_reportCommissioningState(BDB_COMMISSIONING_STATE_FORMATION,TRUE);
   \   000008                ; Setup parameters for call to function bdb_reportCommissioningState
   \   000008   7A01         MOV       R2,#0x1
   \   00000A   801F         SJMP      ??bdb_nwkFormationAttempt_1
   1547            }
   1548            else
   1549            {
   1550              //Can we try the secondary channel set?
   1551              if((vDoPrimaryScan) && (bdbAttributes.bdbSecondaryChannelSet))
   \                     ??bdb_nwkFormationAttempt_0:
   \   00000C   90....       MOV       DPTR,#vDoPrimaryScan
   \   00000F   E0           MOVX      A,@DPTR
   \   000010   6017         JZ        ??bdb_nwkFormationAttempt_2
   \   000012   90....       MOV       DPTR,#bdbAttributes
   \   000015   12....       LCALL     ?XLOAD_R0123
   \   000018   E8           MOV       A,R0
   \   000019   49           ORL       A,R1
   \   00001A   4A           ORL       A,R2
   \   00001B   4B           ORL       A,R3
   \   00001C   600B         JZ        ??bdb_nwkFormationAttempt_2
   1552              {
   1553                vDoPrimaryScan = FALSE;
   \   00001E   90....       MOV       DPTR,#vDoPrimaryScan
   \   000021   E4           CLR       A
   \   000022   F0           MOVX      @DPTR,A
   1554                bdb_nwkJoiningFormation(FALSE);
   \   000023                ; Setup parameters for call to function bdb_nwkJoiningFormation
   \   000023   F9           MOV       R1,A
   \   000024   12....       LCALL     `??bdb_nwkJoiningFormation::?relay`; Banked call to: bdb_nwkJoiningFormation
   \   000027   8007         SJMP      ??bdb_nwkFormationAttempt_3
   1555              }
   1556              else
   1557              {
   1558                bdb_reportCommissioningState(BDB_COMMISSIONING_STATE_FORMATION, FALSE);
   \                     ??bdb_nwkFormationAttempt_2:
   \   000029                ; Setup parameters for call to function bdb_reportCommissioningState
   \   000029   7A00         MOV       R2,#0x0
   \                     ??bdb_nwkFormationAttempt_1:
   \   00002B   7905         MOV       R1,#0x5
   \   00002D   12....       LCALL     `??bdb_reportCommissioningState::?relay`; Banked call to: bdb_reportCommissioningState
   1559              }
   1560            }
   1561          }
   \                     ??bdb_nwkFormationAttempt_3:
   \   000030   02....       LJMP      ?Subroutine0 & 0xFFFF
   1562          
   1563          
   1564          
   1565          /*********************************************************************
   1566           * @fn          bdb_isDeviceNonFactoryNew
   1567           *
   1568           * @brief       Returns the state of bdbNodeIsOnANetwork attribute
   1569           * 
   1570           * @param       none
   1571           *
   1572           * @return      bdbNodeIsOnANetwork
   1573           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1574          bool bdb_isDeviceNonFactoryNew(void)
   \                     bdb_isDeviceNonFactoryNew:
   1575          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1576            return bdbAttributes.bdbNodeIsOnANetwork;
   \   000004   90....       MOV       DPTR,#bdbAttributes + 14
   \   000007                REQUIRE ?Subroutine8
   \   000007                ; // Fall through to label ?Subroutine8
   1577          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   E0           MOVX      A,@DPTR
   \   000001                REQUIRE ??Subroutine41_0
   \   000001                ; // Fall through to label ??Subroutine41_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine41_0:
   \   000000   F9           MOV       R1,A
   \   000001   02....       LJMP      ??Subroutine40_0 & 0xFFFF
   1578          
   1579          
   1580          /*********************************************************************
   1581           * @fn          bdb_doTrustCenterRequireKeyExchange
   1582           *
   1583           * @brief       Returns the state of bdbTrustCenterRequireKeyExchange attribute
   1584           * 
   1585           * @param       none
   1586           *
   1587           * @return      bdbTrustCenterRequireKeyExchange
   1588           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1589          bool bdb_doTrustCenterRequireKeyExchange(void)
   \                     bdb_doTrustCenterRequireKeyExchange:
   1590          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1591          #if (ZG_BUILD_COORDINATOR_TYPE) 
   1592            return bdbAttributes.bdbTrustCenterRequireKeyExchange;
   \   000004   90....       MOV       DPTR,#bdbAttributes + 17
   \   000007   80..         SJMP      ?Subroutine8
   1593          #else
   1594            return 0;
   1595          #endif
   1596          }
   1597          
   1598          /*********************************************************************
   1599           * @fn      bdb_rejoinNwk
   1600           *
   1601           * @brief   Attempt to rejoin/resume a nwk from nv parameters
   1602           *
   1603           * @param   none
   1604           *
   1605           * @return  ZStatus_t
   1606           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1607          ZStatus_t bdb_rejoinNwk(void)
   \                     bdb_rejoinNwk:
   1608          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV       A,#-0x1
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   1609            ZStatus_t rejoinStatus = ZSuccess;
   \   00000A   7E00         MOV       R6,#0x0
   1610            
   1611            // Transition state machine to correct rejoin state based on nwk key
   1612            if ( ZDApp_RestoreNwkKey( FALSE )== TRUE )
   \   00000C                ; Setup parameters for call to function ZDApp_RestoreNwkKey
   \   00000C   7900         MOV       R1,#0x0
   \   00000E   12....       LCALL     `??ZDApp_RestoreNwkKey::?relay`; Banked call to: ZDApp_RestoreNwkKey
   \   000011   E9           MOV       A,R1
   \   000012   6401         XRL       A,#0x1
   \   000014   7004         JNZ       ??bdb_rejoinNwk_0
   1613            {
   1614              ZDApp_ChangeState( DEV_NWK_SEC_REJOIN_CURR_CHANNEL );
   \   000016                ; Setup parameters for call to function ZDApp_ChangeState
   \   000016   7904         MOV       R1,#0x4
   \   000018   8002         SJMP      ??bdb_rejoinNwk_1
   1615            }
   1616            else
   1617            {
   1618              ZDApp_ChangeState( DEV_NWK_TC_REJOIN_CURR_CHANNEL );
   \                     ??bdb_rejoinNwk_0:
   \   00001A                ; Setup parameters for call to function ZDApp_ChangeState
   \   00001A   790E         MOV       R1,#0xe
   \                     ??bdb_rejoinNwk_1:
   \   00001C   12....       LCALL     `??ZDApp_ChangeState::?relay`; Banked call to: ZDApp_ChangeState
   1619            }
   1620          
   1621            // Before trying to do rejoin, check if the device has a valid short address
   1622            // If not, generate a random short address for itself
   1623            if ( _NIB.nwkDevAddress == INVALID_NODE_ADDR )
   \   00001F   90....       MOV       DPTR,#_NIB + 20
   \   000022   E0           MOVX      A,@DPTR
   \   000023   64FE         XRL       A,#0xfe
   \   000025   7003         JNZ       ??bdb_rejoinNwk_2
   \   000027   A3           INC       DPTR
   \   000028   E0           MOVX      A,@DPTR
   \   000029   F4           CPL       A
   \                     ??bdb_rejoinNwk_2:
   \   00002A   7002         JNZ       ??bdb_rejoinNwk_3
   1624            {
   1625              rejoinStatus = ZFailure;
   \   00002C   7E01         MOV       R6,#0x1
   1626            }
   1627          
   1628            // Check if the device has a valid PanID, if not, set it to the discovered Pan
   1629            if ( _NIB.nwkPanId == 0xFFFF )
   \                     ??bdb_rejoinNwk_3:
   \   00002E   90....       MOV       DPTR,#_NIB + 33
   \   000031   E0           MOVX      A,@DPTR
   \   000032   F4           CPL       A
   \   000033   7003         JNZ       ??bdb_rejoinNwk_4
   \   000035   A3           INC       DPTR
   \   000036   E0           MOVX      A,@DPTR
   \   000037   F4           CPL       A
   \                     ??bdb_rejoinNwk_4:
   \   000038   7004         JNZ       ??bdb_rejoinNwk_5
   1630            {
   1631              rejoinStatus = ZFailure;
   \   00003A   7E01         MOV       R6,#0x1
   \   00003C   803A         SJMP      ??bdb_rejoinNwk_6
   1632            }
   1633          
   1634            if(rejoinStatus == ZSuccess)
   \                     ??bdb_rejoinNwk_5:
   \   00003E   EE           MOV       A,R6
   \   00003F   A2E0         MOV       C,0xE0 /* A   */.0
   \   000041   4035         JC        ??bdb_rejoinNwk_6
   1635            {
   1636              uint8 tmp = true;
   \   000043   85..82       MOV       DPL,?XSP + 0
   \   000046   85..83       MOV       DPH,?XSP + 1
   \   000049   7401         MOV       A,#0x1
   \   00004B   F0           MOVX      @DPTR,A
   1637              ZMacSetReq( ZMacRxOnIdle, &tmp ); // Set receiver always on during rejoin
   \   00004C                ; Setup parameters for call to function ZMacSetReq
   \   00004C   AA..         MOV       R2,?XSP + 0
   \   00004E   AB..         MOV       R3,?XSP + 1
   \   000050   7952         MOV       R1,#0x52
   \   000052   12....       LCALL     `??ZMacSetReq::?relay`; Banked call to: ZMacSetReq
   1638                  
   1639              // Perform Secure or Unsecure Rejoin depending on available configuration
   1640              if ( ZG_SECURE_ENABLED && ( ZDApp_RestoreNwkKey( TRUE ) == TRUE ) )
   \   000055                ; Setup parameters for call to function ZDApp_RestoreNwkKey
   \   000055   7901         MOV       R1,#0x1
   \   000057   12....       LCALL     `??ZDApp_RestoreNwkKey::?relay`; Banked call to: ZDApp_RestoreNwkKey
   \   00005A   E9           MOV       A,R1
   \   00005B   6401         XRL       A,#0x1
   \   00005D   90....       MOV       DPTR,#_NIB + 22
   \   000060   700B         JNZ       ??bdb_rejoinNwk_7
   1641              {
   1642                rejoinStatus = NLME_ReJoinRequest( ZDO_UseExtendedPANID, _NIB.nwkLogicalChannel);
   \   000062                ; Setup parameters for call to function NLME_ReJoinRequest
   \   000062   E0           MOVX      A,@DPTR
   \   000063   F9           MOV       R1,A
   \   000064   7A..         MOV       R2,#ZDO_UseExtendedPANID & 0xff
   \   000066   7B..         MOV       R3,#(ZDO_UseExtendedPANID >> 8) & 0xff
   \   000068   12....       LCALL     `??NLME_ReJoinRequest::?relay`; Banked call to: NLME_ReJoinRequest
   \   00006B   8009         SJMP      ??bdb_rejoinNwk_8
   1643              }
   1644              else
   1645              {
   1646                rejoinStatus = NLME_ReJoinRequestUnsecure( ZDO_UseExtendedPANID, _NIB.nwkLogicalChannel);
   \                     ??bdb_rejoinNwk_7:
   \   00006D                ; Setup parameters for call to function NLME_ReJoinRequestUnsecure
   \   00006D   E0           MOVX      A,@DPTR
   \   00006E   F9           MOV       R1,A
   \   00006F   7A..         MOV       R2,#ZDO_UseExtendedPANID & 0xff
   \   000071   7B..         MOV       R3,#(ZDO_UseExtendedPANID >> 8) & 0xff
   \   000073   12....       LCALL     `??NLME_ReJoinRequestUnsecure::?relay`; Banked call to: NLME_ReJoinRequestUnsecure
   \                     ??bdb_rejoinNwk_8:
   \   000076   E9           MOV       A,R1
   \   000077   FE           MOV       R6,A
   1647              }
   1648            }
   1649            
   1650            return rejoinStatus;
   \                     ??bdb_rejoinNwk_6:
   \   000078   EE           MOV       A,R6
   \   000079   F9           MOV       R1,A
   \   00007A   7401         MOV       A,#0x1
   \   00007C   12....       LCALL     ?DEALLOC_XSTACK8
   \   00007F                REQUIRE ?Subroutine0
   \   00007F                ; // Fall through to label ?Subroutine0
   1651          }
   1652          
   1653          #if (ZG_BUILD_JOINING_TYPE)
   1654           /*********************************************************************
   1655           * @fn          bdb_nwkDiscoveryAttempt
   1656           *
   1657           * @brief       Process a nwk discovery attempt
   1658           *
   1659           * @param       didSuccess - TRUE we found nwk in the scanned channels, FALSE if 
   1660           *                           no suitable nwks were found, try secondary channel
   1661           *
   1662           * @return      none
   1663           */
   1664          void bdb_nwkDiscoveryAttempt(bool didSuccess)
   1665          {
   1666            uint8 bdbJoinEvent = BDB_JOIN_EVENT_NWK_DISCOVERY;
   1667            
   1668            if(didSuccess)
   1669            {
   1670              bdb_SendMsg(bdb_TaskID, BDB_COMMISSIONING_STATE_JOINING, BDB_MSG_EVENT_SUCCESS,sizeof(bdbJoinEvent),(uint8*)&bdbJoinEvent);
   1671            }
   1672            else
   1673            {
   1674              //Can we try the secondary channel set?
   1675              if((vDoPrimaryScan) && (bdbAttributes.bdbSecondaryChannelSet))
   1676              {
   1677                vDoPrimaryScan = FALSE;
   1678                bdb_setChannel(bdbAttributes.bdbSecondaryChannelSet);
   1679                
   1680                ZDApp_NetworkInit( 50 );
   1681              }
   1682              else
   1683              {
   1684                bdb_reportCommissioningState(BDB_COMMISSIONING_STATE_JOINING, FALSE);
   1685              }
   1686            }
   1687          }
   1688          
   1689           /*********************************************************************
   1690           * @fn          bdb_filterNwkDisc
   1691           *
   1692           * @brief       Filter the nwks found and attempt to join the suitable nwks
   1693           *              Here the application can include nwk filters 
   1694           *
   1695           * @param       none
   1696           *
   1697           * @return      none
   1698           */
   1699          void bdb_filterNwkDisc(void)
   1700          {
   1701            networkDesc_t* pNwkDesc;
   1702            uint8 i = 0;
   1703            uint8 ResultCount = 0;
   1704            uint8 stackProfile = 0;
   1705            uint8 stackProfilePro = 0;
   1706            
   1707            pBDBListNwk  = nwk_getNwkDescList();
   1708            nwk_desc_list_release();
   1709            
   1710            pNwkDesc = pBDBListNwk;
   1711            while (pNwkDesc)
   1712            {
   1713              ResultCount++;
   1714              pNwkDesc = pNwkDesc->nextDesc;
   1715            }
   1716            
   1717            if(pBDBListNwk)
   1718            {
   1719              if(pfnFilterNwkDesc)
   1720              {
   1721                pfnFilterNwkDesc(pBDBListNwk, ResultCount);
   1722              }
   1723              
   1724              for ( stackProfile = 0; stackProfile < STACK_PROFILE_MAX; stackProfile++ )
   1725              {
   1726                pNwkDesc = pBDBListNwk;
   1727                
   1728                if(pNwkDesc)
   1729                {
   1730                  for ( i = 0; i < ResultCount; i++, pNwkDesc = pNwkDesc->nextDesc )
   1731                  {
   1732                    if ( nwk_ExtPANIDValid( ZDO_UseExtendedPANID ) == true )
   1733                    {
   1734                      // If the extended Pan ID is commissioned to a non zero value
   1735                      // Only join the Pan that has match EPID
   1736                      if ( osal_ExtAddrEqual( ZDO_UseExtendedPANID, pNwkDesc->extendedPANID) == false )
   1737                      {
   1738                        //Remove from the list
   1739                        bdb_nwkDescFree(pNwkDesc);
   1740                        ResultCount--;
   1741                        continue;
   1742                      }
   1743                    }
   1744                    else if ( zgConfigPANID != 0xFFFF )
   1745                    {
   1746                      // PAN Id is preconfigured. check if it matches
   1747                      if ( pNwkDesc->panId != zgConfigPANID )
   1748                      {
   1749                        //Remove from the list
   1750                        bdb_nwkDescFree(pNwkDesc);
   1751                        ResultCount--;
   1752                        continue;
   1753                      }
   1754                    }
   1755          
   1756                    if ( pNwkDesc->chosenRouter != _NIB.nwkCoordAddress || _NIB.nwkCoordAddress == INVALID_NODE_ADDR )
   1757                    {
   1758                      // check that network is allowing joining
   1759                      if ( ZSTACK_ROUTER_BUILD )
   1760                      {
   1761                        if ( stackProfilePro == FALSE )
   1762                        {
   1763                          if ( !pNwkDesc->routerCapacity )
   1764                          {
   1765                            //Remove from the list
   1766                            bdb_nwkDescFree(pNwkDesc);
   1767                            ResultCount--;
   1768                            continue;
   1769                          }
   1770                        }
   1771                        else
   1772                        {
   1773                          if ( !pNwkDesc->deviceCapacity )
   1774                          {
   1775                            //Remove from the list
   1776                            bdb_nwkDescFree(pNwkDesc);
   1777                            ResultCount--;
   1778                            continue;
   1779                          }
   1780                        }
   1781                      }
   1782                      else if ( ZSTACK_END_DEVICE_BUILD )
   1783                      {
   1784                        if ( !pNwkDesc->deviceCapacity )
   1785                        {
   1786                          //Remove from the list
   1787                          bdb_nwkDescFree(pNwkDesc);
   1788                          ResultCount--;
   1789                          continue;
   1790                        }
   1791                      }
   1792                    }
   1793          
   1794                    // check version of zigbee protocol
   1795                    if ( pNwkDesc->version != _NIB.nwkProtocolVersion )
   1796                      continue;
   1797          
   1798                    // check version of stack profile
   1799                    if ( pNwkDesc->stackProfile != zgStackProfile  )
   1800                    {
   1801                      if ( ((zgStackProfile == HOME_CONTROLS) && (pNwkDesc->stackProfile == ZIGBEEPRO_PROFILE))
   1802                          || ((zgStackProfile == ZIGBEEPRO_PROFILE) && (pNwkDesc->stackProfile == HOME_CONTROLS))  )
   1803                      {
   1804                        stackProfilePro = TRUE;
   1805                      }
   1806          
   1807                      if ( stackProfile == 0 )
   1808                      {
   1809                        //Remove from the list
   1810                        bdb_nwkDescFree(pNwkDesc);
   1811                        ResultCount--;
   1812                        continue;
   1813                      }
   1814                    }
   1815                  }
   1816                }
   1817              }
   1818            }
   1819          }
   1820                
   1821           /*********************************************************************
   1822           * @fn          bdb_tryNwkAssoc
   1823           *
   1824           * @brief       Try to associate to the first network in the network descriptor list
   1825           *
   1826           * @param       none
   1827           *
   1828           * @return      none
   1829           */
   1830          static void bdb_tryNwkAssoc(void)
   1831          {
   1832            if(pBDBListNwk)
   1833            {
   1834              bdbCommissioningProcedureState.bdbJoinState = BDB_JOIN_STATE_ASSOC;
   1835              
   1836              //Try the first in the list after the filtering
   1837              if(ZSuccess != bdb_joinProcess(pBDBListNwk))
   1838              {
   1839                //If fail, free the first in the list and prepare for futher processing, either next nwk or discover again
   1840                uint8 bdbJoinEvent = BDB_JOIN_EVENT_ASSOCIATION;
   1841                bdb_nwkDescFree(pBDBListNwk);
   1842                bdb_SendMsg(bdb_TaskID,BDB_COMMISSIONING_STATE_JOINING,BDB_MSG_EVENT_FAIL,sizeof(uint8),&bdbJoinEvent);
   1843              }
   1844            }
   1845            else
   1846            {
   1847              bdbCommissioningProcedureState.bdbJoinState = BDB_JOIN_STATE_NWK_DISC;
   1848              uint8 bdbJoinEvent = BDB_JOIN_EVENT_NWK_DISCOVERY;
   1849              
   1850              bdb_SendMsg(bdb_TaskID,BDB_COMMISSIONING_STATE_JOINING,BDB_MSG_EVENT_FAIL,sizeof(uint8),&bdbJoinEvent);
   1851            }
   1852          }
   1853          
   1854          
   1855          
   1856           /*********************************************************************
   1857           * @fn          bdb_nwkAssocAttemt
   1858           *
   1859           * @brief       Process the result of an attempt to associate to a network 
   1860           *
   1861           * @param       didSuccess - bool
   1862           *
   1863           * @return      none
   1864           */
   1865          void bdb_nwkAssocAttemt(bool didSuccess)
   1866          {
   1867            bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_STATE_JOINING;
   1868            uint8 bdbJoinEvent = BDB_JOIN_EVENT_ASSOCIATION;
   1869            uint8 status;
   1870            
   1871            if(didSuccess)
   1872            {
   1873              status = BDB_MSG_EVENT_SUCCESS;
   1874            }
   1875            else
   1876            {
   1877              if(bdb_nwkAssocRetriesCount < BDBC_REC_SAME_NETWORK_RETRY_ATTEMPS)
   1878              {
   1879                bdb_nwkAssocRetriesCount++;
   1880              }
   1881              else
   1882              {
   1883                //Free the first in the list and prepare for futher processing
   1884                bdb_nwkDescFree(pBDBListNwk);
   1885                bdb_nwkAssocRetriesCount = 0;
   1886              }
   1887              status = BDB_MSG_EVENT_FAIL;
   1888            }
   1889            bdb_SendMsg(bdb_TaskID,BDB_COMMISSIONING_STATE_JOINING,status,sizeof(uint8),&bdbJoinEvent);
   1890          }
   1891                                 
   1892          
   1893          /****************************************************************************
   1894           * @fn          bdb_nwkDescFree
   1895           *
   1896           * @brief       This function frees one network discovery data.
   1897           *
   1898           * @param       ZSuccess - If the device was found and erased
   1899           * @param       ZInvalidParameter - Not found
   1900           *
   1901           * @return      none
   1902           */
   1903          ZStatus_t bdb_nwkDescFree(networkDesc_t* nodeDescToRemove)
   1904          {
   1905            networkDesc_t* current_desc;
   1906            networkDesc_t* prev_desc;
   1907            
   1908            current_desc = pBDBListNwk;
   1909          
   1910            while(current_desc != NULL)
   1911            {  
   1912              if(current_desc == nodeDescToRemove)
   1913              {
   1914                if (current_desc == pBDBListNwk)
   1915                {
   1916                  pBDBListNwk = pBDBListNwk->nextDesc;
   1917                }
   1918                else
   1919                {
   1920                  prev_desc->nextDesc = current_desc->nextDesc;
   1921                }
   1922                
   1923                osal_mem_free( current_desc );
   1924                
   1925                return ZSuccess;
   1926              }
   1927          
   1928              prev_desc = current_desc;
   1929              current_desc = current_desc->nextDesc;
   1930            }
   1931            
   1932            return ZInvalidParameter;
   1933          }
   1934          
   1935          /*********************************************************************
   1936          * @fn          bdb_joinProcess
   1937          *
   1938          * @brief       Start the joining process for the selected nwk
   1939          *
   1940          * @return      ZStatus_t
   1941          */  
   1942          ZStatus_t bdb_joinProcess(networkDesc_t *pChosenNwk)
   1943          {
   1944            ZStatus_t status;
   1945           
   1946            ZDApp_ChangeState( DEV_NWK_JOINING );
   1947            ZDApp_NodeProfileSync( pChosenNwk->stackProfile);
   1948          
   1949            status =  NLME_JoinRequest( pChosenNwk->extendedPANID, pChosenNwk->panId,
   1950                                  pChosenNwk->logicalChannel,
   1951                                  ZDO_Config_Node_Descriptor.CapabilityFlags,
   1952                                  pChosenNwk->chosenRouter, pChosenNwk->chosenRouterDepth );
   1953            
   1954            if(status == ZSuccess)
   1955            {
   1956              // The receiver is on, turn network layer polling off.
   1957              if ( ZDO_Config_Node_Descriptor.CapabilityFlags & CAPINFO_RCVR_ON_IDLE )
   1958              {
   1959                // for an End Device with NO Child Table Management process or for a Router
   1960                if ( ( ZG_DEVICE_RTR_TYPE )  ||
   1961                     ( (ZG_DEVICE_ENDDEVICE_TYPE) && ( zgChildAgingEnable == FALSE ) ) )
   1962                {
   1963                  NLME_SetPollRate( 0 );
   1964                  NLME_SetQueuedPollRate( 0 );
   1965                  NLME_SetResponseRate( 0 );
   1966                }
   1967              }
   1968              else
   1969              {
   1970                if ( (ZG_SECURE_ENABLED) && (devStartMode == MODE_JOIN) )
   1971                {
   1972                  ZDApp_SavedPollRate = zgPollRate;
   1973                  NLME_SetPollRate( zgRejoinPollRate );
   1974                }
   1975              }
   1976            }
   1977            return status;
   1978          }
   1979          #endif
   1980          
   1981          
   1982           /*********************************************************************
   1983           * @fn          bdb_setChannelAttribute
   1984           *
   1985           * @brief       Set the primary or seconday channel for discovery or formation procedure
   1986           *
   1987           * @param       isPrimaryChannel - True if channel to set is primary,  
   1988           *                                 False if the channel to set is secondary
   1989           *
   1990           * @param       channel - Channel mask
   1991           *
   1992           * @return      none
   1993           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1994          void bdb_setChannelAttribute(bool isPrimaryChannel, uint32 channel)
   \                     bdb_setChannelAttribute:
   1995          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
   \   000009   8C..         MOV       ?V2,R4
   \   00000B   8D..         MOV       ?V3,R5
   1996            if(isPrimaryChannel)
   \   00000D   E9           MOV       A,R1
   \   00000E   6005         JZ        ??bdb_setChannelAttribute_0
   1997            {
   1998              bdbAttributes.bdbPrimaryChannelSet = channel;
   \   000010   90....       MOV       DPTR,#bdbAttributes + 4
   \   000013   8003         SJMP      ??bdb_setChannelAttribute_1
   1999            }
   2000            else
   2001            {
   2002              bdbAttributes.bdbSecondaryChannelSet = channel;
   \                     ??bdb_setChannelAttribute_0:
   \   000015   90....       MOV       DPTR,#bdbAttributes
   \                     ??bdb_setChannelAttribute_1:
   \   000018   78..         MOV       R0,#?V0
   \   00001A   12....       LCALL     ?L_MOV_TO_X
   2003            }
   2004          }
   \   00001D   80..         SJMP      ??Subroutine43_0
   2005          
   2006           /*********************************************************************
   2007           * @fn          bdb_setChannel
   2008           *
   2009           * @brief       Set channel and save it in Nv for joining/formation operations
   2010           *
   2011           * @param       channel - Channel mask
   2012           *
   2013           * @return      none
   2014           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7404         MOV       A,#0x4
   \   000002                REQUIRE ??Subroutine42_0
   \   000002                ; // Fall through to label ??Subroutine42_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2015          void bdb_setChannel(uint32 channel)
   \                     bdb_setChannel:
   2016          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
   \   000009   8C..         MOV       ?V2,R4
   \   00000B   8D..         MOV       ?V3,R5
   2017            //Assign the channel and save it into nv
   2018            vScanChannels = channel;
   \   00000D   90....       MOV       DPTR,#zgDefaultChannelList
   \   000010   78..         MOV       R0,#?V0
   \   000012   12....       LCALL     ?L_MOV_TO_X
   2019            runtimeChannel = channel;
   \   000015   90....       MOV       DPTR,#runtimeChannel
   \   000018   78..         MOV       R0,#?V0
   \   00001A   12....       LCALL     ?L_MOV_TO_X
   2020              
   2021            osal_nv_write(ZCD_NV_CHANLIST,0,sizeof(uint32),&vScanChannels);
   \   00001D                ; Setup parameters for call to function osal_nv_write
   \   00001D   75....       MOV       ?V0,#zgDefaultChannelList & 0xff
   \   000020   75....       MOV       ?V1,#(zgDefaultChannelList >> 8) & 0xff
   \   000023   78..         MOV       R0,#?V0
   \   000025   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000028   75..04       MOV       ?V0,#0x4
   \   00002B   75..00       MOV       ?V1,#0x0
   \   00002E   78..         MOV       R0,#?V0
   \   000030   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000033   7C00         MOV       R4,#0x0
   \   000035   7D00         MOV       R5,#0x0
   \   000037   7A84         MOV       R2,#-0x7c
   \   000039   7B00         MOV       R3,#0x0
   \   00003B   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   00003E   80..         SJMP      ?Subroutine2
   2022          }
   2023          
   2024          
   2025           /*********************************************************************
   2026           * @fn          bdb_nwkJoiningFormation   
   2027           *
   2028           * @brief       Performs Joining/Formation operation on primary or secondary channel
   2029           *
   2030           * @param       isJoining - TRUE if the device is performing joining, FALSE is performing Formation
   2031           *
   2032           * @return      none
   2033           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2034          void bdb_nwkJoiningFormation(bool isJoining)
   \                     bdb_nwkJoiningFormation:
   2035          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
   2036            
   2037            if((vDoPrimaryScan) && (bdbAttributes.bdbPrimaryChannelSet))
   \   000007   90....       MOV       DPTR,#vDoPrimaryScan
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   601C         JZ        ??bdb_nwkJoiningFormation_0
   \   00000D   90....       MOV       DPTR,#bdbAttributes + 4
   \   000010   78..         MOV       R0,#?V0
   \   000012   12....       LCALL     ?L_MOV_X
   \   000015   E5..         MOV       A,?V0
   \   000017   45..         ORL       A,?V1
   \   000019   45..         ORL       A,?V2
   \   00001B   45..         ORL       A,?V3
   \   00001D   600A         JZ        ??bdb_nwkJoiningFormation_0
   2038            {
   2039              bdb_setChannel(bdbAttributes.bdbPrimaryChannelSet);
   \   00001F                ; Setup parameters for call to function bdb_setChannel
   \   00001F   AA..         MOV       R2,?V0
   \   000021   AB..         MOV       R3,?V1
   \   000023   AC..         MOV       R4,?V2
   \   000025   AD..         MOV       R5,?V3
   \   000027   800B         SJMP      ??bdb_nwkJoiningFormation_1
   2040            }
   2041            else
   2042            {
   2043              vDoPrimaryScan = FALSE;
   \                     ??bdb_nwkJoiningFormation_0:
   \   000029   90....       MOV       DPTR,#vDoPrimaryScan
   \   00002C   E4           CLR       A
   \   00002D   F0           MOVX      @DPTR,A
   2044              bdb_setChannel(bdbAttributes.bdbSecondaryChannelSet);
   \   00002E                ; Setup parameters for call to function bdb_setChannel
   \   00002E   90....       MOV       DPTR,#bdbAttributes
   \   000031   12....       LCALL     ?XLOAD_R2345
   \                     ??bdb_nwkJoiningFormation_1:
   \   000034   12....       LCALL     `??bdb_setChannel::?relay`; Banked call to: bdb_setChannel
   2045            }
   2046          
   2047            if(vScanChannels)
   \   000037   90....       MOV       DPTR,#zgDefaultChannelList
   \   00003A   12....       LCALL     ?XLOAD_R0123
   \   00003D   E8           MOV       A,R0
   \   00003E   49           ORL       A,R1
   \   00003F   4A           ORL       A,R2
   \   000040   4B           ORL       A,R3
   \   000041   601A         JZ        ??bdb_nwkJoiningFormation_2
   2048            {
   2049              if(ZG_DEVICE_RTRONLY_TYPE)
   \   000043   90....       MOV       DPTR,#zgDeviceLogicalType
   \   000046   E0           MOVX      A,@DPTR
   \   000047   6401         XRL       A,#0x1
   \   000049   7007         JNZ       ??bdb_nwkJoiningFormation_3
   2050              {
   2051                if(isJoining)
   \   00004B   EE           MOV       A,R6
   \   00004C   7004         JNZ       ??bdb_nwkJoiningFormation_3
   2052                {
   2053                  ZDOInitDeviceEx(100,0);
   2054                }
   2055                else
   2056                {
   2057                  ZDOInitDeviceEx(100,1);
   \   00004E                ; Setup parameters for call to function ZDOInitDeviceEx
   \   00004E   7901         MOV       R1,#0x1
   \   000050   8002         SJMP      ??bdb_nwkJoiningFormation_4
   2058                }
   2059              }
   2060              //ZED can only join, and ZC can only create
   2061              else
   2062              {
   2063                ZDOInitDeviceEx(100,0);
   \                     ??bdb_nwkJoiningFormation_3:
   \   000052                ; Setup parameters for call to function ZDOInitDeviceEx
   \   000052   7900         MOV       R1,#0x0
   \                     ??bdb_nwkJoiningFormation_4:
   \   000054   7A64         MOV       R2,#0x64
   \   000056   7B00         MOV       R3,#0x0
   \   000058   12....       LCALL     `??ZDOInitDeviceEx::?relay`; Banked call to: ZDOInitDeviceEx
   \   00005B   800E         SJMP      ??bdb_nwkJoiningFormation_5
   2064              }
   2065            }
   2066            else
   2067            {
   2068              if(isJoining)
   \                     ??bdb_nwkJoiningFormation_2:
   \   00005D   EE           MOV       A,R6
   \   00005E   7A00         MOV       R2,#0x0
   \   000060   6004         JZ        ??bdb_nwkJoiningFormation_6
   2069              {
   2070                bdb_reportCommissioningState(BDB_COMMISSIONING_STATE_JOINING, FALSE);
   \   000062                ; Setup parameters for call to function bdb_reportCommissioningState
   \   000062   7903         MOV       R1,#0x3
   \   000064   8002         SJMP      ??bdb_nwkJoiningFormation_7
   2071              }
   2072              else
   2073              {
   2074                bdb_reportCommissioningState(BDB_COMMISSIONING_STATE_FORMATION, FALSE);
   \                     ??bdb_nwkJoiningFormation_6:
   \   000066                ; Setup parameters for call to function bdb_reportCommissioningState
   \   000066   7905         MOV       R1,#0x5
   \                     ??bdb_nwkJoiningFormation_7:
   \   000068   12....       LCALL     `??bdb_reportCommissioningState::?relay`; Banked call to: bdb_reportCommissioningState
   2075              }
   2076            }
   2077          }
   \                     ??bdb_nwkJoiningFormation_5:
   \   00006B   02....       LJMP      ??Subroutine43_0 & 0xFFFF
   2078          
   2079          #if (ZG_BUILD_JOINING_TYPE)
   2080           /*********************************************************************
   2081           * @fn          bdb_tcLinkKeyExchangeAttempt
   2082           *
   2083           * @brief       Generic send msg for TC link key exchange process attempts
   2084           *
   2085           * @param       didSuccess - FALSE if the step failed/timeout, TRUE otherwise
   2086           * @param       bdbTCExchangeState - Step in which the attemp was done
   2087           *
   2088           * @return      none
   2089           */
   2090          void bdb_tcLinkKeyExchangeAttempt(bool didSuccess, uint8 bdbTCExchangeState)
   2091          {
   2092            bool bdbEventStatus = BDB_MSG_EVENT_SUCCESS;
   2093            uint8 dummy;
   2094            bdbCommissioningProcedureState.bdbTCExchangeState = bdbTCExchangeState;
   2095            if(didSuccess)
   2096            {
   2097              //Allow try since we are performing a new step.
   2098              osal_stop_timerEx(bdb_TaskID, BDB_PROCESS_TIMEOUT);
   2099              bdbAttributes.bdbTCLinkKeyExchangeAttempts = 0;
   2100            }
   2101            else
   2102            {
   2103              bdbEventStatus = BDB_MSG_EVENT_FAIL;
   2104            }
   2105            bdb_SendMsg(bdb_TaskID,BDB_COMMISSIONING_STATE_TC_LINK_KEY_EXCHANGE,bdbEventStatus,1, &dummy);
   2106          }
   2107          
   2108          
   2109           /*********************************************************************
   2110           * @fn          bdb_requestVerifyTCLinkKey
   2111           *
   2112           * @brief       Attempt to verify the TC link key by sending Verify Key Request
   2113           *
   2114           * @param       none
   2115           *
   2116           * @return      none
   2117           */
   2118          void bdb_requestVerifyTCLinkKey(void)
   2119          {
   2120              uint8 TC_ExtAddr[Z_EXTADDR_LEN];
   2121              APSME_VerifyKeyReq_t vKey;
   2122              
   2123              APSME_GetRequest( apsTrustCenterAddress,0, TC_ExtAddr );
   2124              
   2125              vKey.tcExtAddr = TC_ExtAddr;
   2126              vKey.keyType = KEY_TYPE_TC_LINK;
   2127              
   2128              APSME_VerifyKeyReq( &vKey );
   2129              
   2130              osal_stop_timerEx(bdb_TaskID,BDB_PROCESS_TIMEOUT);
   2131              osal_start_timerEx(bdb_TaskID,BDB_PROCESS_TIMEOUT,BDBC_TC_LINK_KEY_EXANGE_TIMEOUT);
   2132              
   2133          }
   2134          
   2135          /*********************************************************************
   2136           * @fn          bdb_requestTCLinkKey
   2137           *
   2138           * @brief       Attempt to request a TC link key
   2139           *
   2140           * @param       none
   2141           *
   2142           * @return      none
   2143           */
   2144          void bdb_requestTCLinkKey(void)
   2145          {
   2146            zAddrType_t destAddr;
   2147            APSME_RequestKeyReq_t req;
   2148          
   2149            destAddr.addrMode = Addr16Bit;
   2150            destAddr.addr.shortAddr = 0x0000;
   2151            
   2152            req.dstAddr = destAddr.addr.shortAddr;
   2153            req.keyType = KEY_TYPE_TC_LINK;
   2154            
   2155            APSME_RequestKeyReq(&req);
   2156            
   2157            osal_stop_timerEx(bdb_TaskID,BDB_PROCESS_TIMEOUT);
   2158            
   2159            osal_start_timerEx(bdb_TaskID,BDB_PROCESS_TIMEOUT,(uint32)requestLinkKeyTimeout);
   2160          } 
   2161          
   2162          
   2163          /*********************************************************************
   2164           * @fn          bdb_requestTCStackVersion
   2165           *
   2166           * @brief       Attempt to request the TC stack version using ZDP Node desc if 
   2167           *              join a Centralized nwk
   2168           *
   2169           * @param       none
   2170           *
   2171           * @return      none
   2172           */
   2173          void bdb_requestTCStackVersion(void)
   2174          {
   2175            if(requestNewTrustCenterLinkKey)
   2176            {
   2177              if(!APSME_IsDistributedSecurity())
   2178              {
   2179                if(bdbAttributes.bdbTCLinkKeyExchangeMethod == BDB_TC_LINK_KEY_EXCHANGE_APS_KEY)
   2180                {
   2181                  zAddrType_t destAddr;
   2182                 
   2183                  destAddr.addrMode = Addr16Bit;
   2184                  destAddr.addr.shortAddr = 0x0000;
   2185                 
   2186                  ZDP_NodeDescReq( &destAddr, destAddr.addr.shortAddr, 0);  
   2187                  
   2188                  osal_stop_timerEx(bdb_TaskID,BDB_PROCESS_TIMEOUT);
   2189                  osal_start_timerEx( bdb_TaskID, BDB_PROCESS_TIMEOUT, BDBC_TC_LINK_KEY_EXANGE_TIMEOUT );
   2190                  return;
   2191                }
   2192                else
   2193                {
   2194                  if(pfnCBKETCLinkKeyExchange)
   2195                  {
   2196                    pfnCBKETCLinkKeyExchange();
   2197                  }
   2198                  return;
   2199                }
   2200              }
   2201              else
   2202              {
   2203                bdb_setNodeJoinLinkKeyType(BDB_DISTRIBUTED_SECURITY_GLOBAL_LINK_KEY);
   2204              }
   2205            }
   2206            else
   2207            {
   2208              //Key not required, set default which is global
   2209              bdb_setNodeJoinLinkKeyType(BDB_DEFAULT_GLOBAL_TRUST_CENTER_LINK_KEY);
   2210            }
   2211            //TC link key not required or join distributed nwk
   2212            bdb_reportCommissioningState(BDB_COMMISSIONING_STATE_TC_LINK_KEY_EXCHANGE,TRUE);
   2213          }
   2214          #endif
   2215          
   2216          
   2217          /*********************************************************************
   2218           * @fn          bdb_nwkSteeringDeviceOnNwk
   2219           *
   2220           * @brief       Send ZDP mgmt permit joining
   2221           *
   2222           * @param       none
   2223           *
   2224           * @return      none
   2225           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2226          void bdb_nwkSteeringDeviceOnNwk(void)
   \                     bdb_nwkSteeringDeviceOnNwk:
   2227          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 9
   \   000004   74F7         MOV       A,#-0x9
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
   2228            zAddrType_t dstAddr;
   2229            dstAddr.addr.shortAddr = NWK_BROADCAST_SHORTADDR_DEVZCZR;
   \   000009   85..82       MOV       DPL,?XSP + 0
   \   00000C   85..83       MOV       DPH,?XSP + 1
   \   00000F   74FC         MOV       A,#-0x4
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   74FF         MOV       A,#-0x1
   \   000015   F0           MOVX      @DPTR,A
   2230            dstAddr.addrMode = AddrBroadcast;
   \   000016   7408         MOV       A,#0x8
   \   000018   12....       LCALL     ?XSTACK_DISP0_8
   \   00001B   740F         MOV       A,#0xf
   \   00001D   F0           MOVX      @DPTR,A
   2231            // Trust Center significance is always true
   2232            ZDP_MgmtPermitJoinReq( &dstAddr, BDBC_MIN_COMMISSIONING_TIME, TRUE, FALSE );
   \   00001E                ; Setup parameters for call to function ZDP_MgmtPermitJoinReq
   \   00001E   7D00         MOV       R5,#0x0
   \   000020   7C01         MOV       R4,#0x1
   \   000022   79B4         MOV       R1,#-0x4c
   \   000024   AA..         MOV       R2,?XSP + 0
   \   000026   AB..         MOV       R3,?XSP + 1
   \   000028   12....       LCALL     `??ZDP_MgmtPermitJoinReq::?relay`; Banked call to: ZDP_MgmtPermitJoinReq
   2233          }
   \   00002B   7409         MOV       A,#0x9
   \   00002D                REQUIRE ?Subroutine7
   \   00002D                ; // Fall through to label ?Subroutine7

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   12....       LCALL     ?DEALLOC_XSTACK8
   \   000003   02....       LJMP      ??Subroutine40_0 & 0xFFFF
   2234          
   2235          
   2236          /*********************************************************************
   2237           * @fn          bdb_startResumeCommissioningProcess
   2238           *
   2239           * @brief       Starts or resume the commissioning operations sets in the 
   2240           *              commissioningMode attribute
   2241           *
   2242           * @param       none
   2243           *
   2244           * @return      none
   2245           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2246          void bdb_startResumeCommissioningProcess(void)
   \                     bdb_startResumeCommissioningProcess:
   2247          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 11
   \   000005   74F5         MOV       A,#-0xb
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   2248          
   2249          #if ( defined ( BDB_TL_INITIATOR ) && (BDB_TOUCHLINK_CAPABILITY_ENABLED == TRUE) ) 
   2250            if(bdbAttributes.bdbCommissioningMode & BDB_COMMISSIONING_MODE_INITIATOR_TL)
   2251            {
   2252              uint16 nwkAddr;
   2253          
   2254              //Does the device supports this commissioning mode?
   2255              if(bdbAttributes.bdbNodeCommissioningCapability & BDB_TOUCHLINK_CAPABILITY)
   2256              {
   2257                //Clear previous state and substates
   2258                osal_memset(&bdbCommissioningProcedureState,0,sizeof(bdbCommissioningProcedureState));
   2259                bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_TL;
   2260                
   2261                // Get our short address
   2262                ZMacGetReq( ZMacShortAddress, (byte*)&nwkAddr );
   2263                if ( nwkAddr == INVALID_NODE_ADDR )
   2264                {
   2265                  initiatorSelectNwkParams();
   2266                }
   2267                
   2268                touchLinkInitiator_StartDevDisc( );  
   2269                
   2270                bdb_NotifyCommissioningModeStart(BDB_COMMISSIONING_TOUCHLINK);
   2271              }
   2272              else
   2273              {
   2274                //Process the next commissioning mode
   2275                bdb_reportCommissioningState( BDB_COMMISSIONING_STATE_TL, FALSE );
   2276              }
   2277              return;
   2278            }
   2279          #endif // BDB_TOUCHLINK_CAPABILITY_ENABLED  
   2280          
   2281            
   2282            if(bdbAttributes.bdbCommissioningMode & BDB_COMMISSIONING_MODE_NWK_STEERING)
   \   00000A   90....       MOV       DPTR,#bdbAttributes + 11
   \   00000D   E0           MOVX      A,@DPTR
   \   00000E   A2E1         MOV       C,0xE0 /* A   */.1
   \   000010   5028         JNC       ??bdb_startResumeCommissioningProcess_0
   2283            {
   2284              bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_STEERING_ON_NWK;
   \   000012   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   000015   7404         MOV       A,#0x4
   \   000017   F0           MOVX      @DPTR,A
   2285              
   2286              if(bdbAttributes.bdbNodeCommissioningCapability & BDB_NETWORK_STEERING_CAPABILITY)
   \   000018   90....       MOV       DPTR,#bdbAttributes + 12
   \   00001B   E0           MOVX      A,@DPTR
   \   00001C   A2E0         MOV       C,0xE0 /* A   */.0
   \   00001E   5017         JNC       ??bdb_startResumeCommissioningProcess_1
   2287              {
   2288          #if (BDB_TOUCHLINK_CAPABILITY_ENABLED == TRUE)
   2289                bdb_ClearNetworkParams();
   2290          #endif
   2291                if(bdbAttributes.bdbNodeIsOnANetwork)
   \   000020   90....       MOV       DPTR,#bdbAttributes + 14
   \   000023   E0           MOVX      A,@DPTR
   \   000024   600A         JZ        ??bdb_startResumeCommissioningProcess_2
   2292                {
   2293                  bdb_nwkSteeringDeviceOnNwk();
   \   000026                ; Setup parameters for call to function bdb_nwkSteeringDeviceOnNwk
   \   000026   12....       LCALL     `??bdb_nwkSteeringDeviceOnNwk::?relay`; Banked call to: bdb_nwkSteeringDeviceOnNwk
   2294                  bdb_reportCommissioningState(BDB_COMMISSIONING_STATE_STEERING_ON_NWK, TRUE);
   \   000029                ; Setup parameters for call to function bdb_reportCommissioningState
   \   000029   7A01         MOV       R2,#0x1
   \   00002B   7904         MOV       R1,#0x4
   \   00002D   12....       LCALL     `??bdb_reportCommissioningState::?relay`; Banked call to: bdb_reportCommissioningState
   2295                }
   2296          #if (ZG_BUILD_JOINING_TYPE)
   2297                else
   2298                {
   2299                  if(ZG_DEVICE_JOINING_TYPE)
   2300                  {
   2301                    vDoPrimaryScan = TRUE;
   2302                    
   2303                    //Initialize the commissioning procedure state, bdbJoinState to nwk discovery and TCLinkKeyExchange to not active
   2304                    osal_memset(&bdbCommissioningProcedureState,0,sizeof(bdbCommissioningProcedureState_t));
   2305                    bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_JOINING;
   2306                    bdb_nwkJoiningFormation(TRUE);
   2307                    bdb_NotifyCommissioningModeStart(BDB_COMMISSIONING_NWK_STEERING);
   2308                  }
   2309                }
   2310          #endif
   2311          #if (ZG_BUILD_COORDINATOR_TYPE)
   2312                if(ZG_DEVICE_COORDINATOR_TYPE)
   2313                {
   2314                  bdb_reportCommissioningState(BDB_COMMISSIONING_STATE_STEERING_ON_NWK, FALSE);
   \                     ??bdb_startResumeCommissioningProcess_2:
   \   000030                ; Setup parameters for call to function bdb_reportCommissioningState
   \   000030   7A00         MOV       R2,#0x0
   \   000032   7904         MOV       R1,#0x4
   \   000034   12....       LCALL     `??bdb_reportCommissioningState::?relay`; Banked call to: bdb_reportCommissioningState
   2315                }
   2316          #endif
   2317              }
   2318              return;
   \                     ??bdb_startResumeCommissioningProcess_1:
   \   000037   02....       LJMP      ??bdb_startResumeCommissioningProcess_3 & 0xFFFF
   2319            }
   2320            
   2321            if(bdbAttributes.bdbCommissioningMode & BDB_COMMISSIONING_MODE_NWK_FORMATION)
   \                     ??bdb_startResumeCommissioningProcess_0:
   \   00003A   A2E2         MOV       C,0xE0 /* A   */.2
   \   00003C   5044         JNC       ??bdb_startResumeCommissioningProcess_4
   2322            {
   2323              bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_FORMATION;
   \   00003E   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   000041   7405         MOV       A,#0x5
   \   000043   F0           MOVX      @DPTR,A
   2324              
   2325              if(bdbAttributes.bdbNodeCommissioningCapability & BDB_NETWORK_FORMATION_CAPABILITY)
   \   000044   90....       MOV       DPTR,#bdbAttributes + 12
   \   000047   E0           MOVX      A,@DPTR
   \   000048   A2E1         MOV       C,0xE0 /* A   */.1
   \   00004A   502C         JNC       ??bdb_startResumeCommissioningProcess_5
   2326              {
   2327                if(!bdbAttributes.bdbNodeIsOnANetwork)
   \   00004C   90....       MOV       DPTR,#bdbAttributes + 14
   \   00004F   E0           MOVX      A,@DPTR
   \   000050   7026         JNZ       ??bdb_startResumeCommissioningProcess_5
   2328                {
   2329          #if (BDB_TOUCHLINK_CAPABILITY_ENABLED == TRUE)
   2330                bdb_ClearNetworkParams();
   2331          #endif
   2332                  vDoPrimaryScan = TRUE;
   \   000052   90....       MOV       DPTR,#vDoPrimaryScan
   \   000055   7401         MOV       A,#0x1
   \   000057   F0           MOVX      @DPTR,A
   2333                  
   2334                  osal_memset(&bdbCommissioningProcedureState,0,sizeof(bdbCommissioningProcedureState));
   \   000058                ; Setup parameters for call to function osal_memset
   \   000058   7C04         MOV       R4,#0x4
   \   00005A   7D00         MOV       R5,#0x0
   \   00005C   7900         MOV       R1,#0x0
   \   00005E   7A..         MOV       R2,#bdbCommissioningProcedureState & 0xff
   \   000060   7B..         MOV       R3,#(bdbCommissioningProcedureState >> 8) & 0xff
   \   000062   12....       LCALL     `??osal_memset::?relay`; Banked call to: osal_memset
   2335                  bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_FORMATION;
   \   000065   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   000068   7405         MOV       A,#0x5
   \   00006A   F0           MOVX      @DPTR,A
   2336          
   2337                  bdb_nwkJoiningFormation(FALSE);
   \   00006B                ; Setup parameters for call to function bdb_nwkJoiningFormation
   \   00006B   7900         MOV       R1,#0x0
   \   00006D   12....       LCALL     `??bdb_nwkJoiningFormation::?relay`; Banked call to: bdb_nwkJoiningFormation
   2338                  bdb_NotifyCommissioningModeStart(BDB_COMMISSIONING_FORMATION);
   \   000070                ; Setup parameters for call to function bdb_NotifyCommissioningModeStart
   \   000070   7902         MOV       R1,#0x2
   \   000072   12....       LCALL     `??bdb_NotifyCommissioningModeStart::?relay`; Banked call to: bdb_NotifyCommissioningModeStart
   2339                  return;
   \   000075   02....       LJMP      ??bdb_startResumeCommissioningProcess_3 & 0xFFFF
   2340                }
   2341              }
   2342              bdb_reportCommissioningState(BDB_COMMISSIONING_STATE_FORMATION, FALSE);
   \                     ??bdb_startResumeCommissioningProcess_5:
   \   000078                ; Setup parameters for call to function bdb_reportCommissioningState
   \   000078   7A00         MOV       R2,#0x0
   \   00007A   7905         MOV       R1,#0x5
   \   00007C   12....       LCALL     `??bdb_reportCommissioningState::?relay`; Banked call to: bdb_reportCommissioningState
   2343              return;
   \   00007F   02....       LJMP      ??bdb_startResumeCommissioningProcess_3 & 0xFFFF
   2344            }
   2345          
   2346          #if (BDB_FINDING_BINDING_CAPABILITY_ENABLED==1)    
   2347            if(bdbAttributes.bdbCommissioningMode & BDB_COMMISSIONING_MODE_FINDING_BINDING)
   \                     ??bdb_startResumeCommissioningProcess_4:
   \   000082   A2E3         MOV       C,0xE0 /* A   */.3
   \   000084   4003         JC        $+5
   \   000086   02....       LJMP      ??bdb_startResumeCommissioningProcess_3 & 0xFFFF
   2348            {
   2349              bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_FINDING_BINDING;
   \   000089   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   00008C   7406         MOV       A,#0x6
   \   00008E   F0           MOVX      @DPTR,A
   2350              
   2351              //Is the device on a network?
   2352              if(bdb_isDeviceNonFactoryNew())
   \   00008F   90....       MOV       DPTR,#bdbAttributes + 14
   \   000092   E0           MOVX      A,@DPTR
   \   000093   7003         JNZ       $+5
   \   000095   02....       LJMP      ??bdb_startResumeCommissioningProcess_6 & 0xFFFF
   2353              {
   2354                zclAttrRec_t attrRec;
   2355          
   2356                endPointDesc_t *bdb_CurrEpDescriptor = NULL;
   2357          
   2358                bdb_CurrEpDescriptor = bdb_setEpDescListToActiveEndpoint();
   \   000098                ; Setup parameters for call to function bdb_setEpDescListToActiveEndpoint
   \   000098   12....       LCALL     `??bdb_setEpDescListToActiveEndpoint::?relay`; Banked call to: bdb_setEpDescListToActiveEndpoint
   \   00009B   8A..         MOV       ?V0,R2
   \   00009D   8B..         MOV       ?V1,R3
   \   00009F   AE..         MOV       R6,?V0
   \   0000A1   AF..         MOV       R7,?V1
   2359                
   2360                //If not found endpoint with Identify cluster is found, then report fail
   2361                if(bdb_CurrEpDescriptor == NULL)
   \   0000A3   EE           MOV       A,R6
   \   0000A4   4F           ORL       A,R7
   \   0000A5   7003         JNZ       $+5
   \   0000A7   02....       LJMP      ??bdb_startResumeCommissioningProcess_6 & 0xFFFF
   2362                {
   2363                  bdb_exitFindingBindingWStatus(BDB_COMMISSIONING_FAILURE);
   \   0000AA                ; Setup parameters for call to function bdb_exitFindingBindingWStatus
   2364                  return;
   2365                }
   2366                
   2367                if( bdb_CurrEpDescriptorList->epDesc->epType & BDB_FINDING_AND_BINDING_TARGET)  //F&B as Target
   \   0000AA   12....       LCALL     ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   0000AD   A3           INC       DPTR
   \   0000AE   E0           MOVX      A,@DPTR
   \   0000AF   A2E1         MOV       C,0xE0 /* A   */.1
   \   0000B1   4003         JC        $+5
   \   0000B3   02....       LJMP      ??bdb_startResumeCommissioningProcess_7 & 0xFFFF
   2368                {
   2369                  if (zclFindAttrRec( bdb_CurrEpDescriptor->endPoint, ZCL_CLUSTER_ID_GEN_IDENTIFY,
   2370                            ATTRID_IDENTIFY_TIME, &attrRec ) )
   \   0000B6                ; Setup parameters for call to function zclFindAttrRec
   \   0000B6   7403         MOV       A,#0x3
   \   0000B8   12....       LCALL     ?XSTACK_DISP100_8
   \   0000BB   88..         MOV       ?V0,R0
   \   0000BD   89..         MOV       ?V1,R1
   \   0000BF   78..         MOV       R0,#?V0
   \   0000C1   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0000C4   7C00         MOV       R4,#0x0
   \   0000C6   7D00         MOV       R5,#0x0
   \   0000C8   7A03         MOV       R2,#0x3
   \   0000CA   7B00         MOV       R3,#0x0
   \   0000CC   8E82         MOV       DPL,R6
   \   0000CE   8F83         MOV       DPH,R7
   \   0000D0   E0           MOVX      A,@DPTR
   \   0000D1   F9           MOV       R1,A
   \   0000D2   12....       LCALL     `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   0000D5   7402         MOV       A,#0x2
   \   0000D7   12....       LCALL     ?DEALLOC_XSTACK8
   \   0000DA   E9           MOV       A,R1
   \   0000DB   7003         JNZ       $+5
   \   0000DD   02....       LJMP      ??bdb_startResumeCommissioningProcess_8 & 0xFFFF
   2371                  {
   2372                    //Set it to at less 180 
   2373                    if ( *((uint16*)attrRec.attr.dataPtr) <= BDBC_MIN_COMMISSIONING_TIME )
   \   0000E0   7409         MOV       A,#0x9
   \   0000E2   12....       LCALL     ?XSTACK_DISP0_8
   \   0000E5   12....       LCALL     ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   0000E8   C3           CLR       C
   \   0000E9   E0           MOVX      A,@DPTR
   \   0000EA   94B5         SUBB      A,#-0x4b
   \   0000EC   A3           INC       DPTR
   \   0000ED   E0           MOVX      A,@DPTR
   \   0000EE   9400         SUBB      A,#0x0
   \   0000F0   5040         JNC       ??bdb_startResumeCommissioningProcess_9
   2374                    {
   2375                      *((uint16*)attrRec.attr.dataPtr) = BDBC_MIN_COMMISSIONING_TIME;
   \   0000F2   8882         MOV       DPL,R0
   \   0000F4   8983         MOV       DPH,R1
   \   0000F6   74B4         MOV       A,#-0x4c
   \   0000F8   F0           MOVX      @DPTR,A
   \   0000F9   A3           INC       DPTR
   \   0000FA   E4           CLR       A
   \   0000FB   F0           MOVX      @DPTR,A
   2376                       osal_start_timerEx( bdb_TaskID, BDB_IDENTIFY_TIMEOUT, 1000 );
   \   0000FC                ; Setup parameters for call to function osal_start_timerEx
   \   0000FC   90....       MOV       DPTR,#__Constant_3e8
   \   0000FF   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   000102   7A00         MOV       R2,#0x0
   \   000104   7B20         MOV       R3,#0x20
   \   000106   90....       MOV       DPTR,#bdb_TaskID
   \   000109   E0           MOVX      A,@DPTR
   \   00010A   F9           MOV       R1,A
   \   00010B   12....       LCALL     `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   00010E   7404         MOV       A,#0x4
   \   000110   12....       LCALL     ?DEALLOC_XSTACK8
   2377          
   2378                      if(pfnIdentifyTimeChangeCB != NULL)
   \   000113   90....       MOV       DPTR,#pfnIdentifyTimeChangeCB
   \   000116   12....       LCALL     ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_62:
   \   000119   6017         JZ        ??bdb_startResumeCommissioningProcess_9
   2379                      {
   2380                        if(bdbIndentifyActiveEndpoint == 0xFF)
   \   00011B   90....       MOV       DPTR,#bdbIndentifyActiveEndpoint
   \   00011E   E0           MOVX      A,@DPTR
   \   00011F   F4           CPL       A
   \   000120   7004         JNZ       ??bdb_startResumeCommissioningProcess_10
   2381                        {
   2382                          pfnIdentifyTimeChangeCB(bdbIndentifyActiveEndpoint);  
   \   000122                ; Setup parameters for indirect call
   \   000122   79FF         MOV       R1,#-0x1
   \   000124   8006         SJMP      ??bdb_startResumeCommissioningProcess_11
   2383                        }
   2384                        else
   2385                        {
   2386                          pfnIdentifyTimeChangeCB(bdb_CurrEpDescriptor->endPoint);
   \                     ??bdb_startResumeCommissioningProcess_10:
   \   000126                ; Setup parameters for indirect call
   \   000126   8E82         MOV       DPL,R6
   \   000128   8F83         MOV       DPH,R7
   \   00012A   E0           MOVX      A,@DPTR
   \   00012B   F9           MOV       R1,A
   2387                        }
   2388                      }
   2389                    }
   \                     ??bdb_startResumeCommissioningProcess_11:
   \   00012C   12....       LCALL     ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   00012F   12....       LCALL     ?CALL_IND
   2390                    //Attribute found and set, report success
   2391                    if(!(bdb_CurrEpDescriptorList->epDesc->epType & BDB_FINDING_AND_BINDING_INITIATOR))
   \                     ??bdb_startResumeCommissioningProcess_9:
   \   000132   12....       LCALL     ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_12:
   \   000135   4004         JC        ??bdb_startResumeCommissioningProcess_12
   2392                    {
   2393                      bdb_exitFindingBindingWStatus(BDB_COMMISSIONING_FB_TARGET_IN_PROGRESS);
   \   000137                ; Setup parameters for call to function bdb_exitFindingBindingWStatus
   \   000137   7909         MOV       R1,#0x9
   \   000139   802C         SJMP      ??bdb_startResumeCommissioningProcess_13
   2394                    }
   2395                    else
   2396                    {
   2397                      bdbCommissioningModeMsg_t bdbCommissioningModeMsg;
   2398          
   2399                      bdbCommissioningModeMsg.bdbCommissioningMode = BDB_COMMISSIONING_FINDING_BINDING;
   \                     ??bdb_startResumeCommissioningProcess_12:
   \   00013B   7401         MOV       A,#0x1
   \   00013D   12....       LCALL     ?XSTACK_DISP0_8
   \   000140   12....       LCALL     ?Subroutine16 & 0xFFFF
   2400                      bdbCommissioningModeMsg.bdbCommissioningStatus = BDB_COMMISSIONING_FB_TARGET_IN_PROGRESS;
   2401          
   2402                      bdb_NotifyApp((uint8*)&bdbCommissioningModeMsg);
   2403                    }
   2404                  }
   \                     ??CrossCallReturnLabel_75:
   \   000143   7409         MOV       A,#0x9
   \   000145   12....       LCALL     ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   000148   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00014B   7C03         MOV       R4,#0x3
   \   00014D   7B00         MOV       R3,#0x0
   \   00014F   7A0A         MOV       R2,#0xa
   \   000151   90....       MOV       DPTR,#bdb_TaskID
   \   000154   E0           MOVX      A,@DPTR
   \   000155   F9           MOV       R1,A
   \   000156   12....       LCALL     `??bdb_SendMsg::?relay`; Banked call to: bdb_SendMsg
   \   000159   7402         MOV       A,#0x2
   \   00015B   12....       LCALL     ?DEALLOC_XSTACK8
   \   00015E   800A         SJMP      ??bdb_startResumeCommissioningProcess_7
   2405                  else
   2406                  {
   2407                    //Attribute not found and no initiator process, report fail
   2408                    if(!(bdb_CurrEpDescriptorList->epDesc->epType & BDB_FINDING_AND_BINDING_INITIATOR))
   \                     ??bdb_startResumeCommissioningProcess_8:
   \   000160   12....       LCALL     ?Subroutine18 & 0xFFFF
   \                     ??CrossCallReturnLabel_13:
   \   000163   4005         JC        ??bdb_startResumeCommissioningProcess_7
   2409                    {
   2410                      bdb_exitFindingBindingWStatus(BDB_COMMISSIONING_FAILURE);
   \   000165                ; Setup parameters for call to function bdb_exitFindingBindingWStatus
   \   000165   790E         MOV       R1,#0xe
   \                     ??bdb_startResumeCommissioningProcess_13:
   \   000167   12....       LCALL     `??bdb_exitFindingBindingWStatus::?relay`; Banked call to: bdb_exitFindingBindingWStatus
   2411                    }
   2412                  }
   2413                }  //F&B Target
   2414                
   2415                if( bdb_CurrEpDescriptorList->epDesc->epType & BDB_FINDING_AND_BINDING_INITIATOR)  //F&B as Initiator
   \                     ??bdb_startResumeCommissioningProcess_7:
   \   00016A   90....       MOV       DPTR,#bdb_CurrEpDescriptorList
   \   00016D   E0           MOVX      A,@DPTR
   \   00016E   F8           MOV       R0,A
   \   00016F   A3           INC       DPTR
   \   000170   12....       LCALL     ??Subroutine48_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   000173   A3           INC       DPTR
   \   000174   A3           INC       DPTR
   \   000175   E0           MOVX      A,@DPTR
   \   000176   2401         ADD       A,#0x1
   \   000178   F8           MOV       R0,A
   \   000179   A3           INC       DPTR
   \   00017A   E0           MOVX      A,@DPTR
   \   00017B   3400         ADDC      A,#0x0
   \   00017D   F9           MOV       R1,A
   \   00017E   8882         MOV       DPL,R0
   \   000180   8983         MOV       DPH,R1
   \   000182   E0           MOVX      A,@DPTR
   \   000183   A2E0         MOV       C,0xE0 /* A   */.0
   \   000185   5069         JNC       ??bdb_startResumeCommissioningProcess_3
   2416                {
   2417                  bdbCommissioningModeMsg_t bdbCommissioningModeMsg;
   2418                  
   2419                  //If no function to add binds is available then do not process Initiator
   2420                  if(!pbindAddEntry)
   \   000187   90....       MOV       DPTR,#pbindAddEntry
   \   00018A   12....       LCALL     ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   00018D   7010         JNZ       ??bdb_startResumeCommissioningProcess_14
   2421                  {
   2422                    //If no target process, then report fail
   2423                    if(!(bdb_CurrEpDescriptorList->epDesc->epType & BDB_FINDING_AND_BINDING_TARGET))
   \   00018F   8882         MOV       DPL,R0
   \   000191   8983         MOV       DPH,R1
   \   000193   E0           MOVX      A,@DPTR
   \   000194   A2E1         MOV       C,0xE0 /* A   */.1
   \   000196   4058         JC        ??bdb_startResumeCommissioningProcess_3
   2424                    {
   2425                      bdb_exitFindingBindingWStatus(BDB_COMMISSIONING_FAILURE);
   2426                    }        
   2427                  }
   2428                  else
   2429                  {
   2430                    // JC NOTES: This is the place where the Identify Query specified in BDB F&B (Figure 7) is initiated.
   2431                    //Send identify query with the endpoint requested
   2432                    if(bdb_SendIdentifyQuery(bdb_CurrEpDescriptor->endPoint) != ZSuccess)
   2433                    {
   2434                      bdb_exitFindingBindingWStatus(BDB_COMMISSIONING_FAILURE);
   2435                    }
   2436          
   2437                    //If periodic F&B is enabled
   2438                    if ( FINDING_AND_BINDING_PERIODIC_ENABLE == TRUE )
   2439                    {
   2440                      // total F&B time will be at least BDBC_MIN_COMMISSIONING_TIME, and at most (BDBC_MIN_COMMISSIONING_TIME + FINDING_AND_BINDING_PERIODIC_TIME - 1)
   2441                      bdb_FB_InitiatorCurrentCyclesNumber = (BDBC_MIN_COMMISSIONING_TIME + (FINDING_AND_BINDING_PERIODIC_TIME - 1)) / FINDING_AND_BINDING_PERIODIC_TIME;
   2442                      
   2443                      osal_start_timerEx(bdb_TaskID, BDB_FINDING_AND_BINDING_PERIOD_TIMEOUT, FINDING_AND_BINDING_PERIODIC_TIME * 1000);
   2444                    }
   2445          
   2446                    bdbCommissioningModeMsg.bdbCommissioningMode = BDB_COMMISSIONING_FINDING_BINDING;
   2447                    bdbCommissioningModeMsg.bdbCommissioningStatus = BDB_COMMISSIONING_FB_INITITATOR_IN_PROGRESS;
   2448          
   2449                    bdb_NotifyApp((uint8*)&bdbCommissioningModeMsg);
   2450                  }
   2451                } //F&B Initiator
   2452              }
   2453              //Not in the network
   2454              else
   2455              {
   2456                bdb_exitFindingBindingWStatus(BDB_COMMISSIONING_FAILURE);
   \                     ??bdb_startResumeCommissioningProcess_6:
   \   000198                ; Setup parameters for call to function bdb_exitFindingBindingWStatus
   \   000198   790E         MOV       R1,#0xe
   \   00019A   12....       LCALL     `??bdb_exitFindingBindingWStatus::?relay`; Banked call to: bdb_exitFindingBindingWStatus
   2457              }
   2458              
   2459              return;
   \   00019D   8051         SJMP      ??bdb_startResumeCommissioningProcess_3
   \                     ??bdb_startResumeCommissioningProcess_14:
   \   00019F                ; Setup parameters for call to function bdb_SendIdentifyQuery
   \   00019F   8E82         MOV       DPL,R6
   \   0001A1   8F83         MOV       DPH,R7
   \   0001A3   E0           MOVX      A,@DPTR
   \   0001A4   F9           MOV       R1,A
   \   0001A5   12....       LCALL     `??bdb_SendIdentifyQuery::?relay`; Banked call to: bdb_SendIdentifyQuery
   \   0001A8   E9           MOV       A,R1
   \   0001A9   6005         JZ        ??bdb_startResumeCommissioningProcess_15
   \   0001AB                ; Setup parameters for call to function bdb_exitFindingBindingWStatus
   \   0001AB   790E         MOV       R1,#0xe
   \   0001AD   12....       LCALL     `??bdb_exitFindingBindingWStatus::?relay`; Banked call to: bdb_exitFindingBindingWStatus
   \                     ??bdb_startResumeCommissioningProcess_15:
   \   0001B0   90....       MOV       DPTR,#bdb_FB_InitiatorCurrentCyclesNumber
   \   0001B3   740C         MOV       A,#0xc
   \   0001B5   F0           MOVX      @DPTR,A
   \   0001B6                ; Setup parameters for call to function osal_start_timerEx
   \   0001B6   90....       MOV       DPTR,#__Constant_3a98
   \   0001B9   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   0001BC   7A40         MOV       R2,#0x40
   \   0001BE   7B00         MOV       R3,#0x0
   \   0001C0   90....       MOV       DPTR,#bdb_TaskID
   \   0001C3   E0           MOVX      A,@DPTR
   \   0001C4   F9           MOV       R1,A
   \   0001C5   12....       LCALL     `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   0001C8   7404         MOV       A,#0x4
   \   0001CA   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001CD   7401         MOV       A,#0x1
   \   0001CF   12....       LCALL     ?XSTACK_DISP0_8
   \   0001D2   12....       LCALL     ?Subroutine16 & 0xFFFF
   2460            }
   \                     ??CrossCallReturnLabel_76:
   \   0001D5   740A         MOV       A,#0xa
   \   0001D7   12....       LCALL     ?Subroutine9 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   0001DA   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   0001DD   7C03         MOV       R4,#0x3
   \   0001DF   7B00         MOV       R3,#0x0
   \   0001E1   7A0A         MOV       R2,#0xa
   \   0001E3   90....       MOV       DPTR,#bdb_TaskID
   \   0001E6   E0           MOVX      A,@DPTR
   \   0001E7   F9           MOV       R1,A
   \   0001E8   12....       LCALL     `??bdb_SendMsg::?relay`; Banked call to: bdb_SendMsg
   \   0001EB   7402         MOV       A,#0x2
   \   0001ED   12....       LCALL     ?DEALLOC_XSTACK8
   2461          #endif
   2462            
   2463          }
   \                     ??bdb_startResumeCommissioningProcess_3:
   \   0001F0   740B         MOV       A,#0xb
   \   0001F2   02....       LJMP      ?Subroutine1 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   12....       LCALL     ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   A2E0         MOV       C,0xE0 /* A   */.0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   7403         MOV       A,#0x3
   \   000002                REQUIRE ??Subroutine47_0
   \   000002                ; // Fall through to label ??Subroutine47_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   90....       MOV       DPTR,#pfnIdentifyTimeChangeCB + 1
   \   000003                REQUIRE ??Subroutine48_0
   \   000003                ; // Fall through to label ??Subroutine48_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   12....       LCALL     ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   90....       MOV       DPTR,#bdb_CurrEpDescriptorList
   \   000003   12....       LCALL     ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_42:
   \   000006   12....       LCALL     ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   000009   22           RET
   2464          
   2465          /*********************************************************************
   2466           * @fn          bdb_event_loop
   2467           *
   2468           * @brief       Main event loop bdb tasks.
   2469           *
   2470           * @param       task_id - task id
   2471           * @param       events - event bitmap
   2472           *
   2473           * @return      unprocessed events
   2474           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2475          UINT16 bdb_event_loop(byte task_id, UINT16 events)
   \                     bdb_event_loop:
   2476          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV       A,#-0x8
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   2477            (void)task_id;  // Intentionally unreferenced parameter
   2478            
   2479          #if (BDB_FINDING_BINDING_CAPABILITY_ENABLED==1)  
   2480            endPointDesc_t * bdb_CurrEpDescriptor;
   2481          #endif
   2482            
   2483            if(events & BDB_CHANGE_COMMISSIONING_STATE)
   \   00000E   EE           MOV       A,R6
   \   00000F   5404         ANL       A,#0x4
   \   000011   6047         JZ        ??bdb_event_loop_0
   2484            {
   2485              switch(bdbCommissioningProcedureState.bdbCommissioningState)
   \   000013   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   000016   E0           MOVX      A,@DPTR
   \   000017   600A         JZ        ??bdb_event_loop_1
   \   000019   24FC         ADD       A,#-0x4
   \   00001B   600B         JZ        ??bdb_event_loop_2
   \   00001D   24FE         ADD       A,#-0x2
   \   00001F   6013         JZ        ??bdb_event_loop_3
   \   000021   8031         SJMP      ??bdb_event_loop_4
   2486              {
   2487                case BDB_COMMISSIONING_STATE_START_RESUME:
   2488                  bdb_startResumeCommissioningProcess();
   \                     ??bdb_event_loop_1:
   \   000023                ; Setup parameters for call to function bdb_startResumeCommissioningProcess
   \   000023   12....       LCALL     `??bdb_startResumeCommissioningProcess::?relay`; Banked call to: bdb_startResumeCommissioningProcess
   2489                break;
   \   000026   802C         SJMP      ??bdb_event_loop_4
   2490                
   2491                case BDB_COMMISSIONING_STATE_TC_LINK_KEY_EXCHANGE:
   2492                  if (ZG_BUILD_JOINING_TYPE)
   2493                  {
   2494                    bdb_tcLinkKeyExchangeAttempt(TRUE,BDB_REQ_TC_STACK_VERSION);
   2495                  }
   2496                break;
   2497                
   2498                case BDB_COMMISSIONING_STATE_STEERING_ON_NWK:
   2499                  bdb_nwkSteeringDeviceOnNwk();
   \                     ??bdb_event_loop_2:
   \   000028                ; Setup parameters for call to function bdb_nwkSteeringDeviceOnNwk
   \   000028   12....       LCALL     `??bdb_nwkSteeringDeviceOnNwk::?relay`; Banked call to: bdb_nwkSteeringDeviceOnNwk
   2500                  
   2501                  bdb_reportCommissioningState(BDB_COMMISSIONING_STATE_STEERING_ON_NWK, TRUE);
   \   00002B                ; Setup parameters for call to function bdb_reportCommissioningState
   \   00002B   7A01         MOV       R2,#0x1
   \   00002D   7904         MOV       R1,#0x4
   \   00002F   12....       LCALL     `??bdb_reportCommissioningState::?relay`; Banked call to: bdb_reportCommissioningState
   2502                break;
   \   000032   8020         SJMP      ??bdb_event_loop_4
   2503                
   2504                case BDB_COMMISSIONING_STATE_FINDING_BINDING:
   2505                  bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_SUCCESS;
   \                     ??bdb_event_loop_3:
   \   000034   90....       MOV       DPTR,#bdbAttributes + 10
   \   000037   E4           CLR       A
   \   000038   F0           MOVX      @DPTR,A
   2506                  bdbCommissioningProcedureState.bdbCommissioningState = BDB_COMMISSIONING_STATE_START_RESUME;
   \   000039   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   00003C   F0           MOVX      @DPTR,A
   2507                  osal_start_timerEx(bdb_TaskID,BDB_CHANGE_COMMISSIONING_STATE,50);
   \   00003D                ; Setup parameters for call to function osal_start_timerEx
   \   00003D   90....       MOV       DPTR,#__Constant_32
   \   000040   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   000043   7A04         MOV       R2,#0x4
   \   000045   7B00         MOV       R3,#0x0
   \   000047   90....       MOV       DPTR,#bdb_TaskID
   \   00004A   E0           MOVX      A,@DPTR
   \   00004B   F9           MOV       R1,A
   \   00004C   12....       LCALL     `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   00004F   7404         MOV       A,#0x4
   \   000051   12....       LCALL     ?DEALLOC_XSTACK8
   2508                break;
   2509                
   2510              }
   2511              return (events ^ BDB_CHANGE_COMMISSIONING_STATE);
   \                     ??bdb_event_loop_4:
   \   000054   EE           MOV       A,R6
   \   000055   6404         XRL       A,#0x4
   \   000057   02....       LJMP      ??bdb_event_loop_5 & 0xFFFF
   2512            }
   2513          
   2514            if ( events & SYS_EVENT_MSG )
   \                     ??bdb_event_loop_0:
   \   00005A   EF           MOV       A,R7
   \   00005B   5480         ANL       A,#0x80
   \   00005D   7026         JNZ       ??bdb_event_loop_6
   2515            {
   2516              uint8 *msg_ptr;
   2517              
   2518              while ( (msg_ptr = osal_msg_receive( bdb_TaskID )) )
   2519              {
   2520                //Process the Incomming ZDO messages used by BDB commissioning methods
   2521                if(((bdbInMsg_t*)msg_ptr)->hdr.event == BDB_ZDO_CB_MSG)
   2522                {
   2523                  bdb_processZDOMgs((zdoIncomingMsg_t *)msg_ptr);
   2524                }
   2525                
   2526                //Validate the is receive on the right process
   2527                else if(((bdbInMsg_t*)msg_ptr)->hdr.event == bdbCommissioningProcedureState.bdbCommissioningState)
   2528                {
   2529                  bdb_ProcessOSALMsg( (bdbInMsg_t *)msg_ptr );
   2530                }
   2531                //Notify the user
   2532                else if(((bdbInMsg_t*)msg_ptr)->hdr.event == BDB_NOTIFY_USER)
   2533                {
   2534                  ((bdbCommissioningModeMsg_t*) ((bdbInMsg_t*)msg_ptr)->buf)->bdbRemainingCommissioningModes = bdbAttributes.bdbCommissioningMode;
   2535                  if(pfnCommissioningStatusCB)
   2536                  {
   2537                    pfnCommissioningStatusCB((bdbCommissioningModeMsg_t*) (((bdbInMsg_t*)msg_ptr)->buf));
   2538                  }
   2539          #ifdef MT_APP_CNF_FUNC
   2540                  //Notify the host processor about the event
   2541                  MT_AppCnfCommissioningNotification((bdbCommissioningModeMsg_t*) (((bdbInMsg_t*)msg_ptr)->buf));
   2542          #endif
   2543                }
   2544          #if (ZG_BUILD_COORDINATOR_TYPE)
   2545                else
   2546                {
   2547                  if(ZG_DEVICE_COORDINATOR_TYPE)
   2548                  {
   2549                    //Notify the status 
   2550                    if(((bdbInMsg_t*)msg_ptr)->hdr.event == BDB_TC_LINK_KEY_EXCHANGE_PROCESS)
   2551                    {
   2552                      pfnTCLinkKeyExchangeProcessCB( (bdb_TCLinkKeyExchProcess_t*) ((bdbInMsg_t*)msg_ptr)->buf);
   2553                    }
   2554                  }
   2555                }
   2556          #endif
   2557                // Release the memory
   2558                osal_msg_deallocate( msg_ptr );
   2559              }
   2560          
   2561              // Return unprocessed events
   2562              return (events ^ SYS_EVENT_MSG);
   2563            }
   2564            
   2565          
   2566            if(events & BDB_PROCESS_TIMEOUT)
   \   00005F   EF           MOV       A,R7
   \   000060   5410         ANL       A,#0x10
   \   000062   7003         JNZ       $+5
   \   000064   02....       LJMP      ??bdb_event_loop_7 & 0xFFFF
   2567            {
   2568              bdb_processTimeout();
   2569              // Return unprocessed events
   2570              return (events ^ BDB_PROCESS_TIMEOUT);
   \   000067   EF           MOV       A,R7
   \   000068   6410         XRL       A,#0x10
   \   00006A   02....       LJMP      ??bdb_event_loop_8 & 0xFFFF
   2571            }
   \                     ??bdb_event_loop_9:
   \   00006D   7409         MOV       A,#0x9
   \   00006F   68           XRL       A,R0
   \   000070   700C         JNZ       ??bdb_event_loop_10
   \   000072                ; Setup parameters for indirect call
   \   000072   90....       MOV       DPTR,#pfnTCLinkKeyExchangeProcessCB
   \   000075   E0           MOVX      A,@DPTR
   \   000076   F8           MOV       R0,A
   \   000077   A3           INC       DPTR
   \                     ??bdb_event_loop_11:
   \   000078   12....       LCALL     ??Subroutine48_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_80:
   \   00007B   12....       LCALL     ?CALL_IND
   \                     ??bdb_event_loop_10:
   \   00007E                ; Setup parameters for call to function osal_msg_deallocate
   \   00007E   AA..         MOV       R2,?V0
   \   000080   AB..         MOV       R3,?V1
   \   000082   12....       LCALL     `??osal_msg_deallocate::?relay`; Banked call to: osal_msg_deallocate
   \                     ??bdb_event_loop_6:
   \   000085                ; Setup parameters for call to function osal_msg_receive
   \   000085   90....       MOV       DPTR,#bdb_TaskID
   \   000088   E0           MOVX      A,@DPTR
   \   000089   F9           MOV       R1,A
   \   00008A   12....       LCALL     `??osal_msg_receive::?relay`; Banked call to: osal_msg_receive
   \   00008D   8A..         MOV       ?V0,R2
   \   00008F   8B..         MOV       ?V1,R3
   \   000091   EA           MOV       A,R2
   \   000092   45..         ORL       A,?V1
   \   000094   6066         JZ        ??bdb_event_loop_12
   \   000096   8A82         MOV       DPL,R2
   \   000098   8B83         MOV       DPH,R3
   \   00009A   E0           MOVX      A,@DPTR
   \   00009B   F8           MOV       R0,A
   \   00009C   74D3         MOV       A,#-0x2d
   \   00009E   68           XRL       A,R0
   \   00009F   702D         JNZ       ??bdb_event_loop_13
   \   0000A1   EA           MOV       A,R2
   \   0000A2   240C         ADD       A,#0xc
   \   0000A4   F582         MOV       DPL,A
   \   0000A6   E4           CLR       A
   \   0000A7   35..         ADDC      A,?V1
   \   0000A9   F583         MOV       DPH,A
   \   0000AB   E0           MOVX      A,@DPTR
   \   0000AC   F5..         MOV       ?V2,A
   \   0000AE   A3           INC       DPTR
   \   0000AF   E0           MOVX      A,@DPTR
   \   0000B0   F5..         MOV       ?V3,A
   \   0000B2   78..         MOV       R0,#?V2
   \   0000B4   12....       LCALL     ?US_SWITCH_DENSE
   \                     `?<Jumptable for bdb_event_loop>_0`:
   \   0000B7   0180         DW        32769
   \   0000B9   03           DB        3
   \   0000BA   ....         DW        ??bdb_event_loop_10
   \   0000BC   ....         DW        ??bdb_event_loop_14
   \   0000BE   ....         DW        ??bdb_event_loop_10
   \   0000C0   ....         DW        ??bdb_event_loop_10
   \   0000C2   ....         DW        ??bdb_event_loop_15
   \                     ??bdb_event_loop_15:
   \   0000C4                ; Setup parameters for call to function bdb_ProcessSimpleDesc
   \   0000C4   12....       LCALL     `??bdb_ProcessSimpleDesc::?relay`; Banked call to: bdb_ProcessSimpleDesc
   \   0000C7   80B5         SJMP      ??bdb_event_loop_10
   \                     ??bdb_event_loop_14:
   \   0000C9                ; Setup parameters for call to function bdb_ProcessIEEEAddrRsp
   \   0000C9   12....       LCALL     `??bdb_ProcessIEEEAddrRsp::?relay`; Banked call to: bdb_ProcessIEEEAddrRsp
   \   0000CC   80B0         SJMP      ??bdb_event_loop_10
   \                     ??bdb_event_loop_13:
   \   0000CE   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   0000D1   E0           MOVX      A,@DPTR
   \   0000D2   68           XRL       A,R0
   \   0000D3   60A9         JZ        ??bdb_event_loop_10
   \   0000D5   EA           MOV       A,R2
   \   0000D6   2402         ADD       A,#0x2
   \   0000D8   FA           MOV       R2,A
   \   0000D9   E4           CLR       A
   \   0000DA   35..         ADDC      A,?V1
   \   0000DC   FB           MOV       R3,A
   \   0000DD   740A         MOV       A,#0xa
   \   0000DF   68           XRL       A,R0
   \   0000E0   708B         JNZ       ??bdb_event_loop_9
   \   0000E2   90....       MOV       DPTR,#bdbAttributes + 11
   \   0000E5   E0           MOVX      A,@DPTR
   \   0000E6   85..82       MOV       DPL,?V0
   \   0000E9   85..83       MOV       DPH,?V1
   \   0000EC   A3           INC       DPTR
   \   0000ED   A3           INC       DPTR
   \   0000EE   A3           INC       DPTR
   \   0000EF   A3           INC       DPTR
   \   0000F0   F0           MOVX      @DPTR,A
   \   0000F1   90....       MOV       DPTR,#pfnCommissioningStatusCB
   \   0000F4   12....       LCALL     ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_63:
   \   0000F7   6085         JZ        ??bdb_event_loop_10
   \   0000F9                ; Setup parameters for indirect call
   \   0000F9   02....       LJMP      ??bdb_event_loop_11 & 0xFFFF
   \                     ??bdb_event_loop_12:
   \   0000FC   EE           MOV       A,R6
   \   0000FD   FA           MOV       R2,A
   \   0000FE   EF           MOV       A,R7
   \   0000FF   6480         XRL       A,#0x80
   \   000101   02....       LJMP      ??bdb_event_loop_8 & 0xFFFF
   2572            
   2573            if(events &  BDB_REPORT_TIMEOUT){
   \                     ??bdb_event_loop_7:
   \   000104   EE           MOV       A,R6
   \   000105   5480         ANL       A,#0x80
   \   000107   6007         JZ        ??bdb_event_loop_16
   2574          #ifdef BDB_REPORTING    
   2575              bdb_RepProcessEvent();
   2576          #endif
   2577              // Return unprocessed events
   2578              return (events ^ BDB_REPORT_TIMEOUT);
   \   000109   EE           MOV       A,R6
   \   00010A   6480         XRL       A,#0x80
   \   00010C   FA           MOV       R2,A
   \   00010D   02....       LJMP      ??bdb_event_loop_17 & 0xFFFF
   2579            }
   2580            
   2581          #if (ZG_BUILD_JOINING_TYPE)
   2582            if(events & BDB_TC_LINK_KEY_EXCHANGE_FAIL)
   2583            {
   2584              if(ZG_DEVICE_JOINING_TYPE)
   2585              {
   2586                NLME_LeaveReq_t leaveReq;
   2587                // Set every field to 0
   2588                osal_memset( &leaveReq, 0, sizeof( NLME_LeaveReq_t ) );
   2589                
   2590                bdb_setNodeIsOnANetwork(FALSE);
   2591          
   2592                if ( NLME_LeaveReq( &leaveReq ) != ZSuccess )
   2593                {
   2594                  osal_set_event( bdb_TaskID,BDB_TC_LINK_KEY_EXCHANGE_FAIL);
   2595                }
   2596              }
   2597              // Return unprocessed events
   2598              return (events ^ BDB_TC_LINK_KEY_EXCHANGE_FAIL);
   2599            }
   2600          #endif
   2601            
   2602            if(events & BDB_TC_JOIN_TIMEOUT)
   \                     ??bdb_event_loop_16:
   \   000110   EF           MOV       A,R7
   \   000111   5408         ANL       A,#0x8
   \   000113   600B         JZ        ??bdb_event_loop_18
   2603            {     
   2604          #if (ZG_BUILD_COORDINATOR_TYPE)
   2605              if(ZG_DEVICE_COORDINATOR_TYPE)
   2606              {
   2607                bdb_TCProcessJoiningList();
   \   000115                ; Setup parameters for call to function bdb_TCProcessJoiningList
   \   000115   12....       LCALL     `??bdb_TCProcessJoiningList::?relay`; Banked call to: bdb_TCProcessJoiningList
   2608              }
   2609          #endif    
   2610              return (events ^ BDB_TC_JOIN_TIMEOUT);
   \   000118   EE           MOV       A,R6
   \   000119   FA           MOV       R2,A
   \   00011A   EF           MOV       A,R7
   \   00011B   6408         XRL       A,#0x8
   \   00011D   02....       LJMP      ??bdb_event_loop_8 & 0xFFFF
   2611            }
   2612          
   2613          #if (BDB_FINDING_BINDING_CAPABILITY_ENABLED==1)  
   2614            
   2615            if(events & BDB_FINDING_AND_BINDING_PERIOD_TIMEOUT)
   \                     ??bdb_event_loop_18:
   \   000120   EE           MOV       A,R6
   \   000121   5440         ANL       A,#0x40
   \   000123   607C         JZ        ??bdb_event_loop_19
   2616            {
   2617              /**
   2618               * JC NOTES: In this block, the device just sent a Identify Query but there is timeout waiting for the reply.
   2619               * If FINDING_AND_BINDING_PERIODIC_ENABLE is set True, the device will try again to send Identify Query and wait for reply.
   2620              **/ 
   2621              if ( FINDING_AND_BINDING_PERIODIC_ENABLE == TRUE )
   2622              {
   2623                bdb_CurrEpDescriptor = bdb_setEpDescListToActiveEndpoint();
   \   000125                ; Setup parameters for call to function bdb_setEpDescListToActiveEndpoint
   \   000125   12....       LCALL     `??bdb_setEpDescListToActiveEndpoint::?relay`; Banked call to: bdb_setEpDescListToActiveEndpoint
   \   000128   8A..         MOV       ?V0,R2
   \   00012A   8B..         MOV       ?V1,R3
   2624                
   2625                //If we have endpoint from which to send the identify command, then proceed, otherwise finish
   2626                if(bdb_CurrEpDescriptor != NULL) //just a safty check. The fact that we got to this functuon at all means that this cannot be NULL
   \   00012C   EA           MOV       A,R2
   \   00012D   45..         ORL       A,?V1
   \   00012F   605D         JZ        ??bdb_event_loop_20
   2627                {
   2628                  //Substract an attempt
   2629                  bdb_FB_InitiatorCurrentCyclesNumber--;
   2630                  
   2631                  if(bdb_FB_InitiatorCurrentCyclesNumber > 0)
   \   000131   90....       MOV       DPTR,#bdb_FB_InitiatorCurrentCyclesNumber
   \   000134   E0           MOVX      A,@DPTR
   \   000135   14           DEC       A
   \   000136   F0           MOVX      @DPTR,A
   \   000137   605B         JZ        ??bdb_event_loop_21
   2632                  {
   2633                    //Only send Identify Query if there is no pending responses from a previous identify query
   2634                    if(bdb_getRespondentRetry(pRespondentHead) != NULL)
   \   000139                ; Setup parameters for call to function bdb_getRespondentRetry
   \   000139   12....       LCALL     ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_97:
   \   00013C   12....       LCALL     `??bdb_getRespondentRetry::?relay`; Banked call to: bdb_getRespondentRetry
   \   00013F   8B..         MOV       ?V3,R3
   \   000141   EA           MOV       A,R2
   \   000142   45..         ORL       A,?V3
   \   000144   6007         JZ        ??bdb_event_loop_22
   2635                    {
   2636                      printf("[BDB.c:2634] Good news! there are Identify Query Response detected!\n");
   \   000146                ; Setup parameters for call to function printf
   \   000146   7A..         MOV       R2,#`?<Constant "[BDB.c:2634] Good new...">` & 0xff
   \   000148   7B..         MOV       R3,#(`?<Constant "[BDB.c:2634] Good new...">` >> 8) & 0xff
   \   00014A   12....       LCALL     `??printf::?relay`; Banked call to: printf
   2637                    }
   2638                    if ((osal_get_timeoutEx(bdb_TaskID, BDB_RESPONDENT_PROCESS_TIMEOUT) == 0) && (bdb_getRespondentRetry(pRespondentHead) == NULL))
   \                     ??bdb_event_loop_22:
   \   00014D                ; Setup parameters for call to function osal_get_timeoutEx
   \   00014D   7A00         MOV       R2,#0x0
   \   00014F   7B40         MOV       R3,#0x40
   \   000151   90....       MOV       DPTR,#bdb_TaskID
   \   000154   E0           MOVX      A,@DPTR
   \   000155   F9           MOV       R1,A
   \   000156   12....       LCALL     `??osal_get_timeoutEx::?relay`; Banked call to: osal_get_timeoutEx
   \   000159   EA           MOV       A,R2
   \   00015A   4B           ORL       A,R3
   \   00015B   4C           ORL       A,R4
   \   00015C   4D           ORL       A,R5
   \   00015D   7018         JNZ       ??bdb_event_loop_23
   \   00015F                ; Setup parameters for call to function bdb_getRespondentRetry
   \   00015F   12....       LCALL     ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_98:
   \   000162   12....       LCALL     `??bdb_getRespondentRetry::?relay`; Banked call to: bdb_getRespondentRetry
   \   000165   8B..         MOV       ?V3,R3
   \   000167   EA           MOV       A,R2
   \   000168   45..         ORL       A,?V3
   \   00016A   700B         JNZ       ??bdb_event_loop_23
   2639                    {
   2640                      //Send identify query with the endpoint requested
   2641                      bdb_SendIdentifyQuery(bdb_CurrEpDescriptor->endPoint);
   \   00016C                ; Setup parameters for call to function bdb_SendIdentifyQuery
   \   00016C   85..82       MOV       DPL,?V0
   \   00016F   85..83       MOV       DPH,?V1
   \   000172   E0           MOVX      A,@DPTR
   \   000173   F9           MOV       R1,A
   \   000174   12....       LCALL     `??bdb_SendIdentifyQuery::?relay`; Banked call to: bdb_SendIdentifyQuery
   2642                    }
   2643                    osal_start_timerEx(bdb_TaskID, BDB_FINDING_AND_BINDING_PERIOD_TIMEOUT, FINDING_AND_BINDING_PERIODIC_TIME * 1000);
   \                     ??bdb_event_loop_23:
   \   000177                ; Setup parameters for call to function osal_start_timerEx
   \   000177   90....       MOV       DPTR,#__Constant_3a98
   \   00017A   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   00017D   7A40         MOV       R2,#0x40
   \   00017F   7B00         MOV       R3,#0x0
   \   000181   90....       MOV       DPTR,#bdb_TaskID
   \   000184   E0           MOVX      A,@DPTR
   \   000185   F9           MOV       R1,A
   \   000186   12....       LCALL     `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   000189   7404         MOV       A,#0x4
   \   00018B   12....       LCALL     ?DEALLOC_XSTACK8
   2644                  }
   2645                }
   2646              }
   2647          
   2648              if (bdb_FB_InitiatorCurrentCyclesNumber == 0)
   \                     ??bdb_event_loop_20:
   \   00018E   90....       MOV       DPTR,#bdb_FB_InitiatorCurrentCyclesNumber
   \   000191   E0           MOVX      A,@DPTR
   \   000192   7005         JNZ       ??bdb_event_loop_24
   2649              {
   2650                bdb_exitFindingBindingWStatus( BDB_COMMISSIONING_FB_NO_IDENTIFY_QUERY_RESPONSE );
   \                     ??bdb_event_loop_21:
   \   000194                ; Setup parameters for call to function bdb_exitFindingBindingWStatus
   \   000194   790B         MOV       R1,#0xb
   \   000196   12....       LCALL     `??bdb_exitFindingBindingWStatus::?relay`; Banked call to: bdb_exitFindingBindingWStatus
   2651              }
   2652              
   2653              return (events ^ BDB_FINDING_AND_BINDING_PERIOD_TIMEOUT);
   \                     ??bdb_event_loop_24:
   \   000199   EE           MOV       A,R6
   \   00019A   6440         XRL       A,#0x40
   \                     ??bdb_event_loop_5:
   \   00019C   FA           MOV       R2,A
   \   00019D   EF           MOV       A,R7
   \   00019E   02....       LJMP      ??bdb_event_loop_8 & 0xFFFF
   2654            }
   2655            
   2656            if(events & BDB_IDENTIFY_TIMEOUT)
   \                     ??bdb_event_loop_19:
   \   0001A1   EF           MOV       A,R7
   \   0001A2   5420         ANL       A,#0x20
   \   0001A4   7003         JNZ       $+5
   \   0001A6   02....       LJMP      ??bdb_event_loop_25 & 0xFFFF
   2657            {
   2658              zclAttrRec_t identifyAttrRec;
   2659              epList_t *bdb_CurrEpDescriptorNextInList = NULL;
   2660              bdb_CurrEpDescriptorNextInList = bdb_HeadEpDescriptorList;
   \   0001A9   90....       MOV       DPTR,#bdb_HeadEpDescriptorList
   \   0001AC   12....       LCALL     ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_68:
   \   0001AF   88..         MOV       ?V0,R0
   \   0001B1   89..         MOV       ?V1,R1
   2661              
   2662              bool KeepIdentifyTimerRunning = FALSE;
   \   0001B3   75..00       MOV       ?V2,#0x0
   \   0001B6   8024         SJMP      ??CrossCallReturnLabel_30
   2663              
   2664              while(bdb_CurrEpDescriptorNextInList != NULL )
   2665              {
   2666                endPointDesc_t *bdb_EpDescriptor = NULL;
   2667                bdb_EpDescriptor = bdb_CurrEpDescriptorNextInList->epDesc;
   2668              
   2669                //Do not check ZDO or Zigbee reserved endpoints
   2670                if((bdb_CurrEpDescriptorList->epDesc->endPoint == 0) || (bdb_CurrEpDescriptorList->epDesc->endPoint >= BDB_ZIGBEE_RESERVED_ENDPOINTS_START))
   2671                {
   2672                  bdb_CurrEpDescriptorNextInList = bdb_CurrEpDescriptorNextInList->nextDesc;
   2673                  continue;
   2674                }
   2675                
   2676                if ( zclFindAttrRec( bdb_EpDescriptor->endPoint, ZCL_CLUSTER_ID_GEN_IDENTIFY,
   2677                                  ATTRID_IDENTIFY_TIME, &identifyAttrRec ) )
   2678                {
   2679                  if(*((uint16*)identifyAttrRec.attr.dataPtr) > 0)
   2680                  {
   2681                    (uint16)(*((uint16*)identifyAttrRec.attr.dataPtr))--;
   2682                    KeepIdentifyTimerRunning = TRUE;
   2683                  }
   2684                  else
   2685                  {
   2686                    // Use bdb success main state
   2687                    bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_SUCCESS;
   \                     ??bdb_event_loop_26:
   \   0001B8   90....       MOV       DPTR,#bdbAttributes + 10
   \   0001BB   E4           CLR       A
   \   0001BC   F0           MOVX      @DPTR,A
   2688                    if(pfnIdentifyTimeChangeCB != NULL)
   \   0001BD   90....       MOV       DPTR,#pfnIdentifyTimeChangeCB
   \   0001C0   12....       LCALL     ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   0001C3   600E         JZ        ??bdb_event_loop_27
   2689                    {
   2690                      pfnIdentifyTimeChangeCB(bdb_EpDescriptor->endPoint);
   \   0001C5                ; Setup parameters for indirect call
   \   0001C5   85..82       MOV       DPL,?V6
   \   0001C8   85..83       MOV       DPH,?V7
   \   0001CB   E0           MOVX      A,@DPTR
   \   0001CC   F9           MOV       R1,A
   \   0001CD   12....       LCALL     ?Subroutine26 & 0xFFFF
   2691                    }
   2692                  }
   \                     ??CrossCallReturnLabel_83:
   \   0001D0   12....       LCALL     ?CALL_IND
   2693                }
   2694                bdb_CurrEpDescriptorNextInList = bdb_CurrEpDescriptorNextInList->nextDesc;
   \                     ??bdb_event_loop_27:
   \   0001D3   85..82       MOV       DPL,?V0
   \   0001D6   85..83       MOV       DPH,?V1
   \   0001D9   12....       LCALL     ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   0001DC   E5..         MOV       A,?V0
   \   0001DE   45..         ORL       A,?V1
   \   0001E0   6065         JZ        ??bdb_event_loop_28
   \   0001E2   85..82       MOV       DPL,?V0
   \   0001E5   85..83       MOV       DPH,?V1
   \   0001E8   A3           INC       DPTR
   \   0001E9   A3           INC       DPTR
   \   0001EA   12....       LCALL     ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   0001ED   88..         MOV       ?V6,R0
   \   0001EF   89..         MOV       ?V7,R1
   \   0001F1   12....       LCALL     ?Subroutine20 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   0001F4   E0           MOVX      A,@DPTR
   \   0001F5   60DC         JZ        ??bdb_event_loop_27
   \   0001F7   C3           CLR       C
   \   0001F8   94F1         SUBB      A,#-0xf
   \   0001FA   50D7         JNC       ??bdb_event_loop_27
   \   0001FC                ; Setup parameters for call to function zclFindAttrRec
   \   0001FC   A8..         MOV       R0,?XSP + 0
   \   0001FE   A9..         MOV       R1,?XSP + 1
   \   000200   88..         MOV       ?V4,R0
   \   000202   89..         MOV       ?V5,R1
   \   000204   78..         MOV       R0,#?V4
   \   000206   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000209   7C00         MOV       R4,#0x0
   \   00020B   7D00         MOV       R5,#0x0
   \   00020D   7A03         MOV       R2,#0x3
   \   00020F   7B00         MOV       R3,#0x0
   \   000211   85..82       MOV       DPL,?V6
   \   000214   85..83       MOV       DPH,?V7
   \   000217   E0           MOVX      A,@DPTR
   \   000218   F9           MOV       R1,A
   \   000219   12....       LCALL     `??zclFindAttrRec::?relay`; Banked call to: zclFindAttrRec
   \   00021C   7402         MOV       A,#0x2
   \   00021E   12....       LCALL     ?DEALLOC_XSTACK8
   \   000221   E9           MOV       A,R1
   \   000222   60AF         JZ        ??bdb_event_loop_27
   \   000224   7406         MOV       A,#0x6
   \   000226   12....       LCALL     ?XSTACK_DISP0_8
   \   000229   12....       LCALL     ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_27:
   \   00022C   12....       LCALL     ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   00022F   6087         JZ        ??bdb_event_loop_26
   \   000231   EA           MOV       A,R2
   \   000232   24FF         ADD       A,#-0x1
   \   000234   1A           DEC       R2
   \   000235   EB           MOV       A,R3
   \   000236   34FF         ADDC      A,#-0x1
   \   000238   FB           MOV       R3,A
   \   000239   8882         MOV       DPL,R0
   \   00023B   8983         MOV       DPH,R1
   \   00023D   EA           MOV       A,R2
   \   00023E   F0           MOVX      @DPTR,A
   \   00023F   A3           INC       DPTR
   \   000240   EB           MOV       A,R3
   \   000241   F0           MOVX      @DPTR,A
   \   000242   75..01       MOV       ?V2,#0x1
   \   000245   808C         SJMP      ??bdb_event_loop_27
   2695              }
   2696              
   2697              //If any endpoint has identify running, keep the timer on
   2698              if(KeepIdentifyTimerRunning)
   \                     ??bdb_event_loop_28:
   \   000247   E5..         MOV       A,?V2
   \   000249   6019         JZ        ??bdb_event_loop_29
   2699              {
   2700                osal_start_timerEx( bdb_TaskID, BDB_IDENTIFY_TIMEOUT, 1000 );
   \   00024B                ; Setup parameters for call to function osal_start_timerEx
   \   00024B   90....       MOV       DPTR,#__Constant_3e8
   \   00024E   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   000251   7A00         MOV       R2,#0x0
   \   000253   7B20         MOV       R3,#0x20
   \   000255   90....       MOV       DPTR,#bdb_TaskID
   \   000258   E0           MOVX      A,@DPTR
   \   000259   F9           MOV       R1,A
   \   00025A   12....       LCALL     `??osal_start_timerEx::?relay`; Banked call to: osal_start_timerEx
   \   00025D   7404         MOV       A,#0x4
   \   00025F   12....       LCALL     ?DEALLOC_XSTACK8
   \   000262   800C         SJMP      ??bdb_event_loop_30
   2701              }
   2702              else
   2703              {
   2704                osal_stop_timerEx( bdb_TaskID, BDB_IDENTIFY_TIMEOUT );
   \                     ??bdb_event_loop_29:
   \   000264                ; Setup parameters for call to function osal_stop_timerEx
   \   000264   7A00         MOV       R2,#0x0
   \   000266   7B20         MOV       R3,#0x20
   \   000268   90....       MOV       DPTR,#bdb_TaskID
   \   00026B   E0           MOVX      A,@DPTR
   \   00026C   F9           MOV       R1,A
   \   00026D   12....       LCALL     `??osal_stop_timerEx::?relay`; Banked call to: osal_stop_timerEx
   2705              }
   2706              
   2707              // Return unprocessed events
   2708              return (events ^ BDB_IDENTIFY_TIMEOUT);
   \                     ??bdb_event_loop_30:
   \   000270   EE           MOV       A,R6
   \   000271   FA           MOV       R2,A
   \   000272   EF           MOV       A,R7
   \   000273   6420         XRL       A,#0x20
   \   000275   800D         SJMP      ??bdb_event_loop_8
   2709            }
   2710            
   2711            if(events & BDB_RESPONDENT_PROCESS_TIMEOUT)
   \                     ??bdb_event_loop_25:
   \   000277   EF           MOV       A,R7
   \   000278   5440         ANL       A,#0x40
   \   00027A   600B         JZ        ??bdb_event_loop_31
   2712            {
   2713              // Send Simple Descriptor request to a respondent node
   2714              /**
   2715               * JC NOTES: The BDB_RESPONDENT_PROCESS_TIMEOUT is generated when IDENTIFY_QUERY_RSP_TIMEOUT (bdb_FindingAndBinding.c: 882)
   2716              **/
   2717              bdb_ProcessRespondentList();
   \   00027C                ; Setup parameters for call to function bdb_ProcessRespondentList
   \   00027C   12....       LCALL     `??bdb_ProcessRespondentList::?relay`; Banked call to: bdb_ProcessRespondentList
   2718          
   2719              return (events ^ BDB_RESPONDENT_PROCESS_TIMEOUT);
   \   00027F   EE           MOV       A,R6
   \   000280   FA           MOV       R2,A
   \   000281   EF           MOV       A,R7
   \   000282   6440         XRL       A,#0x40
   \                     ??bdb_event_loop_8:
   \   000284   FB           MOV       R3,A
   \   000285   8004         SJMP      ??bdb_event_loop_17
   2720            }
   2721          #endif
   2722            
   2723            return 0;
   \                     ??bdb_event_loop_31:
   \   000287   7A00         MOV       R2,#0x0
   \   000289   7B00         MOV       R3,#0x0
   \                     ??bdb_event_loop_17:
   \   00028B   7408         MOV       A,#0x8
   \   00028D   02....       LJMP      ?Subroutine6 & 0xFFFF
   2724          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F5..         MOV       ?V0,A
   \   000003   A3           INC       DPTR
   \   000004   E0           MOVX      A,@DPTR
   \   000005   F5..         MOV       ?V1,A
   \   000007   22           RET
   2725          
   2726          /*********************************************************************
   2727           * @fn          bdb_processZDOMgs
   2728           *
   2729           * @brief       Process ZDO messages used as part of BDB commissioning methods
   2730           *
   2731           * @param       zdoIncomingMsg_t - ZDO message
   2732           *
   2733           * @return      
   2734           */
   2735          static void bdb_processZDOMgs(zdoIncomingMsg_t *pMsg)
   2736          {
   2737            switch ( pMsg->clusterID )
   2738            {
   2739          #if (BDB_FINDING_BINDING_CAPABILITY_ENABLED==1)      
   2740              case IEEE_addr_rsp:
   2741                 bdb_ProcessIEEEAddrRsp(pMsg);
   2742              break;
   2743              case Simple_Desc_rsp:
   2744                bdb_ProcessSimpleDesc(pMsg);
   2745              break;
   2746          #endif
   2747          
   2748          #if (ZG_BUILD_JOINING_TYPE)    
   2749              case Node_Desc_rsp:
   2750                bdb_ProcessNodeDescRsp(pMsg);
   2751              break;
   2752          #endif
   2753              
   2754              default:
   2755              break;
   2756            }
   2757          }
   2758          
   2759          
   2760          /*********************************************************************
   2761           * @fn      bdb_ProcessNodeDescRsp
   2762           *
   2763           * @brief   Process Node Descriptor response to validate the stack version of the
   2764           *
   2765           * @param   zdoIncomingMsg_t *pMsg
   2766           *
   2767           * @return  none
   2768           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2769          void bdb_ProcessNodeDescRsp(zdoIncomingMsg_t *pMsg)
   \                     bdb_ProcessNodeDescRsp:
   2770          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 35
   \   000005   74DD         MOV       A,#-0x23
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
   2771            //Avoid processing unintended messages
   2772            if(requestNewTrustCenterLinkKey && 
   2773              (bdbCommissioningProcedureState.bdbCommissioningState == BDB_COMMISSIONING_STATE_TC_LINK_KEY_EXCHANGE))
   \   00000E   90....       MOV       DPTR,#requestNewTrustCenterLinkKey
   \   000011   E0           MOVX      A,@DPTR
   \   000012   7003         JNZ       $+5
   \   000014   02....       LJMP      ??bdb_ProcessNodeDescRsp_0 & 0xFFFF
   \   000017   90....       MOV       DPTR,#bdbCommissioningProcedureState
   \   00001A   E0           MOVX      A,@DPTR
   \   00001B   6401         XRL       A,#0x1
   \   00001D   6003         JZ        $+5
   \   00001F   02....       LJMP      ??bdb_ProcessNodeDescRsp_0 & 0xFFFF
   2774            {
   2775              if(!APSME_IsDistributedSecurity())
   \   000022                ; Setup parameters for call to function APSME_IsDistributedSecurity
   \   000022   12....       LCALL     `??APSME_IsDistributedSecurity::?relay`; Banked call to: APSME_IsDistributedSecurity
   \   000025   E9           MOV       A,R1
   \   000026   6003         JZ        $+5
   \   000028   02....       LJMP      ??bdb_ProcessNodeDescRsp_0 & 0xFFFF
   2776              {
   2777                //Is this from the coordinator?
   2778                if(pMsg->srcAddr.addr.shortAddr == 0x0000)
   \   00002B   8E82         MOV       DPL,R6
   \   00002D   8F83         MOV       DPH,R7
   \   00002F   A3           INC       DPTR
   \   000030   A3           INC       DPTR
   \   000031   12....       LCALL     ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   000034   7077         JNZ       ??bdb_ProcessNodeDescRsp_0
   2779                {
   2780                  ZDO_NodeDescRsp_t NDRsp;
   2781                  uint8 StackComplianceRev;
   2782          
   2783                  //Stop timer to avoid unintended resets
   2784                  osal_stop_timerEx( bdb_TaskID, BDB_PROCESS_TIMEOUT);
   \   000036                ; Setup parameters for call to function osal_stop_timerEx
   \   000036   7A00         MOV       R2,#0x0
   \   000038   7B10         MOV       R3,#0x10
   \   00003A   90....       MOV       DPTR,#bdb_TaskID
   \   00003D   E0           MOVX      A,@DPTR
   \   00003E   F9           MOV       R1,A
   \   00003F   12....       LCALL     `??osal_stop_timerEx::?relay`; Banked call to: osal_stop_timerEx
   2785                  
   2786                  ZDO_ParseNodeDescRsp(pMsg, &NDRsp);
   \   000042                ; Setup parameters for call to function ZDO_ParseNodeDescRsp
   \   000042   7413         MOV       A,#0x13
   \   000044   12....       LCALL     ?XSTACK_DISP102_8
   \   000047   EE           MOV       A,R6
   \   000048   FA           MOV       R2,A
   \   000049   EF           MOV       A,R7
   \   00004A   FB           MOV       R3,A
   \   00004B   12....       LCALL     `??ZDO_ParseNodeDescRsp::?relay`; Banked call to: ZDO_ParseNodeDescRsp
   2787                  
   2788                  StackComplianceRev = NDRsp.nodeDesc.ServerMask >> STACK_COMPLIANCE_CURRENT_REV_POS;
   2789                  
   2790                  if( StackComplianceRev >= STACK_COMPL_REV_21 )
   \   00004E   741E         MOV       A,#0x1e
   \   000050   12....       LCALL     ?XSTACK_DISP0_8
   \   000053   12....       LCALL     ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   000056   7409         MOV       A,#0x9
   \   000058   78..         MOV       R0,#?V0
   \   00005A   12....       LCALL     ?US_SHR
   \   00005D   C3           CLR       C
   \   00005E   E5..         MOV       A,?V0
   \   000060   9415         SUBB      A,#0x15
   \   000062   95E0         SUBB      A,0xE0 /* A   */
   \   000064   C3           CLR       C
   \   000065   65D0         XRL       A,PSW
   \   000067   33           RLC       A
   \   000068   4009         JC        ??bdb_ProcessNodeDescRsp_1
   2791                  {
   2792                    bdb_tcLinkKeyExchangeAttempt(TRUE,BDB_REQ_TC_LINK_KEY);
   \   00006A                ; Setup parameters for call to function bdb_tcLinkKeyExchangeAttempt
   \   00006A   7A02         MOV       R2,#0x2
   \   00006C   7901         MOV       R1,#0x1
   \   00006E   12....       LCALL     `??bdb_tcLinkKeyExchangeAttempt::?relay`; Banked call to: bdb_tcLinkKeyExchangeAttempt
   \   000071   803A         SJMP      ??bdb_ProcessNodeDescRsp_0
   2793                  }
   2794                  else
   2795                  {
   2796                    APSME_TCLKDevEntry_t TCLKDevEntry;
   2797                    
   2798                    //Save the KeyAttribute for joining device that it has joined non-R21 nwk
   2799                    TCLKDevEntry.keyAttributes = ZG_NON_R21_NWK_JOINED;
   \                     ??bdb_ProcessNodeDescRsp_1:
   \   000073   7410         MOV       A,#0x10
   \   000075   12....       LCALL     ?XSTACK_DISP0_8
   \   000078   74FD         MOV       A,#-0x3
   \   00007A   F0           MOVX      @DPTR,A
   2800                    osal_nv_write(ZCD_NV_TCLK_TABLE_START,osal_offsetof(APSME_TCLKDevEntry_t,keyAttributes),sizeof(uint8),&TCLKDevEntry.keyAttributes);
   \   00007B                ; Setup parameters for call to function osal_nv_write
   \   00007B   8582..       MOV       ?V0,DPL
   \   00007E   8583..       MOV       ?V1,DPH
   \   000081   78..         MOV       R0,#?V0
   \   000083   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000086   75..01       MOV       ?V0,#0x1
   \   000089   75..00       MOV       ?V1,#0x0
   \   00008C   78..         MOV       R0,#?V0
   \   00008E   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000091   7C10         MOV       R4,#0x10
   \   000093   7D00         MOV       R5,#0x0
   \   000095   7A11         MOV       R2,#0x11
   \   000097   7B01         MOV       R3,#0x1
   \   000099   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   00009C   7404         MOV       A,#0x4
   \   00009E   12....       LCALL     ?DEALLOC_XSTACK8
   2801                    
   2802                    bdb_setNodeJoinLinkKeyType(BDB_DEFAULT_GLOBAL_TRUST_CENTER_LINK_KEY);
   \   0000A1                ; Setup parameters for call to function bdb_setNodeJoinLinkKeyType
   \   0000A1   7900         MOV       R1,#0x0
   \   0000A3   12....       LCALL     `??bdb_setNodeJoinLinkKeyType::?relay`; Banked call to: bdb_setNodeJoinLinkKeyType
   2803                    bdb_reportCommissioningState(BDB_COMMISSIONING_STATE_TC_LINK_KEY_EXCHANGE, TRUE);
   \   0000A6                ; Setup parameters for call to function bdb_reportCommissioningState
   \   0000A6   7A01         MOV       R2,#0x1
   \   0000A8   7901         MOV       R1,#0x1
   \   0000AA   12....       LCALL     `??bdb_reportCommissioningState::?relay`; Banked call to: bdb_reportCommissioningState
   2804                  }
   2805                }
   2806              }
   2807            }
   2808          }
   \                     ??bdb_ProcessNodeDescRsp_0:
   \   0000AD   7423         MOV       A,#0x23
   \   0000AF   02....       LJMP      ?Subroutine1 & 0xFFFF
   2809          
   2810          
   2811          /*********************************************************************
   2812           * @fn          bdb_touchlinkSendFNReset
   2813           *
   2814           * @brief       Starts the Factory New Procedure for Initiator
   2815           *
   2816           * @param       isOnANetwork - TRUE if the devices is not FN, FALSE otherwise
   2817           *
   2818           * @return      none
   2819           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2820          void bdb_touchlinkSendFNReset( void )
   \                     bdb_touchlinkSendFNReset:
   2821          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2822          #ifdef BDB_TL_INITIATOR
   2823            touchLinkInitiator_ResetToFNProcedure( );
   2824          #endif
   2825          }
   \   000000   02....       LJMP      ?BRET
   2826          
   2827          
   2828          /*********************************************************************
   2829           * @fn          bdb_setNodeIsOnANetwork
   2830           *
   2831           * @brief       Sets and saves in Nv bdbNodeIsOnANetwork attribute
   2832           *
   2833           * @param       isOnANetwork - TRUE if the devices is not FN, FALSE otherwise
   2834           *
   2835           * @return      none
   2836           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2837          void bdb_setNodeIsOnANetwork(bool isOnANetwork)
   \                     bdb_setNodeIsOnANetwork:
   2838          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
   2839            if((bdbAttributes.bdbNodeIsOnANetwork != isOnANetwork) || (!bdb_initialization))
   \   000007   90....       MOV       DPTR,#bdbAttributes + 14
   \   00000A   E0           MOVX      A,@DPTR
   \   00000B   6E           XRL       A,R6
   \   00000C   7006         JNZ       ??bdb_setNodeIsOnANetwork_0
   \   00000E   90....       MOV       DPTR,#bdb_initialization
   \   000011   E0           MOVX      A,@DPTR
   \   000012   7033         JNZ       ??bdb_setNodeIsOnANetwork_1
   2840            {
   2841              //We lose our network
   2842              if(!isOnANetwork)
   \                     ??bdb_setNodeIsOnANetwork_0:
   \   000014   EE           MOV       A,R6
   \   000015   7005         JNZ       ??bdb_setNodeIsOnANetwork_2
   2843              {
   2844                bdbAttributes.bdbCommissioningMode = 0;
   \   000017   90....       MOV       DPTR,#bdbAttributes + 11
   \   00001A   E4           CLR       A
   \   00001B   F0           MOVX      @DPTR,A
   2845              }
   2846              
   2847              bdbAttributes.bdbNodeIsOnANetwork = isOnANetwork;
   \                     ??bdb_setNodeIsOnANetwork_2:
   \   00001C   EE           MOV       A,R6
   \   00001D   90....       MOV       DPTR,#bdbAttributes + 14
   \   000020   F0           MOVX      @DPTR,A
   2848              
   2849              osal_nv_write(ZCD_NV_BDBNODEISONANETWORK,0,sizeof(bdbAttributes.bdbNodeIsOnANetwork),&bdbAttributes.bdbNodeIsOnANetwork);
   \   000021                ; Setup parameters for call to function osal_nv_write
   \   000021   75....       MOV       ?V0,#(bdbAttributes + 14) & 0xff
   \   000024   75....       MOV       ?V1,#((bdbAttributes + 14) >> 8) & 0xff
   \   000027   78..         MOV       R0,#?V0
   \   000029   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00002C   75..01       MOV       ?V0,#0x1
   \   00002F   75..00       MOV       ?V1,#0x0
   \   000032   78..         MOV       R0,#?V0
   \   000034   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   000037   7C00         MOV       R4,#0x0
   \   000039   7D00         MOV       R5,#0x0
   \   00003B   7A55         MOV       R2,#0x55
   \   00003D   7B00         MOV       R3,#0x0
   \   00003F   12....       LCALL     `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000042   7404         MOV       A,#0x4
   \   000044   12....       LCALL     ?DEALLOC_XSTACK8
   2850            }
   2851          }
   \                     ??bdb_setNodeIsOnANetwork_1:
   \   000047   02....       LJMP      ??Subroutine37_0 & 0xFFFF
   2852          
   2853          /*********************************************************************
   2854           * @fn          bdb_setCommissioningGroupID
   2855           *
   2856           * @brief       Sets the commissioning groupd ID
   2857           *
   2858           * @param       groupID
   2859           *
   2860           * @return      none
   2861           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   EA           MOV       A,R2
   \   000001   F0           MOVX      @DPTR,A
   \   000002   A3           INC       DPTR
   \   000003   EB           MOV       A,R3
   \   000004                REQUIRE ??Subroutine39_0
   \   000004                ; // Fall through to label ??Subroutine39_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2862          void bdb_setCommissioningGroupID(uint16 groupID)
   \                     bdb_setCommissioningGroupID:
   2863          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2864            bdbAttributes.bdbCommissioningGroupID = groupID;
   \   000004   90....       MOV       DPTR,#bdbAttributes + 8
   \   000007   02....       LJMP      ?Subroutine4 & 0xFFFF
   2865          }
   2866          
   2867          /*********************************************************************
   2868           * @fn      bdb_CreateRespondentList
   2869           *
   2870           * @brief   Create respondent list for finding and binding if empty
   2871           *
   2872           * @param   pHead - pointer to a pointer of the list head
   2873           *
   2874           * @return  none
   2875           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   EA           MOV       A,R2
   \   000001   FE           MOV       R6,A
   \   000002   EB           MOV       A,R3
   \   000003                REQUIRE ??Subroutine44_0
   \   000003                ; // Fall through to label ??Subroutine44_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine44_0:
   \   000000   FF           MOV       R7,A
   \   000001                REQUIRE ??Subroutine45_0
   \   000001                ; // Fall through to label ??Subroutine45_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2876          void bdb_CreateRespondentList( bdbFindingBindingRespondent_t **pHead )
   \                     bdb_CreateRespondentList:
   2877          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL     ?Subroutine17 & 0xFFFF
   2878          
   2879            // Create the list if empty
   2880            if ( *pHead == NULL )
   \                     ??CrossCallReturnLabel_49:
   \   000008   700F         JNZ       ??CrossCallReturnLabel_37
   2881            {
   2882              *pHead = ( bdbFindingBindingRespondent_t* )osal_mem_alloc( sizeof( bdbFindingBindingRespondent_t ) );
   \   00000A                ; Setup parameters for call to function osal_mem_alloc
   \   00000A   7A11         MOV       R2,#0x11
   \   00000C   7B00         MOV       R3,#0x0
   \   00000E   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000011   12....       LCALL     ?Subroutine12 & 0xFFFF
   2883              
   2884              if ( *pHead != NULL )
   \                     ??CrossCallReturnLabel_84:
   \   000014   6003         JZ        ??CrossCallReturnLabel_37
   2885              {
   2886                (*pHead)->pNext = NULL;
   \   000016   12....       LCALL     ?Subroutine30 & 0xFFFF
   2887              }
   2888            }
   2889            return;
   \                     ??CrossCallReturnLabel_37:
   \   000019   02....       LJMP      ??Subroutine37_0 & 0xFFFF
   2890          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   8A..         MOV       ?V0,R2
   \   000002   8B..         MOV       ?V1,R3
   \   000004   A8..         MOV       R0,?V0
   \   000006   A9..         MOV       R1,?V1
   \   000008                REQUIRE ??Subroutine49_0
   \   000008                ; // Fall through to label ??Subroutine49_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   E8           MOV       A,R0
   \   000001   240F         ADD       A,#0xf
   \   000003   F582         MOV       DPL,A
   \   000005   E4           CLR       A
   \   000006   39           ADDC      A,R1
   \   000007   F583         MOV       DPH,A
   \   000009   E4           CLR       A
   \   00000A   F0           MOVX      @DPTR,A
   \   00000B   A3           INC       DPTR
   \   00000C   F0           MOVX      @DPTR,A
   \   00000D   22           RET
   2891          
   2892          /*********************************************************************
   2893           * @fn      bdb_AddRespondentNode
   2894           *
   2895           * @brief   Add node to respondent list for finding and binding
   2896           *
   2897           * @param   pHead - pointer to a pointer of the list head
   2898           *
   2899           * @return  pointer to new node
   2900           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2901          bdbFindingBindingRespondent_t* bdb_AddRespondentNode( bdbFindingBindingRespondent_t **pHead, zclIdentifyQueryRsp_t *pCmd )
   \                     bdb_AddRespondentNode:
   2902          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL     ?Subroutine17 & 0xFFFF
   2903            bdbFindingBindingRespondent_t **pCurr;
   2904            bdbFindingBindingRespondent_t *temp;
   2905            
   2906              // Create respondent list if empty
   2907            if ( *pHead == NULL )
   \                     ??CrossCallReturnLabel_50:
   \   000008   7006         JNZ       ??bdb_AddRespondentNode_0
   2908            {
   2909              bdb_CreateRespondentList( pHead );
   \   00000A                ; Setup parameters for call to function bdb_CreateRespondentList
   \   00000A   12....       LCALL     `??bdb_CreateRespondentList::?relay`; Banked call to: bdb_CreateRespondentList
   2910              return *pHead;
   \   00000D   02....       LJMP      ??CrossCallReturnLabel_38 & 0xFFFF
   2911            }
   2912            else
   2913            {
   2914              // if pCmd is equal to NULL, don't look for duplucates
   2915              if( pCmd != NULL )
   \                     ??bdb_AddRespondentNode_0:
   \   000010   EC           MOV       A,R4
   \   000011   4D           ORL       A,R5
   \   000012   606F         JZ        ??bdb_AddRespondentNode_1
   2916              {
   2917                //Find if any duplicate in the list
   2918                temp = *pHead;
   \   000014   E8           MOV       A,R0
   \   000015   FA           MOV       R2,A
   \   000016   E9           MOV       A,R1
   \   000017   FB           MOV       R3,A
   \   000018   8C82         MOV       DPL,R4
   \   00001A   8D83         MOV       DPH,R5
   \   00001C   E0           MOVX      A,@DPTR
   \   00001D   FC           MOV       R4,A
   \   00001E   A3           INC       DPTR
   \   00001F   E0           MOVX      A,@DPTR
   \   000020   FD           MOV       R5,A
   2919                
   2920                while(temp != NULL)
   2921                {
   2922                  if((temp->data.endPoint == pCmd->srcAddr->endPoint) && (temp->data.panId == pCmd->srcAddr->panId))
   \                     ??bdb_AddRespondentNode_2:
   \   000021   8A82         MOV       DPL,R2
   \   000023   8B83         MOV       DPH,R3
   \   000025   A3           INC       DPTR
   \   000026   A3           INC       DPTR
   \   000027   A3           INC       DPTR
   \   000028   A3           INC       DPTR
   \   000029   A3           INC       DPTR
   \   00002A   A3           INC       DPTR
   \   00002B   A3           INC       DPTR
   \   00002C   A3           INC       DPTR
   \   00002D   A3           INC       DPTR
   \   00002E   E0           MOVX      A,@DPTR
   \   00002F   FE           MOV       R6,A
   \   000030   8C82         MOV       DPL,R4
   \   000032   8D83         MOV       DPH,R5
   \   000034   A3           INC       DPTR
   \   000035   A3           INC       DPTR
   \   000036   A3           INC       DPTR
   \   000037   A3           INC       DPTR
   \   000038   A3           INC       DPTR
   \   000039   A3           INC       DPTR
   \   00003A   A3           INC       DPTR
   \   00003B   A3           INC       DPTR
   \   00003C   A3           INC       DPTR
   \   00003D   E0           MOVX      A,@DPTR
   \   00003E   6E           XRL       A,R6
   \   00003F   7034         JNZ       ??bdb_AddRespondentNode_3
   \   000041   8A82         MOV       DPL,R2
   \   000043   8B83         MOV       DPH,R3
   \   000045   A3           INC       DPTR
   \   000046   A3           INC       DPTR
   \   000047   A3           INC       DPTR
   \   000048   A3           INC       DPTR
   \   000049   A3           INC       DPTR
   \   00004A   A3           INC       DPTR
   \   00004B   A3           INC       DPTR
   \   00004C   A3           INC       DPTR
   \   00004D   A3           INC       DPTR
   \   00004E   A3           INC       DPTR
   \   00004F   12....       LCALL     ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   000052   A3           INC       DPTR
   \   000053   A3           INC       DPTR
   \   000054   A3           INC       DPTR
   \   000055   A3           INC       DPTR
   \   000056   A3           INC       DPTR
   \   000057   A3           INC       DPTR
   \   000058   A3           INC       DPTR
   \   000059   A3           INC       DPTR
   \   00005A   A3           INC       DPTR
   \   00005B   A3           INC       DPTR
   \   00005C   E0           MOVX      A,@DPTR
   \   00005D   6E           XRL       A,R6
   \   00005E   7003         JNZ       ??bdb_AddRespondentNode_4
   \   000060   A3           INC       DPTR
   \   000061   E0           MOVX      A,@DPTR
   \   000062   6F           XRL       A,R7
   \                     ??bdb_AddRespondentNode_4:
   \   000063   7010         JNZ       ??bdb_AddRespondentNode_3
   2923                  {
   2924                    //Duplicate
   2925                    if(temp->data.addr.shortAddr == pCmd->srcAddr->addr.shortAddr)
   \   000065   8A82         MOV       DPL,R2
   \   000067   8B83         MOV       DPH,R3
   \   000069   12....       LCALL     ?Subroutine28 & 0xFFFF
   2926                    {
   2927                      return NULL;
   2928                    }
   2929                  }
   \                     ??CrossCallReturnLabel_34:
   \   00006C   E0           MOVX      A,@DPTR
   \   00006D   6E           XRL       A,R6
   \   00006E   7003         JNZ       ??bdb_AddRespondentNode_5
   \   000070   A3           INC       DPTR
   \   000071   E0           MOVX      A,@DPTR
   \   000072   6F           XRL       A,R7
   \                     ??bdb_AddRespondentNode_5:
   \   000073   6025         JZ        ??bdb_AddRespondentNode_6
   2930                  temp = temp->pNext;
   \                     ??bdb_AddRespondentNode_3:
   \   000075   EA           MOV       A,R2
   \   000076   240F         ADD       A,#0xf
   \   000078   F582         MOV       DPL,A
   \   00007A   E4           CLR       A
   \   00007B   3B           ADDC      A,R3
   \   00007C   F583         MOV       DPH,A
   \   00007E   12....       LCALL     ?Subroutine19 & 0xFFFF
   2931                }
   2932              }
   \                     ??CrossCallReturnLabel_15:
   \   000081   709E         JNZ       ??bdb_AddRespondentNode_2
   2933              
   2934              pCurr = &((*pHead)->pNext);
   2935              
   2936              while ( *pCurr != NULL )
   2937              {
   2938                pCurr = &((*pCurr)->pNext);
   \                     ??bdb_AddRespondentNode_1:
   \   000083   E8           MOV       A,R0
   \   000084   240F         ADD       A,#0xf
   \   000086   FE           MOV       R6,A
   \   000087   E4           CLR       A
   \   000088   39           ADDC      A,R1
   \   000089   12....       LCALL     ??Subroutine44_0 & 0xFFFF
   2939              }
   \                     ??CrossCallReturnLabel_51:
   \   00008C   70F5         JNZ       ??bdb_AddRespondentNode_1
   2940          
   2941              *pCurr = ( bdbFindingBindingRespondent_t* )osal_mem_alloc( sizeof( bdbFindingBindingRespondent_t ) );
   \   00008E                ; Setup parameters for call to function osal_mem_alloc
   \   00008E   7A11         MOV       R2,#0x11
   \   000090   7B00         MOV       R3,#0x0
   \   000092   12....       LCALL     `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000095   12....       LCALL     ?Subroutine12 & 0xFFFF
   2942              
   2943              if(*pCurr == NULL)
   \                     ??CrossCallReturnLabel_85:
   \   000098   7006         JNZ       ??bdb_AddRespondentNode_7
   2944              {
   2945                //No memory
   2946                return NULL;
   \                     ??bdb_AddRespondentNode_6:
   \   00009A   7A00         MOV       R2,#0x0
   \   00009C   7B00         MOV       R3,#0x0
   \   00009E   800A         SJMP      ??CrossCallReturnLabel_94
   2947              }
   2948              
   2949              (*pCurr)->pNext = NULL;
   \                     ??bdb_AddRespondentNode_7:
   \   0000A0   12....       LCALL     ?Subroutine30 & 0xFFFF
   2950            }
   2951            
   2952            return *pCurr;
   \                     ??CrossCallReturnLabel_38:
   \   0000A3   8E82         MOV       DPL,R6
   \   0000A5   8F83         MOV       DPH,R7
   \   0000A7   12....       LCALL     ??Subroutine51_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_94:
   \   0000AA   02....       LJMP      ??Subroutine37_0 & 0xFFFF
   2953          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   12....       LCALL     ??Subroutine50_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_88:
   \   000003   8C82         MOV       DPL,R4
   \   000005   8D83         MOV       DPH,R5
   \   000007   22           RET
   2954          
   2955          /*********************************************************************
   2956           * @fn      bdb_zclRespondentListClean
   2957           *
   2958           * @brief   This function free reserved memory for respondent list
   2959           *
   2960           * @param   pHead - begin of the respondent list
   2961           *
   2962           * @return  status
   2963           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2964          void bdb_zclRespondentListClean( bdbFindingBindingRespondent_t **pHead )
   \                     bdb_zclRespondentListClean:
   2965          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
   2966            bdbFindingBindingRespondent_t **pCurr;
   2967            bdbFindingBindingRespondent_t **pNext;
   2968            
   2969            if ( *pHead == NULL )
   \   000009   8A82         MOV       DPL,R2
   \   00000B   8B83         MOV       DPH,R3
   \   00000D   12....       LCALL     ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_66:
   \   000010   6031         JZ        ??bdb_zclRespondentListClean_0
   2970            {
   2971              return;
   2972            }
   2973            
   2974            pCurr = pHead;
   \   000012   AE..         MOV       R6,?V0
   \   000014   AF..         MOV       R7,?V1
   \   000016   8018         SJMP      ??bdb_zclRespondentListClean_1
   2975            
   2976            while( *pCurr != NULL )
   2977            {
   2978              pNext = &((*pCurr)->pNext);
   \                     ??bdb_zclRespondentListClean_2:
   \   000018   EA           MOV       A,R2
   \   000019   240F         ADD       A,#0xf
   \   00001B   F5..         MOV       ?V2,A
   \   00001D   E4           CLR       A
   \   00001E   3B           ADDC      A,R3
   \   00001F   F5..         MOV       ?V3,A
   2979              osal_mem_free( *pCurr );
   \   000021                ; Setup parameters for call to function osal_mem_free
   \   000021   12....       LCALL     `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   2980              *pCurr = ( bdbFindingBindingRespondent_t* )NULL;
   \   000024   8E82         MOV       DPL,R6
   \   000026   8F83         MOV       DPH,R7
   \   000028   E4           CLR       A
   \   000029   F0           MOVX      @DPTR,A
   \   00002A   A3           INC       DPTR
   \   00002B   F0           MOVX      @DPTR,A
   2981              pCurr = pNext;
   \   00002C   AE..         MOV       R6,?V2
   \   00002E   AF..         MOV       R7,?V3
   2982            }
   \                     ??bdb_zclRespondentListClean_1:
   \   000030   8E82         MOV       DPL,R6
   \   000032   8F83         MOV       DPH,R7
   \   000034   12....       LCALL     ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   000037   70DF         JNZ       ??bdb_zclRespondentListClean_2
   2983            *pHead = NULL;
   \   000039   85..82       MOV       DPL,?V0
   \   00003C   85..83       MOV       DPH,?V1
   \   00003F   E4           CLR       A
   \   000040   F0           MOVX      @DPTR,A
   \   000041   A3           INC       DPTR
   \   000042   F0           MOVX      @DPTR,A
   2984          }
   \                     ??bdb_zclRespondentListClean_0:
   \   000043   02....       LJMP      ??Subroutine43_0 & 0xFFFF
   2985          
   2986           /*********************************************************************
   2987           * PRIVATE FUNCTIONS
   2988           *********************************************************************/
   2989          
   2990          /*********************************************************************
   2991           * @fn      bdb_ProcessOSALMsg
   2992           *
   2993           * @brief   Process the incoming task message.
   2994           *
   2995           * @param   msgPtr - message to process
   2996           *
   2997           * @return  none
   2998           */
   2999          void bdb_ProcessOSALMsg( bdbInMsg_t *msgPtr )
   3000          {
   3001            
   3002            switch(msgPtr->hdr.event)
   3003            {
   3004          #if (ZG_BUILD_JOINING_TYPE)
   3005              case BDB_COMMISSIONING_STATE_JOINING:
   3006                if(ZG_DEVICE_JOINING_TYPE)
   3007                {
   3008                  switch(msgPtr->buf[0])
   3009                  {
   3010                    case BDB_JOIN_EVENT_NWK_DISCOVERY:
   3011                      if(msgPtr->hdr.status == BDB_MSG_EVENT_SUCCESS)
   3012                      {
   3013                        bdb_filterNwkDisc();
   3014                        bdb_tryNwkAssoc();
   3015                      }
   3016                      else
   3017                      {
   3018                        bdb_nwkDiscoveryAttempt(FALSE);
   3019                      }
   3020                    break;
   3021                    
   3022                    case BDB_JOIN_EVENT_ASSOCIATION:
   3023                      if(msgPtr->hdr.status == BDB_MSG_EVENT_SUCCESS)
   3024                      {
   3025                        bdbCommissioningProcedureState.bdbJoinState = BDB_JOIN_STATE_WAITING_NWK_KEY;
   3026                        //Nwk key timeout get right timing
   3027                        osal_start_timerEx(bdb_TaskID,BDB_PROCESS_TIMEOUT, BDB_DEFAULT_DEVICE_UNAUTH_TIMEOUT);
   3028                      }
   3029                      else
   3030                      {
   3031                        if ( (NLME_GetShortAddr() != INVALID_NODE_ADDR) ||
   3032                             (_NIB.nwkDevAddress != INVALID_NODE_ADDR) )
   3033                        {
   3034                          uint16 addr = INVALID_NODE_ADDR;
   3035                          // Invalidate nwk addr so end device does not use in its data reqs.
   3036                          _NIB.nwkDevAddress = INVALID_NODE_ADDR;
   3037                          ZMacSetReq( ZMacShortAddress, (uint8 *)&addr );
   3038                        }
   3039          
   3040                        //Clear the neighbor Table and network discovery tables.
   3041                        nwkNeighborInitTable();
   3042                        NLME_NwkDiscTerm();
   3043                        _NIB.nwkState = NWK_INIT;
   3044                        
   3045                        bdb_tryNwkAssoc();
   3046                      }
   3047                    break;
   3048                  }
   3049                }
   3050              break;
   3051              
   3052              case BDB_COMMISSIONING_STATE_TC_LINK_KEY_EXCHANGE:
   3053                if(ZG_DEVICE_JOINING_TYPE)
   3054                {
   3055                  if(msgPtr->hdr.status != BDB_MSG_EVENT_SUCCESS)
   3056                  {
   3057                    bdbAttributes.bdbTCLinkKeyExchangeAttempts++;
   3058                    if(bdbAttributes.bdbTCLinkKeyExchangeAttempts > bdbAttributes.bdbTCLinkKeyExchangeAttemptsMax)
   3059                    {
   3060                      //TCLK process fail due to many attempts fails
   3061                      bdb_reportCommissioningState(BDB_COMMISSIONING_STATE_TC_LINK_KEY_EXCHANGE, FALSE);
   3062                      return;
   3063                    }
   3064                  }
   3065                  switch(bdbCommissioningProcedureState.bdbTCExchangeState)
   3066                  {
   3067                    case BDB_REQ_TC_STACK_VERSION:
   3068                      bdb_requestTCStackVersion();
   3069                    break;
   3070                    case BDB_REQ_TC_LINK_KEY:
   3071                      bdb_requestTCLinkKey();
   3072                    break;
   3073                    case BDB_REQ_VERIFY_TC_LINK_KEY:
   3074                      bdb_requestVerifyTCLinkKey();
   3075                    break;
   3076                  }
   3077                }
   3078             break;
   3079          #endif
   3080             }
   3081          }
   3082          
   3083          
   3084          /*********************************************************************
   3085           * @fn      bdb_processTimeout
   3086           *
   3087           * @brief   Handles timeout of the bdb process
   3088           *
   3089           * @param   msgPtr - message to process
   3090           *
   3091           * @return  none
   3092           */
   3093          void bdb_processTimeout(void)
   3094          {
   3095          #if (ZG_BUILD_JOINING_TYPE)
   3096            if(ZG_DEVICE_JOINING_TYPE)
   3097            {
   3098              switch(bdbCommissioningProcedureState.bdbCommissioningState)
   3099              {
   3100                case BDB_COMMISSIONING_STATE_TC_LINK_KEY_EXCHANGE:
   3101                  
   3102                  bdb_tcLinkKeyExchangeAttempt(FALSE,bdbCommissioningProcedureState.bdbTCExchangeState);
   3103                break;
   3104                case BDB_COMMISSIONING_STATE_JOINING:
   3105                  if(bdbCommissioningProcedureState.bdbJoinState == BDB_JOIN_STATE_WAITING_NWK_KEY)
   3106                  {
   3107                    //If nwk key fails, then try association again
   3108                    bdbCommissioningProcedureState.bdbJoinState = BDB_JOIN_STATE_ASSOC;
   3109                    bdb_nwkAssocAttemt(FALSE);
   3110                  }
   3111                break;
   3112              }
   3113            }
   3114          #endif
   3115            
   3116          }
   3117          
   3118          
   3119          /*********************************************************************
   3120           * @fn      bdb_SendMsg
   3121           *
   3122           * @brief   Send messages to bdb processing with the expected format
   3123           *
   3124           * @param   msgPtr - message to process
   3125           *
   3126           * @return  none
   3127           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3128          void bdb_SendMsg(uint8 taskID, uint8 toCommissioningState,uint8 status, uint8 len, uint8 *buf)
   \                     bdb_SendMsg:
   3129          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV       A,#-0x1
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   85..82       MOV       DPL,?XSP + 0
   \   00000E   85..83       MOV       DPH,?XSP + 1
   \   000011   F0           MOVX      @DPTR,A
   \   000012   8A..         MOV       ?V7,R2
   \   000014   8B..         MOV       ?V6,R3
   \   000016   8C..         MOV       ?V3,R4
   3130            bdbInMsg_t *msgPtr = NULL;
   3131          
   3132            if ( (len > 0) && (buf != NULL) )
   \   000018   EC           MOV       A,R4
   \   000019   6058         JZ        ??bdb_SendMsg_0
   \   00001B   7411         MOV       A,#0x11
   \   00001D   12....       LCALL     ?XSTACK_DISP0_8
   \   000020   12....       LCALL     ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   000023   E5..         MOV       A,?V0
   \   000025   45..         ORL       A,?V1
   \   000027   604A         JZ        ??bdb_SendMsg_0
   3133            {
   3134              uint8 tmpLength;
   3135              tmpLength = len;
   3136              tmpLength += sizeof(osal_event_hdr_t);
   3137              
   3138              msgPtr = (bdbInMsg_t *)osal_msg_allocate( tmpLength );
   \   000029                ; Setup parameters for call to function osal_msg_allocate
   \   000029   7402         MOV       A,#0x2
   \   00002B   2C           ADD       A,R4
   \   00002C   FA           MOV       R2,A
   \   00002D   7B00         MOV       R3,#0x0
   \   00002F   12....       LCALL     `??osal_msg_allocate::?relay`; Banked call to: osal_msg_allocate
   \   000032   8A..         MOV       ?V4,R2
   \   000034   8B..         MOV       ?V5,R3
   \   000036   AE..         MOV       R6,?V4
   \   000038   AF..         MOV       R7,?V5
   3139              
   3140              if ( msgPtr )
   \   00003A   EE           MOV       A,R6
   \   00003B   4F           ORL       A,R7
   \   00003C   6035         JZ        ??bdb_SendMsg_0
   3141              {
   3142                osal_memcpy( msgPtr->buf, buf, len );
   \   00003E                ; Setup parameters for call to function osal_memcpy
   \   00003E   75..00       MOV       ?V2,#0x0
   \   000041   78..         MOV       R0,#?V0
   \   000043   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000046   AC..         MOV       R4,?V3
   \   000048   7D00         MOV       R5,#0x0
   \   00004A   EE           MOV       A,R6
   \   00004B   2402         ADD       A,#0x2
   \   00004D   FA           MOV       R2,A
   \   00004E   E4           CLR       A
   \   00004F   3F           ADDC      A,R7
   \   000050   FB           MOV       R3,A
   \   000051   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000054   7403         MOV       A,#0x3
   \   000056   12....       LCALL     ?DEALLOC_XSTACK8
   3143              
   3144                msgPtr->hdr.event = toCommissioningState;
   \   000059   8E82         MOV       DPL,R6
   \   00005B   8F83         MOV       DPH,R7
   \   00005D   E5..         MOV       A,?V7
   \   00005F   F0           MOVX      @DPTR,A
   3145                msgPtr->hdr.status = status;
   \   000060   A3           INC       DPTR
   \   000061   E5..         MOV       A,?V6
   \   000063   F0           MOVX      @DPTR,A
   3146                osal_msg_send( taskID, (uint8 *)msgPtr );
   \   000064                ; Setup parameters for call to function osal_msg_send
   \   000064   EE           MOV       A,R6
   \   000065   FA           MOV       R2,A
   \   000066   EF           MOV       A,R7
   \   000067   FB           MOV       R3,A
   \   000068   85..82       MOV       DPL,?XSP + 0
   \   00006B   85..83       MOV       DPH,?XSP + 1
   \   00006E   E0           MOVX      A,@DPTR
   \   00006F   F9           MOV       R1,A
   \   000070   12....       LCALL     `??osal_msg_send::?relay`; Banked call to: osal_msg_send
   3147              }
   3148            }
   3149          }
   \                     ??bdb_SendMsg_0:
   \   000073   7401         MOV       A,#0x1
   \   000075                REQUIRE ?Subroutine6
   \   000075                ; // Fall through to label ?Subroutine6
   3150          
   3151          
   3152          /*********************************************************************
   3153           * @fn      bdb_RegisterCommissioningStatusCB
   3154           *
   3155           * @brief   Register a callback in which the status of the procedures done in
   3156           *          BDB commissioning process will be reported
   3157           *
   3158           * @param   bdbGCB_CommissioningStatus - application callback
   3159           *
   3160           * @return  none
   3161           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3162          void bdb_RegisterCommissioningStatusCB(bdbGCB_CommissioningStatus_t bdbGCB_CommissioningStatus)
   \                     bdb_RegisterCommissioningStatusCB:
   3163          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3164            pfnCommissioningStatusCB = bdbGCB_CommissioningStatus;
   \   000004   90....       MOV       DPTR,#pfnCommissioningStatusCB
   \   000007   02....       LJMP      ?Subroutine4 & 0xFFFF
   3165          }
   3166          
   3167          /*********************************************************************
   3168           * @fn      bdb_ClearNetworkParams
   3169           *
   3170           * @brief   Restore nwk parameters to invalid if the device is not on a network
   3171           *
   3172           * @param   void
   3173           *
   3174           * @return  void
   3175           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3176          void bdb_ClearNetworkParams(void)
   \                     bdb_ClearNetworkParams:
   3177          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   3178          #if (BDB_TOUCHLINK_CAPABILITY_ENABLED == TRUE)
   3179            if ( bdbAttributes.bdbNodeIsOnANetwork == FALSE )
   3180            {
   3181              //Clear the event
   3182              _NIB.nwkPanId = INVALID_NODE_ADDR;
   3183              _NIB.nwkLogicalChannel = 0;
   3184              _NIB.nwkDevAddress = INVALID_NODE_ADDR;
   3185              touchLink_SetMacNwkParams( _NIB.nwkDevAddress, _NIB.nwkPanId, _NIB.nwkLogicalChannel );
   3186            }
   3187          #endif
   3188          }
   \   000000   02....       LJMP      ?BRET
   3189          
   3190          /*********************************************************************
   3191           * @fn      bdb_getZCLFrameCounter
   3192           *
   3193           * @brief   Get the next ZCL Frame Counter for packet sequence number
   3194           *
   3195           * @param   none
   3196           *
   3197           * @return  next ZCL frame counter
   3198           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3199          uint8 bdb_getZCLFrameCounter(void)
   \                     bdb_getZCLFrameCounter:
   3200          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3201            bdb_ZclTransactionSequenceNumber++;
   \   000004   90....       MOV       DPTR,#bdb_ZclTransactionSequenceNumber
   \   000007   E0           MOVX      A,@DPTR
   \   000008   04           INC       A
   \   000009   F0           MOVX      @DPTR,A
   3202            return bdb_ZclTransactionSequenceNumber;
   \   00000A   02....       LJMP      ??Subroutine41_0 & 0xFFFF
   3203          
   3204          }
   3205          
   3206          
   3207          #if (ZG_BUILD_JOINING_TYPE)
   3208          /*********************************************************************
   3209           * @fn      bdb_RegisterCBKETCLinkKeyExchangeCB
   3210           *
   3211           * @brief   Register a callback in which the TC link key exchange procedure will 
   3212           *          be performed by application.
   3213           *          Upon fail or success bdb must be notified, see bdb_CBKETCLinkKeyExchangeAttempt
   3214           *
   3215           * @param   bdbGCB_TCLinkKeyExchangeMethod - application callback
   3216           *
   3217           * @return  none
   3218           */
   3219          void bdb_RegisterCBKETCLinkKeyExchangeCB(bdbGCB_CBKETCLinkKeyExchange_t bdbGCB_CBKETCLinkKeyExchange)
   3220          {
   3221            if(bdbGCB_CBKETCLinkKeyExchange)
   3222            {
   3223              pfnCBKETCLinkKeyExchange = bdbGCB_CBKETCLinkKeyExchange;
   3224              bdbAttributes.bdbTCLinkKeyExchangeMethod = BDB_TC_LINK_KEY_EXCHANGE_CBKE;
   3225            }
   3226            else
   3227            {
   3228              pfnCBKETCLinkKeyExchange = NULL;
   3229              bdbAttributes.bdbTCLinkKeyExchangeMethod = BDB_TC_LINK_KEY_EXCHANGE_APS_KEY;
   3230            }
   3231          }
   3232          
   3233          /*********************************************************************
   3234           * @fn      bdb_RegisterForFilterNwkDescCB
   3235           *
   3236           * @brief   Register a callback in which the application gets the list of network
   3237           *          descriptors got from active scan.
   3238           *          Use bdb_nwkDescFree to release the network descriptors that are not 
   3239           *          of interest and leave those which are to be attempted.
   3240           *
   3241           * @param   bdbGCB_FilterNwkDesc - application callback
   3242           *
   3243           * @return  none
   3244           */
   3245          void bdb_RegisterForFilterNwkDescCB(bdbGCB_FilterNwkDesc_t bdbGCB_FilterNwkDesc)
   3246          {
   3247            if(bdbGCB_FilterNwkDesc)
   3248            {
   3249              pfnFilterNwkDesc = bdbGCB_FilterNwkDesc;
   3250            }
   3251          }
   3252          
   3253          
   3254          /*********************************************************************
   3255           * @fn          bdb_CBKETCLinkKeyExchangeAttempt
   3256           *
   3257           * @brief       Tell BDB module the result of the TC link key exchange, to try
   3258           *              the default process or to keep going with the joining process.
   3259           *
   3260           * @param       didSuccess - TRUE if the process was succes, False otherwise
   3261           *
   3262           * @return      unprocessed events
   3263           */
   3264          void bdb_CBKETCLinkKeyExchangeAttempt(bool didSuccess)
   3265          {
   3266            if(didSuccess)
   3267            {
   3268              bdb_setNodeJoinLinkKeyType(BDB_DEFAULT_GLOBAL_TRUST_CENTER_LINK_KEY);
   3269              bdb_reportCommissioningState(BDB_COMMISSIONING_STATE_TC_LINK_KEY_EXCHANGE, TRUE);
   3270            }
   3271            else
   3272            {
   3273              bdbAttributes.bdbTCLinkKeyExchangeMethod = BDB_TC_LINK_KEY_EXCHANGE_APS_KEY;
   3274              //We are going back one state to try it again
   3275              bdbCommissioningProcedureState.bdbTCExchangeState -= BDB_TC_EXCHANGE_NEXT_STATE;
   3276              bdb_tcLinkKeyExchangeAttempt(TRUE,BDB_REQ_TC_STACK_VERSION);
   3277            }
   3278          
   3279          }
   3280          #endif
   3281          
   3282          #if !defined (DISABLE_GREENPOWER_BASIC_PROXY) && (ZG_BUILD_RTR_TYPE)
   3283          
   3284          /*********************************************************************
   3285           * @fn      gp_ChangeChannelReq
   3286           *
   3287           * @brief   Callback function to notify the BDB about a GP commissioning 
   3288           * request that will change the current channel for at most 
   3289           * gpBirectionalCommissioningChangeChannelTimeout ms
   3290           *
   3291           * @param   channel - Channel in which the commissioning will take place
   3292           *
   3293           * @return  TRUE to allow change channel, FALSE to do not allow
   3294           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3295          static uint8 gp_ChangeChannelReq(void)
   \                     gp_ChangeChannelReq:
   3296          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3297            uint8 allowChangeChannel = TRUE;
   \   000004   7901         MOV       R1,#0x1
   3298            
   3299            //Do not allow changes of channel if any process is in place
   3300            if(bdbAttributes.bdbCommissioningMode)
   \   000006   90....       MOV       DPTR,#bdbAttributes + 11
   \   000009   E0           MOVX      A,@DPTR
   \   00000A   6002         JZ        ??gp_ChangeChannelReq_0
   3301            {
   3302              allowChangeChannel = FALSE;
   \   00000C   7900         MOV       R1,#0x0
   3303            }
   3304            
   3305            //Check application state to decide if allow change channel or not
   3306            
   3307            return allowChangeChannel;
   \                     ??gp_ChangeChannelReq_0:
   \   00000E   02....       LJMP      ??Subroutine40_0 & 0xFFFF
   3308          }
   3309          
   3310          
   3311          /*********************************************************************
   3312           * @fn          gp_CBInit
   3313           *
   3314           * @brief       Register the callbacks for GP endpoint
   3315           *
   3316           * @param       none
   3317           *
   3318           * @return      none
   3319           */
   3320          void gp_CBInit(void)
   3321          {
   3322            GP_DataCnfGCB = GP_DataCnf;
   3323            GP_endpointInitGCB = gp_endpointInit;  
   3324            GP_expireDuplicateFilteringGCB = gp_expireDuplicateFiltering;
   3325            GP_stopCommissioningModeGCB = gp_stopCommissioningMode;
   3326            GP_returnOperationalChannelGCB = gp_returnOperationalChannel;
   3327            GP_DataIndGCB = GP_DataInd;
   3328            GP_SecReqGCB = GP_SecReq;   
   3329            GP_CheckAnnouncedDeviceGCB = gp_CheckAnnouncedDevice;
   3330              
   3331            GP_aliasConflictAnnce = &aliasConflictAnnce;
   3332            
   3333            GP_endpointInitGCB();
   3334          }
   3335          
   3336          #endif
   3337          
   3338          /*********************************************************************
   3339          *********************************************************************/
   3340          
   3341          
   3342          /******************************************************************************
   3343           * @fn          bdb_GenerateInstallCodeCRC
   3344           *
   3345           * @brief       Creates a CRC for the install code passed.
   3346           *
   3347           * @param       installCode - install code from which CRC will be generated
   3348           *
   3349           * @return      CRC
   3350           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3351          uint16 bdb_GenerateInstallCodeCRC(uint8 *installCode)
   \                     bdb_GenerateInstallCodeCRC:
   3352          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 2
   \   000004   74FE         MOV       A,#-0x2
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
   3353            uint16 CRC;
   3354            
   3355            bdb_calculateCCITT_CRC(installCode, INSTALL_CODE_LEN, &CRC);
   \   000009                ; Setup parameters for call to function bdb_calculateCCITT_CRC
   \   000009   90....       MOV       DPTR,#__Constant_10
   \   00000C   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   00000F   7404         MOV       A,#0x4
   \   000011   12....       LCALL     ?XSTACK_DISP102_8
   \   000014   12....       LCALL     `??bdb_calculateCCITT_CRC::?relay`; Banked call to: bdb_calculateCCITT_CRC
   \   000017   7404         MOV       A,#0x4
   \   000019   12....       LCALL     ?DEALLOC_XSTACK8
   3356          
   3357            return CRC;
   \   00001C   85..82       MOV       DPL,?XSP + 0
   \   00001F   85..83       MOV       DPH,?XSP + 1
   \   000022   12....       LCALL     ??Subroutine51_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_95:
   \   000025   7402         MOV       A,#0x2
   \   000027   02....       LJMP      ?Subroutine7 & 0xFFFF
   3358          }
   3359          
   3360          /******************************************************************************
   3361           * @fn          bdb_calculateCCITT_CRC
   3362           *
   3363           * @brief       Creates a CRC for the install code passed.
   3364           *
   3365           * @param       Mb - install code from which CRC will be generated
   3366           * @param       msglen - install code length
   3367           * @param       crc - 
   3368           *
   3369           * @return      none
   3370           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3371          void bdb_calculateCCITT_CRC (uint8 *Mb, uint32 msglen, uint16 *crc)
   \                     bdb_calculateCCITT_CRC:
   3372          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   8A..         MOV       ?V0,R2
   \   00000C   8B..         MOV       ?V1,R3
   \   00000E   EC           MOV       A,R4
   \   00000F   FE           MOV       R6,A
   \   000010   ED           MOV       A,R5
   \   000011   FF           MOV       R7,A
   3373            uint16 crcinit_direct; 
   3374            uint16 crcinit_nondirect;
   3375            bdb_crcInit(crc, &crcinit_direct, &crcinit_nondirect);
   \   000012                ; Setup parameters for call to function bdb_crcInit
   \   000012   A8..         MOV       R0,?XSP + 0
   \   000014   A9..         MOV       R1,?XSP + 1
   \   000016   88..         MOV       ?V2,R0
   \   000018   89..         MOV       ?V3,R1
   \   00001A   78..         MOV       R0,#?V2
   \   00001C   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00001F   7404         MOV       A,#0x4
   \   000021   12....       LCALL     ?XSTACK_DISP102_8
   \   000024   EE           MOV       A,R6
   \   000025   FA           MOV       R2,A
   \   000026   EF           MOV       A,R7
   \   000027   FB           MOV       R3,A
   \   000028   12....       LCALL     `??bdb_crcInit::?relay`; Banked call to: bdb_crcInit
   \   00002B   7402         MOV       A,#0x2
   \   00002D   12....       LCALL     ?DEALLOC_XSTACK8
   3376            *crc = bdb_crcBitByBitFast(Mb, msglen, crcinit_direct, crcinit_nondirect);
   \   000030                ; Setup parameters for call to function bdb_crcBitByBitFast
   \   000030   85..82       MOV       DPL,?XSP + 0
   \   000033   85..83       MOV       DPH,?XSP + 1
   \   000036   12....       LCALL     ?PUSH_XSTACK8_X_TWO
   \   000039   7412         MOV       A,#0x12
   \   00003B   12....       LCALL     ?XSTACK_DISP0_8
   \   00003E   12....       LCALL     ?PUSH_XSTACK8_X_FOUR
   \   000041   7408         MOV       A,#0x8
   \   000043   12....       LCALL     ?XSTACK_DISP0_8
   \   000046   E0           MOVX      A,@DPTR
   \   000047   FC           MOV       R4,A
   \   000048   A3           INC       DPTR
   \   000049   E0           MOVX      A,@DPTR
   \   00004A   FD           MOV       R5,A
   \   00004B   AA..         MOV       R2,?V0
   \   00004D   AB..         MOV       R3,?V1
   \   00004F   12....       LCALL     `??bdb_crcBitByBitFast::?relay`; Banked call to: bdb_crcBitByBitFast
   \   000052   7406         MOV       A,#0x6
   \   000054   12....       LCALL     ?DEALLOC_XSTACK8
   \   000057   8E82         MOV       DPL,R6
   \   000059   8F83         MOV       DPH,R7
   \   00005B   EA           MOV       A,R2
   \   00005C   F0           MOVX      @DPTR,A
   \   00005D   A3           INC       DPTR
   \   00005E   EB           MOV       A,R3
   \   00005F   F0           MOVX      @DPTR,A
   3377          }
   \   000060   02....       LJMP      ?Subroutine2 & 0xFFFF
   3378          
   3379          
   3380          /******************************************************************************
   3381           * @fn          bdb_crcInit
   3382           *
   3383           * @brief       Initialize CRC calculation
   3384           *
   3385           * @param       crc - 
   3386           * @param       crcinit_direct -
   3387           * @param       crcinit_nondirect - 
   3388           *
   3389           * @return      none
   3390           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3391          void bdb_crcInit(uint16 *crc, uint16 *crcinit_direct, uint16 *crcinit_nondirect)
   \                     bdb_crcInit:
   3392          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   3393          
   3394            uint16 i;
   3395            uint16 bit;
   3396          
   3397            *crcinit_direct = CRC_INIT;
   \   000005   8C82         MOV       DPL,R4
   \   000007   8D83         MOV       DPH,R5
   \   000009   74FF         MOV       A,#-0x1
   \   00000B   F0           MOVX      @DPTR,A
   \   00000C   A3           INC       DPTR
   \   00000D   F0           MOVX      @DPTR,A
   3398            *crc = CRC_INIT;
   \   00000E   8A82         MOV       DPL,R2
   \   000010   8B83         MOV       DPH,R3
   \   000012   F0           MOVX      @DPTR,A
   \   000013   A3           INC       DPTR
   \   000014   F0           MOVX      @DPTR,A
   3399            for (i=0; i<CRC_ORDER; i++) 
   \   000015   7E10         MOV       R6,#0x10
   3400            {
   3401              bit = *crc & 1;
   \                     ??bdb_crcInit_0:
   \   000017   8A82         MOV       DPL,R2
   \   000019   8B83         MOV       DPH,R3
   \   00001B   E0           MOVX      A,@DPTR
   \   00001C   F8           MOV       R0,A
   3402              if (bit) *crc^= CRC_POLYNOM;
   \   00001D   A2E0         MOV       C,0xE0 /* A   */.0
   \   00001F   5008         JNC       ??bdb_crcInit_1
   \   000021   6421         XRL       A,#0x21
   \   000023   F0           MOVX      @DPTR,A
   \   000024   A3           INC       DPTR
   \   000025   E0           MOVX      A,@DPTR
   \   000026   6410         XRL       A,#0x10
   \   000028   F0           MOVX      @DPTR,A
   3403              *crc >>= 1;
   \                     ??bdb_crcInit_1:
   \   000029   8A82         MOV       DPL,R2
   \   00002B   8B83         MOV       DPH,R3
   \   00002D   E0           MOVX      A,@DPTR
   \   00002E   FC           MOV       R4,A
   \   00002F   A3           INC       DPTR
   \   000030   E0           MOVX      A,@DPTR
   \   000031   C3           CLR       C
   \   000032   13           RRC       A
   \   000033   FD           MOV       R5,A
   \   000034   EC           MOV       A,R4
   \   000035   13           RRC       A
   \   000036   8A82         MOV       DPL,R2
   \   000038   8B83         MOV       DPH,R3
   \   00003A   F0           MOVX      @DPTR,A
   \   00003B   A3           INC       DPTR
   \   00003C   ED           MOV       A,R5
   \   00003D   F0           MOVX      @DPTR,A
   3404              if (bit) *crc|= CRC_HIGHBIT;
   \   00003E   E8           MOV       A,R0
   \   00003F   A2E0         MOV       C,0xE0 /* A   */.0
   \   000041   5009         JNC       ??bdb_crcInit_2
   \   000043   8A82         MOV       DPL,R2
   \   000045   8B83         MOV       DPH,R3
   \   000047   A3           INC       DPTR
   \   000048   E0           MOVX      A,@DPTR
   \   000049   4480         ORL       A,#0x80
   \   00004B   F0           MOVX      @DPTR,A
   3405            }	
   \                     ??bdb_crcInit_2:
   \   00004C   1E           DEC       R6
   \   00004D   EE           MOV       A,R6
   \   00004E   70C7         JNZ       ??bdb_crcInit_0
   3406            *crcinit_nondirect = *crc;
   \   000050   8A82         MOV       DPL,R2
   \   000052   8B83         MOV       DPH,R3
   \   000054   12....       LCALL     ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   000057   7409         MOV       A,#0x9
   \   000059   12....       LCALL     ?XSTACK_DISP0_8
   \   00005C   E0           MOVX      A,@DPTR
   \   00005D   FA           MOV       R2,A
   \   00005E   A3           INC       DPTR
   \   00005F   E0           MOVX      A,@DPTR
   \   000060   F583         MOV       DPH,A
   \   000062   8A82         MOV       DPL,R2
   \   000064   12....       LCALL     ??Subroutine52_0 & 0xFFFF
   3407          
   3408          }
   \                     ??CrossCallReturnLabel_100:
   \   000067   02....       LJMP      ?Subroutine0 & 0xFFFF
   3409          
   3410          
   3411          /******************************************************************************
   3412           * @fn          bdb_crcReflect
   3413           *
   3414           * @brief       
   3415           *
   3416           * @param       crc - 
   3417           * @param       bitnum -
   3418           *
   3419           * @return      none
   3420           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3421          uint16 bdb_crcReflect (uint16 crc, uint16 bitnum)
   \                     bdb_crcReflect:
   3422          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV       A,R2
   \   000006   FE           MOV       R6,A
   \   000007   EB           MOV       A,R3
   \   000008   FF           MOV       R7,A
   3423          
   3424            // reflects the lower 'bitnum' bits of 'crc'
   3425          
   3426            uint16 i, j=1, crcout=0;
   \   000009   7A01         MOV       R2,#0x1
   \   00000B   7B00         MOV       R3,#0x0
   \   00000D   8B..         MOV       ?V2,R3
   \   00000F   8B..         MOV       ?V3,R3
   3427          
   3428            for (i=(uint16)1<<(bitnum-1); i; i>>=1) {
   \   000011   8A..         MOV       ?V0,R2
   \   000013   8B..         MOV       ?V1,R3
   \   000015   EC           MOV       A,R4
   \   000016   14           DEC       A
   \   000017   78..         MOV       R0,#?V0
   \   000019   12....       LCALL     ?S_SHL
   \   00001C   A8..         MOV       R0,?V0
   \   00001E   A9..         MOV       R1,?V1
   \   000020   8022         SJMP      ??bdb_crcReflect_0
   3429              if (crc & i) crcout|=j;
   \                     ??bdb_crcReflect_1:
   \   000022   EE           MOV       A,R6
   \   000023   58           ANL       A,R0
   \   000024   FC           MOV       R4,A
   \   000025   EF           MOV       A,R7
   \   000026   59           ANL       A,R1
   \   000027   FD           MOV       R5,A
   \   000028   EC           MOV       A,R4
   \   000029   4D           ORL       A,R5
   \   00002A   600A         JZ        ??bdb_crcReflect_2
   \   00002C   EA           MOV       A,R2
   \   00002D   45..         ORL       A,?V2
   \   00002F   F5..         MOV       ?V2,A
   \   000031   EB           MOV       A,R3
   \   000032   45..         ORL       A,?V3
   \   000034   F5..         MOV       ?V3,A
   3430              j<<= 1;
   \                     ??bdb_crcReflect_2:
   \   000036   EA           MOV       A,R2
   \   000037   25E0         ADD       A,0xE0 /* A   */
   \   000039   FA           MOV       R2,A
   \   00003A   EB           MOV       A,R3
   \   00003B   33           RLC       A
   \   00003C   FB           MOV       R3,A
   3431            }
   \   00003D   E9           MOV       A,R1
   \   00003E   C3           CLR       C
   \   00003F   13           RRC       A
   \   000040   F9           MOV       R1,A
   \   000041   E8           MOV       A,R0
   \   000042   13           RRC       A
   \   000043   F8           MOV       R0,A
   \                     ??bdb_crcReflect_0:
   \   000044   E8           MOV       A,R0
   \   000045   49           ORL       A,R1
   \   000046   70DA         JNZ       ??bdb_crcReflect_1
   3432            return (crcout);
   \   000048   AA..         MOV       R2,?V2
   \   00004A   AB..         MOV       R3,?V3
   \   00004C   02....       LJMP      ??Subroutine43_0 & 0xFFFF
   3433          }
   3434          
   3435          
   3436          /******************************************************************************
   3437           * @fn          bdb_crcBitByBitFast
   3438           *
   3439           * @brief       
   3440           *
   3441           * @param       p - 
   3442           * @param       len -
   3443           * @param       crcinit_direct - 
   3444           * @param       crcinit_nondirect -
   3445           *
   3446           * @return      crc
   3447           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3448          uint16 bdb_crcBitByBitFast(uint8 * p, uint32 len, uint16 crcinit_direct, uint16 crcinit_nondirect) 
   \                     bdb_crcBitByBitFast:
   3449          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV       A,#-0x10
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV       A,#-0x4
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   85..82       MOV       DPL,?XSP + 0
   \   00000D   85..83       MOV       DPH,?XSP + 1
   \   000010   EA           MOV       A,R2
   \   000011   F0           MOVX      @DPTR,A
   \   000012   A3           INC       DPTR
   \   000013   EB           MOV       A,R3
   \   000014   F0           MOVX      @DPTR,A
   3450            // fast bit by bit algorithm without augmented zero bytes.
   3451            // does not use lookup table, suited for polynom orders between 1...32.
   3452          
   3453            uint16 i, j, c, bit;
   3454            uint16 crc = crcinit_direct;
   \   000015   EC           MOV       A,R4
   \   000016   FE           MOV       R6,A
   \   000017   ED           MOV       A,R5
   \   000018   FF           MOV       R7,A
   3455          
   3456            for (i=0; i<len; i++) {
   \   000019   7402         MOV       A,#0x2
   \   00001B   12....       LCALL     ?XSTACK_DISP0_8
   \   00001E   E4           CLR       A
   \   00001F   F0           MOVX      @DPTR,A
   \   000020   A3           INC       DPTR
   \   000021   F0           MOVX      @DPTR,A
   \   000022   7414         MOV       A,#0x14
   \   000024   12....       LCALL     ?XSTACK_DISP0_8
   \   000027   78..         MOV       R0,#?V0
   \   000029   12....       LCALL     ?L_MOV_X
   \   00002C   8063         SJMP      ??bdb_crcBitByBitFast_0
   3457          
   3458              c = (uint16)*p++;
   \                     ??bdb_crcBitByBitFast_1:
   \   00002E   85..82       MOV       DPL,?XSP + 0
   \   000031   85..83       MOV       DPH,?XSP + 1
   \   000034   E0           MOVX      A,@DPTR
   \   000035   F8           MOV       R0,A
   \   000036   A3           INC       DPTR
   \   000037   12....       LCALL     ??Subroutine48_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   00003A   E0           MOVX      A,@DPTR
   \   00003B   FA           MOV       R2,A
   \   00003C   7B00         MOV       R3,#0x0
   \   00003E   85..82       MOV       DPL,?XSP + 0
   \   000041   85..83       MOV       DPH,?XSP + 1
   \   000044   E0           MOVX      A,@DPTR
   \   000045   2401         ADD       A,#0x1
   \   000047   08           INC       R0
   \   000048   A3           INC       DPTR
   \   000049   E0           MOVX      A,@DPTR
   \   00004A   3400         ADDC      A,#0x0
   \   00004C   F9           MOV       R1,A
   \   00004D   85..82       MOV       DPL,?XSP + 0
   \   000050   85..83       MOV       DPH,?XSP + 1
   \   000053   12....       LCALL     ??Subroutine52_0 & 0xFFFF
   3459              c = bdb_crcReflect(c, 8);
   \                     ??CrossCallReturnLabel_101:
   \   000056                ; Setup parameters for call to function bdb_crcReflect
   \   000056   7C08         MOV       R4,#0x8
   \   000058   7D00         MOV       R5,#0x0
   \   00005A   12....       LCALL     `??bdb_crcReflect::?relay`; Banked call to: bdb_crcReflect
   3460          
   3461              for (j=0x80; j; j>>=1) {
   \   00005D   7880         MOV       R0,#-0x80
   3462          
   3463                bit = crc & CRC_HIGHBIT;
   \                     ??bdb_crcBitByBitFast_2:
   \   00005F   EF           MOV       A,R7
   \   000060   5480         ANL       A,#0x80
   \   000062   FD           MOV       R5,A
   3464                crc<<= 1;
   \   000063   EE           MOV       A,R6
   \   000064   25E0         ADD       A,0xE0 /* A   */
   \   000066   FE           MOV       R6,A
   \   000067   EF           MOV       A,R7
   \   000068   33           RLC       A
   \   000069   FF           MOV       R7,A
   3465                if (c & j) bit^= CRC_HIGHBIT;
   \   00006A   EA           MOV       A,R2
   \   00006B   58           ANL       A,R0
   \   00006C   6004         JZ        ??bdb_crcBitByBitFast_3
   \   00006E   7480         MOV       A,#-0x80
   \   000070   6D           XRL       A,R5
   \   000071   FD           MOV       R5,A
   3466                if (bit) crc^= CRC_POLYNOM;
   \                     ??bdb_crcBitByBitFast_3:
   \   000072   ED           MOV       A,R5
   \   000073   6008         JZ        ??bdb_crcBitByBitFast_4
   \   000075   7421         MOV       A,#0x21
   \   000077   6E           XRL       A,R6
   \   000078   FE           MOV       R6,A
   \   000079   7410         MOV       A,#0x10
   \   00007B   6F           XRL       A,R7
   \   00007C   FF           MOV       R7,A
   3467              }
   \                     ??bdb_crcBitByBitFast_4:
   \   00007D   C3           CLR       C
   \   00007E   E8           MOV       A,R0
   \   00007F   13           RRC       A
   \   000080   F8           MOV       R0,A
   \   000081   70DC         JNZ       ??bdb_crcBitByBitFast_2
   3468            }	
   \   000083   7402         MOV       A,#0x2
   \   000085   12....       LCALL     ?XSTACK_DISP0_8
   \   000088   E0           MOVX      A,@DPTR
   \   000089   2401         ADD       A,#0x1
   \   00008B   F0           MOVX      @DPTR,A
   \   00008C   A3           INC       DPTR
   \   00008D   E0           MOVX      A,@DPTR
   \   00008E   3400         ADDC      A,#0x0
   \   000090   F0           MOVX      @DPTR,A
   \                     ??bdb_crcBitByBitFast_0:
   \   000091   7402         MOV       A,#0x2
   \   000093   12....       LCALL     ?XSTACK_DISP0_8
   \   000096   E0           MOVX      A,@DPTR
   \   000097   F5..         MOV       ?V4,A
   \   000099   A3           INC       DPTR
   \   00009A   E0           MOVX      A,@DPTR
   \   00009B   F5..         MOV       ?V5,A
   \   00009D   E4           CLR       A
   \   00009E   F5..         MOV       ?V6,A
   \   0000A0   F5..         MOV       ?V7,A
   \   0000A2   78..         MOV       R0,#?V0
   \   0000A4   79..         MOV       R1,#?V4
   \   0000A6   12....       LCALL     ?UL_GT
   \   0000A9   4083         JC        ??bdb_crcBitByBitFast_1
   3469          
   3470            crc=bdb_crcReflect(crc, CRC_ORDER);
   3471            crc^= CRC_XOR;
   3472          
   3473            return(crc);
   \   0000AB                ; Setup parameters for call to function bdb_crcReflect
   \   0000AB   7C10         MOV       R4,#0x10
   \   0000AD   7D00         MOV       R5,#0x0
   \   0000AF   EE           MOV       A,R6
   \   0000B0   FA           MOV       R2,A
   \   0000B1   EF           MOV       A,R7
   \   0000B2   FB           MOV       R3,A
   \   0000B3   12....       LCALL     `??bdb_crcReflect::?relay`; Banked call to: bdb_crcReflect
   \   0000B6   EA           MOV       A,R2
   \   0000B7   F4           CPL       A
   \   0000B8   FA           MOV       R2,A
   \   0000B9   EB           MOV       A,R3
   \   0000BA   F4           CPL       A
   \   0000BB   FB           MOV       R3,A
   \   0000BC   7404         MOV       A,#0x4
   \   0000BE   02....       LJMP      ?Subroutine6 & 0xFFFF
   3474          }

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for bdbAttributes>`:
   \   000000   00F0FF07     DD 134213632
   \   000004   00080000     DD 2048
   \   000008   FFFF         DW 65535
   \   00000A   00           DB 0
   \   00000B   00           DB 0
   \   00000C   07           DB 7
   \   00000D   04           DB 4
   \   00000E   00           DB 0
   \   00000F   00           DB 0
   \   000010   0F           DB 15
   \   000011   00           DB 0

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for vDoPrimaryScan>`:
   \   000000   01           DB 1

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for zgBdbInstallCodeCRC>`:
   \   000000   83           DB 131
   \   000001   FE           DB 254
   \   000002   D3           DB 211
   \   000003   40           DB 64
   \   000004   7A           DB 122
   \   000005   93           DB 147
   \   000006   97           DB 151
   \   000007   23           DB 35
   \   000008   A5           DB 165
   \   000009   C6           DB 198
   \   00000A   39           DB 57
   \   00000B   B2           DB 178
   \   00000C   69           DB 105
   \   00000D   16           DB 22
   \   00000E   D5           DB 213
   \   00000F   05           DB 5
   \   000010   C3           DB 195
   \   000011   B5           DB 181

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_Init::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_RegisterSimpleDescriptor::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_RegisterSimpleDescriptor

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_ZclIdentifyCmdInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_ZclIdentifyCmdInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_addInstallCode::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_addInstallCode

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_RegisterTCLinkKeyExchangeProcessCB::?rela`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_RegisterTCLinkKeyExchangeProcessCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_setTCRequireKeyExchange::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_setTCRequireKeyExchange

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_TCAddJoiningDevice::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_TCAddJoiningDevice

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_TCProcessJoiningList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_TCProcessJoiningList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_TCjoiningDeviceComplete::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_TCjoiningDeviceComplete

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_TCJoiningDeviceFree::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_TCJoiningDeviceFree

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_setJoinUsesInstallCodeKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_setJoinUsesInstallCodeKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_StartCommissioning::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_StartCommissioning

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_NotifyCommissioningModeStart::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_NotifyCommissioningModeStart

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_setFN::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_setFN

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_resetLocalAction::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_resetLocalAction

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_parentLost::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_parentLost

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_NetworkRestoredResumeState::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_NetworkRestoredResumeState

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_reportCommissioningState::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_reportCommissioningState

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_nwkFormationAttempt::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_nwkFormationAttempt

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_isDeviceNonFactoryNew::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_isDeviceNonFactoryNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_doTrustCenterRequireKeyExchange::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_doTrustCenterRequireKeyExchange

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_rejoinNwk::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_rejoinNwk

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_setChannelAttribute::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_setChannelAttribute

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_setChannel::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_setChannel

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_nwkJoiningFormation::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_nwkJoiningFormation

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_nwkSteeringDeviceOnNwk::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_nwkSteeringDeviceOnNwk

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_startResumeCommissioningProcess::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_startResumeCommissioningProcess

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_event_loop::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_event_loop

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_ProcessNodeDescRsp::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_ProcessNodeDescRsp

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_touchlinkSendFNReset::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_touchlinkSendFNReset

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_setNodeIsOnANetwork::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_setNodeIsOnANetwork

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_setCommissioningGroupID::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_setCommissioningGroupID

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_CreateRespondentList::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_CreateRespondentList

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_AddRespondentNode::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_AddRespondentNode

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_zclRespondentListClean::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_zclRespondentListClean

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_SendMsg::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_SendMsg

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_RegisterCommissioningStatusCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_RegisterCommissioningStatusCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_ClearNetworkParams::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_ClearNetworkParams

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_getZCLFrameCounter::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_getZCLFrameCounter

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??gp_ChangeChannelReq::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    gp_ChangeChannelReq

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_GenerateInstallCodeCRC::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_GenerateInstallCodeCRC

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_calculateCCITT_CRC::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_calculateCCITT_CRC

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_crcInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_crcInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_crcReflect::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_crcReflect

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??bdb_crcBitByBitFast::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    bdb_crcBitByBitFast

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "[BDB.c:2634] Good new...">`:
   \   000000   5B424442     DB 5BH, 42H, 44H, 42H, 2EH, 63H, 3AH, 32H
   \            2E633A32
   \   000008   3633345D     DB 36H, 33H, 34H, 5DH, 20H, 47H, 6FH, 6FH
   \            20476F6F
   \   000010   64206E65     DB 64H, 20H, 6EH, 65H, 77H, 73H, 21H, 20H
   \            77732120
   \   000018   74686572     DB 74H, 68H, 65H, 72H, 65H, 20H, 61H, 72H
   \            65206172
   \   000020   65204964     DB 65H, 20H, 49H, 64H, 65H, 6EH, 74H, 69H
   \            656E7469
   \   000028   66792051     DB 66H, 79H, 20H, 51H, 75H, 65H, 72H, 79H
   \            75657279
   \   000030   20526573     DB 20H, 52H, 65H, 73H, 70H, 6FH, 6EH, 73H
   \            706F6E73
   \   000038   65206465     DB 65H, 20H, 64H, 65H, 74H, 65H, 63H, 74H
   \            74656374
   \   000040   6564210A     DB 65H, 64H, 21H, 0AH, 0
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3e8:
   \   000000   E8030000     DD 1000

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_32:
   \   000000   32000000     DD 50

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_c8:
   \   000000   C8000000     DD 200

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3a98:
   \   000000   983A0000     DD 15000

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_10:
   \   000000   10000000     DD 16
   3475          
   3476          

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0     10   bdb_AddRespondentNode
        0     10   -> bdb_CreateRespondentList
        0     10   -> osal_mem_alloc
      0      0   bdb_ClearNetworkParams
      0     20   bdb_CreateRespondentList
        0     10   -> osal_mem_alloc
      2     36   bdb_GenerateInstallCodeCRC
        2      6   -> bdb_calculateCCITT_CRC
      0      9   bdb_Init
        0      9   -> ZDO_RegisterForZDOMsg
        0      9   -> gp_RegisterGPChangeChannelReqForBDBCB
        0      9   -> gp_endpointInit
      0      0   bdb_NetworkRestoredResumeState
      1     36   bdb_NotifyCommissioningModeStart
        0     15   -> bdb_SendMsg
      0     49   bdb_ProcessNodeDescRsp
        0     45   -> APSME_IsDistributedSecurity
        0     45   -> ZDO_ParseNodeDescRsp
        0     45   -> bdb_reportCommissioningState
        0     45   -> bdb_setNodeJoinLinkKeyType
        0     45   -> bdb_tcLinkKeyExchangeAttempt
        0     49   -> osal_nv_write
        0     45   -> osal_stop_timerEx
      2      0   bdb_RegisterCommissioningStatusCB
      1     10   bdb_RegisterSimpleDescriptor
        0     10   -> afRegister
        0     10   -> osal_mem_alloc
      2      0   bdb_RegisterTCLinkKeyExchangeProcessCB
      1     80   bdb_SendMsg
        0     20   -> osal_memcpy
        0     17   -> osal_msg_allocate
        0     17   -> osal_msg_send
      0     36   bdb_StartCommissioning
        0     32   -> APSME_IsDistributedSecurity
        0     32   -> ZDOInitDeviceEx
        0     32   -> bdb_nwkSteeringDeviceOnNwk
        0     32   -> bdb_reportCommissioningState
        0     32   -> bdb_setNodeIsOnANetwork
        0     32   -> osal_get_timeoutEx
        0     32   -> osal_isbufset
        0     32   -> osal_memset
        0     36   -> osal_nv_read
        0     36   -> osal_nv_write
        0     32   -> osal_set_event
        0     32   -> zgWriteStartupOptions
      1     30   bdb_TCAddJoiningDevice
        0     28   -> bdb_SendMsg
        0     26   -> osal_mem_alloc
        0     29   -> osal_memcmp
        0     29   -> osal_memcpy
        0     30   -> osal_start_reload_timer
      0     75   bdb_TCJoiningDeviceFree
        0     14   -> osal_mem_free
        0     17   -> osal_memcmp
      0     86   bdb_TCProcessJoiningList
        0     60   -> APSME_SearchTCLinkKeyEntry
        0     58   -> AddrMgrEntryLookupExt
        0     60   -> ZDSecMgrAPSRemove
        0     58   -> ZDSecMgrAddrClear
        0     60   -> bdb_SendMsg
        0     58   -> bdb_TCJoiningDeviceFree
        0     61   -> osal_memcpy
        0     58   -> osal_memset
        0     62   -> osal_nv_write
        0     58   -> osal_stop_timerEx
      0     29   bdb_TCjoiningDeviceComplete
        0     28   -> bdb_SendMsg
        0     26   -> bdb_TCJoiningDeviceFree
        0     29   -> osal_memcmp
        0     29   -> osal_memcpy
        0     26   -> osal_stop_timerEx
      0     24   bdb_ZclIdentifyCmdInd
        0     24   -> osal_start_timerEx
        0     20   -> osal_stop_timerEx
        0     22   -> zclFindAttrRec
      0     34   bdb_addInstallCode
        0     30   -> APSME_AddTCLinkKey
        0     30   -> bdb_GenerateInstallCodeCRC
        0     30   -> osal_build_uint16
        0     34   -> sspMMOHash
      0     28   bdb_calculateCCITT_CRC
        0     22   -> bdb_crcBitByBitFast
        0     18   -> bdb_crcInit
      0     42   bdb_crcBitByBitFast
        0     20   -> bdb_crcReflect
      0     27   bdb_crcInit
      0     32   bdb_crcReflect
      2      0   bdb_doTrustCenterRequireKeyExchange
      1     28   bdb_event_loop
        0     24   -> bdb_ProcessIEEEAddrRsp
        0     24   -> bdb_ProcessRespondentList
        0     24   -> bdb_ProcessSimpleDesc
        0     24   -> bdb_SendIdentifyQuery
        0     24   -> bdb_TCProcessJoiningList
        0     24   -> bdb_exitFindingBindingWStatus
        0     24   -> bdb_getRespondentRetry
        0     24   -> bdb_nwkSteeringDeviceOnNwk
        0     24   -> bdb_reportCommissioningState
        0     24   -> bdb_setEpDescListToActiveEndpoint
        0     24   -> bdb_startResumeCommissioningProcess
        0     24   -> osal_get_timeoutEx
        0     24   -> osal_msg_deallocate
        0     24   -> osal_msg_receive
        0     28   -> osal_start_timerEx
        0     24   -> osal_stop_timerEx
        0     24   -> printf
        0     26   -> zclFindAttrRec
      2      0   bdb_getZCLFrameCounter
      2      0   bdb_isDeviceNonFactoryNew
      0      9   bdb_nwkFormationAttempt
        0      9   -> bdb_nwkJoiningFormation
        0      9   -> bdb_reportCommissioningState
      0     33   bdb_nwkJoiningFormation
        0     12   -> ZDOInitDeviceEx
        0     12   -> bdb_reportCommissioningState
        0     12   -> bdb_setChannel
      2     41   bdb_nwkSteeringDeviceOnNwk
        2      9   -> ZDP_MgmtPermitJoinReq
      0      0   bdb_parentLost
      0     10   bdb_rejoinNwk
        0     10   -> NLME_ReJoinRequest
        0     10   -> NLME_ReJoinRequestUnsecure
        0     10   -> ZDApp_ChangeState
        0     10   -> ZDApp_RestoreNwkKey
        0     10   -> ZMacSetReq
      1     63   bdb_reportCommissioningState
        0     14   -> NLME_ResetRequest
        0     14   -> ZDApp_ChangeState
        0     14   -> ZDApp_RestoreNwkSecMaterial
        0     14   -> ZMacSetReq
        0     16   -> bdb_SendMsg
        0     14   -> bdb_getRespondentRetry
        0     14   -> bdb_setFN
        0     14   -> bdb_zclRespondentListClean
        0     14   -> nwk_setStateIdle
        0     14   -> osal_get_timeoutEx
        0     18   -> osal_start_timerEx
        0     14   -> osal_stop_timerEx
        0     14   -> zgWriteStartupOptions
      2      0   bdb_resetLocalAction
        2      0   -> ZDApp_ResetTimerStart
        2      0   -> bdb_setFN
      0     28   bdb_setChannel
        0     16   -> osal_nv_write
      0     12   bdb_setChannelAttribute
      2      0   bdb_setCommissioningGroupID
      2     14   bdb_setFN
        2      0   -> bdb_setNodeIsOnANetwork
        2      0   -> zgWriteStartupOptions
      2      0   bdb_setJoinUsesInstallCodeKey
      0     46   bdb_setNodeIsOnANetwork
        0     14   -> osal_nv_write
      2      0   bdb_setTCRequireKeyExchange
      0     49   bdb_startResumeCommissioningProcess
        0     21   -> bdb_NotifyCommissioningModeStart
        0     21   -> bdb_SendIdentifyQuery
        0     23   -> bdb_SendMsg
        0     21   -> bdb_exitFindingBindingWStatus
        0     21   -> bdb_nwkJoiningFormation
        0     21   -> bdb_nwkSteeringDeviceOnNwk
        0     21   -> bdb_reportCommissioningState
        0     21   -> bdb_setEpDescListToActiveEndpoint
        0     21   -> osal_memset
        0     25   -> osal_start_timerEx
        0     23   -> zclFindAttrRec
      0      0   bdb_touchlinkSendFNReset
      0     26   bdb_zclRespondentListClean
        0     12   -> osal_mem_free
      2      0   gp_ChangeChannelReq


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      69  ?<Constant "[BDB.c:2634] Good new...">
      18  ?<Initializer for bdbAttributes>
       1  ?<Initializer for vDoPrimaryScan>
      18  ?<Initializer for zgBdbInstallCodeCRC>
       5  ??Subroutine37_0
       8  ??Subroutine38_0
       1  ??Subroutine39_0
       7  ??Subroutine40_0
       4  ??Subroutine41_0
       3  ??Subroutine42_0
       5  ??Subroutine43_0
       1  ??Subroutine44_0
       4  ??Subroutine45_0
       6  ??Subroutine46_0
       8  ??Subroutine47_0
       6  ??Subroutine48_0
       6  ??Subroutine49_0
       6  ??Subroutine50_0
       6  ??Subroutine51_0
       6  ??Subroutine52_0
       5  ?Subroutine0
       3  ?Subroutine1
       1  ?Subroutine10
      14  ?Subroutine11
       8  ?Subroutine12
      10  ?Subroutine13
      10  ?Subroutine14
       9  ?Subroutine15
       2  ?Subroutine16
       3  ?Subroutine17
       8  ?Subroutine18
       8  ?Subroutine19
       2  ?Subroutine2
       4  ?Subroutine20
      17  ?Subroutine21
       3  ?Subroutine22
      10  ?Subroutine23
       8  ?Subroutine24
      19  ?Subroutine25
       3  ?Subroutine26
       8  ?Subroutine27
       8  ?Subroutine28
      10  ?Subroutine29
       5  ?Subroutine3
      14  ?Subroutine30
       4  ?Subroutine31
      10  ?Subroutine32
       6  ?Subroutine33
       3  ?Subroutine34
       6  ?Subroutine35
       9  ?Subroutine36
       4  ?Subroutine4
      10  ?Subroutine5
       8  ?Subroutine6
       6  ?Subroutine7
       1  ?Subroutine8
      12  ?Subroutine9
       4  __Constant_10
       4  __Constant_32
       4  __Constant_3a98
       4  __Constant_3e8
       4  __Constant_c8
      18  bdbAttributes
       4  bdbCommissioningProcedureState
     173  bdb_AddRespondentNode
       6  bdb_AddRespondentNode::?relay
       3  bdb_ClearNetworkParams
       6  bdb_ClearNetworkParams::?relay
      28  bdb_CreateRespondentList
       6  bdb_CreateRespondentList::?relay
       2  bdb_CurrEpDescriptorList
       1  bdb_FBStateSuccessLatch
       1  bdb_FB_InitiatorCurrentCyclesNumber
      42  bdb_GenerateInstallCodeCRC
       6  bdb_GenerateInstallCodeCRC::?relay
       2  bdb_HeadEpDescriptorList
     151  bdb_Init
       6  bdb_Init::?relay
       3  bdb_NetworkRestoredResumeState
       6  bdb_NetworkRestoredResumeState::?relay
      51  bdb_NotifyCommissioningModeStart
       6  bdb_NotifyCommissioningModeStart::?relay
     178  bdb_ProcessNodeDescRsp
       6  bdb_ProcessNodeDescRsp::?relay
      10  bdb_RegisterCommissioningStatusCB
       6  bdb_RegisterCommissioningStatusCB::?relay
      57  bdb_RegisterSimpleDescriptor
       6  bdb_RegisterSimpleDescriptor::?relay
      19  bdb_RegisterTCLinkKeyExchangeProcessCB
       6  bdb_RegisterTCLinkKeyExchangeProcessCB::?relay
     117  bdb_SendMsg
       6  bdb_SendMsg::?relay
     451  bdb_StartCommissioning
       6  bdb_StartCommissioning::?relay
     382  bdb_TCAddJoiningDevice
       6  bdb_TCAddJoiningDevice::?relay
     137  bdb_TCJoiningDeviceFree
       6  bdb_TCJoiningDeviceFree::?relay
     450  bdb_TCProcessJoiningList
       6  bdb_TCProcessJoiningList::?relay
     215  bdb_TCjoiningDeviceComplete
       6  bdb_TCjoiningDeviceComplete::?relay
       1  bdb_TaskID
     147  bdb_ZclIdentifyCmdInd
       6  bdb_ZclIdentifyCmdInd::?relay
       1  bdb_ZclTransactionSequenceNumber
     126  bdb_addInstallCode
       6  bdb_addInstallCode::?relay
      99  bdb_calculateCCITT_CRC
       6  bdb_calculateCCITT_CRC::?relay
     193  bdb_crcBitByBitFast
       6  bdb_crcBitByBitFast::?relay
     106  bdb_crcInit
       6  bdb_crcInit::?relay
      79  bdb_crcReflect
       6  bdb_crcReflect::?relay
       9  bdb_doTrustCenterRequireKeyExchange
       6  bdb_doTrustCenterRequireKeyExchange::?relay
     656  bdb_event_loop
       6  bdb_event_loop::?relay
      13  bdb_getZCLFrameCounter
       6  bdb_getZCLFrameCounter::?relay
       1  bdb_initialization
       7  bdb_isDeviceNonFactoryNew
       6  bdb_isDeviceNonFactoryNew::?relay
       2  bdb_joiningDeviceList
      51  bdb_nwkFormationAttempt
       6  bdb_nwkFormationAttempt::?relay
     110  bdb_nwkJoiningFormation
       6  bdb_nwkJoiningFormation::?relay
      45  bdb_nwkSteeringDeviceOnNwk
       6  bdb_nwkSteeringDeviceOnNwk::?relay
       3  bdb_parentLost
       6  bdb_parentLost::?relay
     127  bdb_rejoinNwk
       6  bdb_rejoinNwk::?relay
     624  bdb_reportCommissioningState
       6  bdb_reportCommissioningState::?relay
      16  bdb_resetLocalAction
       6  bdb_resetLocalAction::?relay
      64  bdb_setChannel
       6  bdb_setChannel::?relay
      31  bdb_setChannelAttribute
       6  bdb_setChannelAttribute::?relay
      10  bdb_setCommissioningGroupID
       6  bdb_setCommissioningGroupID::?relay
      18  bdb_setFN
       6  bdb_setFN::?relay
      23  bdb_setJoinUsesInstallCodeKey
       6  bdb_setJoinUsesInstallCodeKey::?relay
      74  bdb_setNodeIsOnANetwork
       6  bdb_setNodeIsOnANetwork::?relay
      11  bdb_setTCRequireKeyExchange
       6  bdb_setTCRequireKeyExchange::?relay
     501  bdb_startResumeCommissioningProcess
       6  bdb_startResumeCommissioningProcess::?relay
       3  bdb_touchlinkSendFNReset
       6  bdb_touchlinkSendFNReset::?relay
      70  bdb_zclRespondentListClean
       6  bdb_zclRespondentListClean::?relay
      17  gp_ChangeChannelReq
       6  gp_ChangeChannelReq::?relay
       2  pRespondentCurr
       2  pRespondentHead
       2  pRespondentNext
       2  pfnCommissioningStatusCB
       2  pfnTCLinkKeyExchangeProcessCB
       1  touchLinkTargetEnabled
       1  vDoPrimaryScan
      18  zgBdbInstallCodeCRC

 
 6 053 bytes in segment BANKED_CODE
   270 bytes in segment BANK_RELAYS
    37 bytes in segment XDATA_I
    37 bytes in segment XDATA_ID
    89 bytes in segment XDATA_ROM_C
    26 bytes in segment XDATA_Z
 
   307 bytes of CODE     memory
    69 bytes of CONST    memory (+ 20 bytes shared)
 6 053 bytes of HUGECODE memory
    63 bytes of XDATA    memory

Errors: none
Warnings: none
