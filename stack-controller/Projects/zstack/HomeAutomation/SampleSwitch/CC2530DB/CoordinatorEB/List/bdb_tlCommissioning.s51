///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V10.10.1.4655 for 8051              22/Nov/2023  15:42:39
// Copyright 2004-2017 IAR Systems AB.
// Standalone license - IAR Embedded Workbench for 8051
//
//    Core               =  plain
//    Code model         =  banked
//    Data model         =  large
//    Calling convention =  xdata reentrant
//    Constant location  =  data_rom
//    Dptr setup         =  1,16
//                          
//    Source file        =  
//        D:\fuzzing-coordinator-response-collection\Components\stack\bdb\bdb_tlCommissioning.c
//    Command line       =  
//        -f C:\Users\ADMINI~1\AppData\Local\Temp\EW98A6.tmp
//        (D:\fuzzing-coordinator-response-collection\Components\stack\bdb\bdb_tlCommissioning.c
//        -D SECURE=1 -D TC_LINKKEY_JOIN -D NV_INIT -D NV_RESTORE -D
//        MULTICAST_ENABLED=FALSE -D ZCL_READ -D ZCL_DISCOVER -D ZCL_WRITE -D
//        ZCL_BASIC -D ZCL_IDENTIFY -D ISR_KEYINTERRUPT -D HAL_UART=TRUE -D
//        HAL_LCD=FALSE -D ZCL_ON_OFF -D INT_HEAP_LEN=2800 -D
//        HAL_UART_DMA_RX_MAX=256 -D HAL_UART_DMA_TX_MAX=256 -lC
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\CoordinatorEB\List
//        -lA
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\CoordinatorEB\List
//        --diag_suppress Pe001,Pa010 -o
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\CoordinatorEB\Obj
//        -e --debug --core=plain --dptr=16,1 --data_model=large
//        --code_model=banked --calling_convention=xdata_reentrant
//        --place_constants=data_rom --nr_virtual_regs 8 -f
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg
//        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
//        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
//        -DZDO_COORDINATOR -DRTR_NWK) -f
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg
//        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
//        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
//        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
//        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
//        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
//        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
//        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
//        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
//        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
//        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x00, 0x01, 0x02, 0x03,
//        0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
//        0x0F}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
//        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
//        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
//        -DREJOIN_POLL_RATE=440 -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000
//        -DENABLE_LED4_DISABLE_S1) -f
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\Source\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\Source\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\ZMain\TI2530DB\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\include\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\include\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\high_level\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\mt\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\osal\include\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\services\saddr\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\services\sdata\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\af\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\bdb\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\gp\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\nwk\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sapi\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sec\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\sys\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\zcl\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\stack\zdo\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\zmac\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\zmac\f8w\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\Common\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\SPI\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\HW_LCD\Font\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\HW_LCD\HAL_LCD_SPI\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\HW_LCD\HAL_OLED\
//        -I
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\HW_LCD\HAL_TFT\
//        -Ohz --require_prototypes)
//    Locale             =  Chinese (Simplified)_China.936
//    List file          =  
//        D:\fuzzing-coordinator-response-collection\Projects\zstack\HomeAutomation\SampleSwitch\CC2530DB\CoordinatorEB\List\bdb_tlCommissioning.s51
//
///////////////////////////////////////////////////////////////////////////////

        NAME bdb_tlCommissioning

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__register_banks", "*"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)


        END
// D:\fuzzing-coordinator-response-collection\Components\stack\bdb\bdb_tlCommissioning.c
//    1 /**************************************************************************************************
//    2   Filename:       bdb_tlCommissioning.c
//    3   Revised:        $Date: 2013-09-10 17:57:03 -0700 (Tue, 10 Sep 2013) $
//    4   Revision:       $Revision: 35271 $
//    5 
//    6   Description:    Zigbee Cluster Library - Light Link commissioning cluster.
//    7 
//    8 
//    9   Copyright 2011-2013 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights
//   12   granted under the terms of a software license agreement between the user
//   13   who downloaded the software, his/her employer (which must be your employer)
//   14   and Texas Instruments Incorporated (the "License").  You may not use this
//   15   Software unless you agree to abide by the terms of the License. The License
//   16   limits your use, and you acknowledge, that the Software may not be modified,
//   17   copied or distributed unless embedded on a Texas Instruments microcontroller
//   18   or used solely and exclusively in conjunction with a Texas Instruments radio
//   19   frequency transceiver, which is integrated into your product.  Other than for
//   20   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   21   works of, modify, distribute, perform, display or sell this Software and/or
//   22   its documentation for any purpose.
//   23 
//   24   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   25   PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   26   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   27   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   28   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   29   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   30   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   31   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   32   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   33   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   34   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   35 
//   36   Should you have any questions regarding your right to use this Software,
//   37   contact Texas Instruments Incorporated at www.TI.com.
//   38 **************************************************************************************************/
//   39 
//   40 
//   41 /*********************************************************************
//   42  * INCLUDES
//   43  */
//   44 #include "zcl.h"
//   45 #include "zcl_general.h"
//   46 #include "bdb_tlCommissioning.h"
//   47 #include "bdb.h"
//   48 #include "bdb_interface.h"
//   49 #include "bdb_touchlink.h"
//   50 
//   51 #include "stub_aps.h"
//   52 
//   53 #if defined ( BDB_TL_TARGET ) || defined ( BDB_TL_INITIATOR )
//   54    
//   55 /*********************************************************************
//   56  * MACROS
//   57  */
//   58 
//   59 /*********************************************************************
//   60  * CONSTANTS
//   61  */
//   62 
//   63 /*********************************************************************
//   64  * TYPEDEFS
//   65  */
//   66 
//   67 typedef struct bdbTLCBRec
//   68 {
//   69   struct bdbTLCBRec     *next;
//   70   uint8 endpoint;               // Used to link it into the endpoint descriptor
//   71   bdbTL_AppCallbacks_t  *CBs;   // Pointer to Callback function
//   72 } bdbTLCBRec_t;
//   73 
//   74 /*********************************************************************
//   75  * GLOBAL VARIABLES
//   76  */
//   77 
//   78 /*********************************************************************
//   79  * GLOBAL FUNCTIONS
//   80  */
//   81 
//   82 /*********************************************************************
//   83  * LOCAL VARIABLES
//   84  */
//   85 static bdbTLCBRec_t *bdbTLCBs = (bdbTLCBRec_t *)NULL;
//   86 static uint8 bdbTLPluginRegisted = FALSE;
//   87 
//   88 static bdbTL_InterPANCallbacks_t *pInterPANCBs = (bdbTL_InterPANCallbacks_t *)NULL;
//   89 
//   90 /*********************************************************************
//   91  * LOCAL FUNCTIONS
//   92  */
//   93 
//   94 static ZStatus_t bdbTL_SendInterPANCommand( uint8 srcEP, afAddrType_t *destAddr, uint8 cmd,
//   95                                             uint8 direction, uint8 seqNum, uint16 cmdFormatLen, 
//   96                                             uint8 *cmdFormat );
//   97 static bdbTL_AppCallbacks_t *bdbTL_FindCallbacks( uint8 endpoint );
//   98 static ZStatus_t bdbTL_HdlIncoming( zclIncoming_t *pInMsg );
//   99 static ZStatus_t bdbTL_HdlInSpecificCommands( zclIncoming_t *pInMsg );
//  100 static ZStatus_t bdbTL_ProcessInLLCmds( zclIncoming_t *pInMsg, bdbTL_AppCallbacks_t *pCBs );
//  101 
//  102 static ZStatus_t bdbTL_ProcessInCmd_GetGrpIDsReq( zclIncoming_t *pInMsg, bdbTL_AppCallbacks_t *pCBs );
//  103 static ZStatus_t bdbTL_ProcessInCmd_GetEPListReq( zclIncoming_t *pInMsg, bdbTL_AppCallbacks_t *pCBs );
//  104 
//  105 static ZStatus_t bdbTL_ProcessInCmd_EndpointInfo( zclIncoming_t *pInMsg, bdbTL_AppCallbacks_t *pCBs );
//  106 static ZStatus_t bdbTL_ProcessInCmd_GetGrpIDsRsp( zclIncoming_t *pInMsg, bdbTL_AppCallbacks_t *pCBs );
//  107 static ZStatus_t bdbTL_ProcessInCmd_GetEPListRsp( zclIncoming_t *pInMsg, bdbTL_AppCallbacks_t *pCBs );
//  108 
//  109 static ZStatus_t bdbTL_HdlInInterPANCommands( zclIncoming_t *pInMsg );
//  110 static ZStatus_t bdbTL_ProcessInLLInterPANCmds( zclIncoming_t *pInMsg );
//  111 
//  112 static void bdbTL_ParseInCmd_NwkJoinReq( uint8 *pBuf, bdbTLNwkJoinReq_t *pReq );
//  113 
//  114 static ZStatus_t bdbTL_ProcessInCmd_ScanReq( zclIncoming_t *pInMsg );
//  115 static ZStatus_t bdbTL_ProcessInCmd_DeviceInfoReq( zclIncoming_t *pInMsg );
//  116 static ZStatus_t bdbTL_ProcessInCmd_IdentifyReq( zclIncoming_t *pInMsg );
//  117 static ZStatus_t bdbTL_ProcessInCmd_ResetToFNReq( zclIncoming_t *pInMsg );
//  118 static ZStatus_t bdbTL_ProcessInCmd_NwkStartReq( zclIncoming_t *pInMsg );
//  119 static ZStatus_t bdbTL_ProcessInCmd_NwkJoinRtrReq( zclIncoming_t *pInMsg );
//  120 static ZStatus_t bdbTL_ProcessInCmd_NwkJoinEDReq( zclIncoming_t *pInMsg );
//  121 static ZStatus_t bdbTL_ProcessInCmd_NwkUpdateReq( zclIncoming_t *pInMsg );
//  122 
//  123 static ZStatus_t bdbTL_ProcessInCmd_ScanRsp( zclIncoming_t *pInMsg );
//  124 static ZStatus_t bdbTL_ProcessInCmd_DeviceInfoRsp( zclIncoming_t *pInMsg );
//  125 static ZStatus_t bdbTL_ProcessInCmd_NwkStartRsp( zclIncoming_t *pInMsg );
//  126 static ZStatus_t bdbTL_ProcessInCmd_NwkJoinRtrRsp( zclIncoming_t *pInMsg );
//  127 static ZStatus_t bdbTL_ProcessInCmd_NwkJoinEDRsp( zclIncoming_t *pInMsg );
//  128 
//  129 
//  130 /*********************************************************************
//  131  * @fn      bdbTL_RegisterCmdCallbacks
//  132  *
//  133  * @brief   Register an applications command callbacks
//  134  *
//  135  * @param   endpoint - application's endpoint
//  136  * @param   callbacks - pointer to the callback record.
//  137  *
//  138  * @return  ZMemError if not able to allocate
//  139  */
//  140 ZStatus_t bdbTL_RegisterCmdCallbacks( uint8 endpoint, bdbTL_AppCallbacks_t *callbacks )
//  141 {
//  142   bdbTLCBRec_t *pNewItem;
//  143   bdbTLCBRec_t *pLoop;
//  144 
//  145   // Register as a ZCL Plugin
//  146   if ( !bdbTLPluginRegisted )
//  147   {
//  148     zcl_registerPlugin( ZCL_CLUSTER_ID_TOUCHLINK,
//  149                         ZCL_CLUSTER_ID_TOUCHLINK,
//  150                         bdbTL_HdlIncoming );
//  151     bdbTLPluginRegisted = TRUE;
//  152   }
//  153 
//  154   // Fill in the new profile list
//  155   pNewItem = zcl_mem_alloc( sizeof( bdbTLCBRec_t ) );
//  156   if ( pNewItem == NULL )
//  157     return (ZMemError);
//  158 
//  159   pNewItem->next = (bdbTLCBRec_t *)NULL;
//  160   pNewItem->endpoint = endpoint;
//  161   pNewItem->CBs = callbacks;
//  162 
//  163   // Find spot in list
//  164   if ( bdbTLCBs == NULL )
//  165   {
//  166     bdbTLCBs = pNewItem;
//  167   }
//  168   else
//  169   {
//  170     // Look for end of list
//  171     pLoop = bdbTLCBs;
//  172     while ( pLoop->next != NULL )
//  173       pLoop = pLoop->next;
//  174 
//  175     // Put new item at end of list
//  176     pLoop->next = pNewItem;
//  177   }
//  178 
//  179   return ( ZSuccess );
//  180 }
//  181 
//  182 /*********************************************************************
//  183  * @fn      bdbTL_RegisterInterPANCmdCallbacks
//  184  *
//  185  * @brief   Register an applications Inter-PAN command callbacks
//  186  *
//  187  * @param   callbacks - pointer to the callback record.
//  188  *
//  189  * @return  ZSuccess
//  190  */
//  191 ZStatus_t bdbTL_RegisterInterPANCmdCallbacks( bdbTL_InterPANCallbacks_t *callbacks )
//  192 {
//  193   // Register as a ZCL Plugin
//  194   if ( !bdbTLPluginRegisted )
//  195   {
//  196     zcl_registerPlugin( ZCL_CLUSTER_ID_TOUCHLINK,
//  197                         ZCL_CLUSTER_ID_TOUCHLINK,
//  198                         bdbTL_HdlIncoming );
//  199     bdbTLPluginRegisted = TRUE;
//  200   }
//  201   pInterPANCBs = callbacks;
//  202 
//  203   return ( ZSuccess );
//  204 }
//  205 
//  206 /*********************************************************************
//  207  * @fn      bdbTL_Send_ScanReq
//  208  *
//  209  * @brief   Call to send out an Scan Request command
//  210  *
//  211  * @param   srcEP - sending application's endpoint
//  212  * @param   dstAddr - where you want the message to go
//  213  * @param   pReq - request parameters
//  214  * @param   seqNum - sequence number
//  215  *
//  216  * @return  ZStatus_t
//  217  */
//  218 ZStatus_t bdbTL_Send_ScanReq( uint8 srcEP, afAddrType_t *dstAddr,
//  219                               bdbTLScanReq_t *pReq, uint8 seqNum )
//  220 {
//  221   uint8 buf[TOUCHLINK_CMDLEN_SCAN_REQ];
//  222 
//  223   VOID zcl_buffer_uint32( buf, pReq->transID );
//  224 
//  225   buf[4] = pReq->zInfo.zInfoByte;
//  226   buf[5] = pReq->touchLinkInfo.touchLinkInfoByte;
//  227 
//  228   return bdbTL_SendInterPANCommand( srcEP, dstAddr, COMMAND_TOUCHLINK_SCAN_REQ,
//  229                                     ZCL_FRAME_CLIENT_SERVER_DIR, seqNum, TOUCHLINK_CMDLEN_SCAN_REQ, buf );
//  230 }
//  231 
//  232 /*********************************************************************
//  233  * @fn      bdbTL_Send_DeviceInfoReq
//  234  *
//  235  * @brief   Call to send out a Device Information Request command
//  236  *
//  237  * @param   srcEP - sending application's endpoint
//  238  * @param   dstAddr - where you want the message to go
//  239  * @param   pReq - request parameters
//  240  * @param   seqNum - sequence number
//  241  *
//  242  * @return  ZStatus_t
//  243  */
//  244 ZStatus_t bdbTL_Send_DeviceInfoReq( uint8 srcEP, afAddrType_t *dstAddr,
//  245                                     bdbTLDeviceInfoReq_t *pReq, uint8 seqNum )
//  246 {
//  247   uint8 buf[TOUCHLINK_CMDLEN_DEVICE_INFO_REQ];
//  248 
//  249   VOID zcl_buffer_uint32( buf, pReq->transID );
//  250 
//  251   buf[4] = pReq->startIndex;
//  252 
//  253   return bdbTL_SendInterPANCommand( srcEP, dstAddr, COMMAND_TOUCHLINK_DEVICE_INFO_REQ,
//  254                                     ZCL_FRAME_CLIENT_SERVER_DIR, seqNum, TOUCHLINK_CMDLEN_DEVICE_INFO_REQ, buf );
//  255 }
//  256 
//  257 /*********************************************************************
//  258  * @fn      bdbTL_Send_IndentifyReq
//  259  *
//  260  * @brief   Call to send out a Identify Request command
//  261  *
//  262  * @param   srcEP - sending application's endpoint
//  263  * @param   dstAddr - where you want the message to go
//  264  * @param   pReq - request parameters
//  265  * @param   seqNum - sequence number
//  266  *
//  267  * @return  ZStatus_t
//  268  */
//  269 ZStatus_t bdbTL_Send_IndentifyReq( uint8 srcEP, afAddrType_t *dstAddr,
//  270                                    bdbTLIdentifyReq_t *pReq, uint8 seqNum )
//  271 {
//  272   uint8 buf[TOUCHLINK_CMDLEN_IDENTIFY_REQ];
//  273 
//  274   VOID zcl_buffer_uint32( buf, pReq->transID );
//  275 
//  276   buf[4] = LO_UINT16( pReq->IdDuration );
//  277   buf[5] = HI_UINT16( pReq->IdDuration );
//  278 
//  279   return bdbTL_SendInterPANCommand( srcEP, dstAddr, COMMAND_TOUCHLINK_IDENTIFY_REQ,
//  280                                     ZCL_FRAME_CLIENT_SERVER_DIR, seqNum, TOUCHLINK_CMDLEN_IDENTIFY_REQ, buf );
//  281 }
//  282 
//  283 /*********************************************************************
//  284  * @fn      bdbTL_Send_ResetToFNReq
//  285  *
//  286  * @brief   Call to send out a Reset to Factory New Request command
//  287  *
//  288  * @param   srcEP - sending application's endpoint
//  289  * @param   dstAddr - where you want the message to go
//  290  * @param   pReq - request parameters
//  291  * @param   seqNum - sequence number
//  292  *
//  293  * @return  ZStatus_t
//  294  */
//  295 ZStatus_t bdbTL_Send_ResetToFNReq( uint8 srcEP, afAddrType_t *dstAddr,
//  296                                    bdbTLResetToFNReq_t *pReq, uint8 seqNum )
//  297 {
//  298   uint8 buf[TOUCHLINK_CMDLEN_RESET_TO_FN_REQ];
//  299 
//  300   VOID zcl_buffer_uint32( buf, pReq->transID );
//  301 
//  302   return bdbTL_SendInterPANCommand( srcEP, dstAddr, COMMAND_TOUCHLINK_RESET_TO_FN_REQ,
//  303                                     ZCL_FRAME_CLIENT_SERVER_DIR, seqNum, TOUCHLINK_CMDLEN_RESET_TO_FN_REQ, buf );
//  304 }
//  305 
//  306 /*********************************************************************
//  307  * @fn      bdbTL_Send_NwkStartReq
//  308  *
//  309  * @brief   Call to send out a Network Start Request command
//  310  *
//  311  * @param   srcEP - sending application's endpoint
//  312  * @param   dstAddr - where you want the message to go
//  313  * @param   pRsp - response parameters
//  314  * @param   seqNum - sequence number
//  315  *
//  316  * @return  ZStatus_t
//  317  */
//  318 ZStatus_t bdbTL_Send_NwkStartReq( uint8 srcEP, afAddrType_t *dstAddr,
//  319                                   bdbTLNwkStartReq_t *pRsp, uint8 seqNum )
//  320 {
//  321   uint8 *buf;
//  322   uint8 *pBuf;
//  323   ZStatus_t status;
//  324 
//  325   buf = zcl_mem_alloc( TOUCHLINK_CMDLEN_NWK_START_REQ );
//  326   if ( buf != NULL )
//  327   {
//  328     pBuf = buf;
//  329 
//  330     pBuf = zcl_buffer_uint32( pBuf, pRsp->transID );
//  331     pBuf = zcl_cpyExtAddr( pBuf, pRsp->nwkParams.extendedPANID );
//  332 
//  333     *pBuf++ = pRsp->nwkParams.keyIndex;
//  334 
//  335     pBuf = zcl_memcpy( pBuf, pRsp->nwkParams.nwkKey, SEC_KEY_LEN );
//  336 
//  337     *pBuf++ = pRsp->nwkParams.logicalChannel;
//  338 
//  339     *pBuf++ = LO_UINT16( pRsp->nwkParams.panId );
//  340     *pBuf++ = HI_UINT16( pRsp->nwkParams.panId );
//  341 
//  342     *pBuf++ = LO_UINT16( pRsp->nwkParams.nwkAddr );
//  343     *pBuf++ = HI_UINT16( pRsp->nwkParams.nwkAddr );
//  344 
//  345     *pBuf++ = LO_UINT16( pRsp->nwkParams.grpIDsBegin );
//  346     *pBuf++ = HI_UINT16( pRsp->nwkParams.grpIDsBegin );
//  347 
//  348     *pBuf++ = LO_UINT16( pRsp->nwkParams.grpIDsEnd );
//  349     *pBuf++ = HI_UINT16( pRsp->nwkParams.grpIDsEnd );
//  350 
//  351     *pBuf++ = LO_UINT16( pRsp->nwkParams.freeNwkAddrBegin );
//  352     *pBuf++ = HI_UINT16( pRsp->nwkParams.freeNwkAddrBegin );
//  353 
//  354     *pBuf++ = LO_UINT16( pRsp->nwkParams.freeNwkAddrEnd );
//  355     *pBuf++ = HI_UINT16( pRsp->nwkParams.freeNwkAddrEnd );
//  356 
//  357     *pBuf++ = LO_UINT16( pRsp->nwkParams.freeGrpIDBegin );
//  358     *pBuf++ = HI_UINT16( pRsp->nwkParams.freeGrpIDBegin );
//  359 
//  360     *pBuf++ = LO_UINT16( pRsp->nwkParams.freeGrpIDEnd );
//  361     *pBuf++ = HI_UINT16( pRsp->nwkParams.freeGrpIDEnd );
//  362 
//  363     pBuf = zcl_cpyExtAddr( pBuf, pRsp->initiatorIeeeAddr );
//  364 
//  365     *pBuf++ = LO_UINT16( pRsp->initiatorNwkAddr );
//  366     *pBuf++ = HI_UINT16( pRsp->initiatorNwkAddr );
//  367 
//  368     status = bdbTL_SendInterPANCommand( srcEP, dstAddr, COMMAND_TOUCHLINK_NWK_START_REQ,
//  369                                         ZCL_FRAME_CLIENT_SERVER_DIR, seqNum, TOUCHLINK_CMDLEN_NWK_START_REQ, buf );
//  370     zcl_mem_free( buf );
//  371   }
//  372   else
//  373   {
//  374     status = ZMemError;
//  375   }
//  376 
//  377   return ( status );
//  378 }
//  379 
//  380 /*********************************************************************
//  381  * @fn      bdbTL_Send_NwkJoinReq
//  382  *
//  383  * @brief   Call to send out a Network Join Router/End Device Request command
//  384  *
//  385  * @param   srcEP - sending application's endpoint
//  386  * @param   dstAddr - where you want the message to go
//  387  * @param   pRsp - response parameters
//  388  * @param   cmd - COMMAND_TOUCHLINK_NWK_JOIN_RTR_REQ or COMMAND_TOUCHLINK_NWK_JOIN_ED_REQ
//  389  * @param   seqNum - sequence number
//  390  *
//  391  * @return  ZStatus_t
//  392  */
//  393 ZStatus_t bdbTL_Send_NwkJoinReq( uint8 srcEP, afAddrType_t *dstAddr,
//  394                                  bdbTLNwkJoinReq_t *pRsp, uint8 cmd, uint8 seqNum )
//  395 {
//  396   uint8 *buf;
//  397   uint8 *pBuf;
//  398   ZStatus_t status;
//  399 
//  400   buf = zcl_mem_alloc( TOUCHLINK_CMDLEN_NWK_JOIN_REQ );
//  401   if ( buf != NULL )
//  402   {
//  403     pBuf = buf;
//  404 
//  405     pBuf = zcl_buffer_uint32( pBuf, pRsp->transID );
//  406     pBuf = zcl_cpyExtAddr( pBuf, pRsp->nwkParams.extendedPANID );
//  407 
//  408     *pBuf++ = pRsp->nwkParams.keyIndex;
//  409 
//  410     pBuf = zcl_memcpy( pBuf, pRsp->nwkParams.nwkKey, SEC_KEY_LEN );
//  411 
//  412     *pBuf++ = pRsp->nwkUpdateId;
//  413     *pBuf++ = pRsp->nwkParams.logicalChannel;
//  414 
//  415     *pBuf++ = LO_UINT16( pRsp->nwkParams.panId );
//  416     *pBuf++ = HI_UINT16( pRsp->nwkParams.panId );
//  417 
//  418     *pBuf++ = LO_UINT16( pRsp->nwkParams.nwkAddr );
//  419     *pBuf++ = HI_UINT16( pRsp->nwkParams.nwkAddr );
//  420 
//  421     *pBuf++ = LO_UINT16( pRsp->nwkParams.grpIDsBegin );
//  422     *pBuf++ = HI_UINT16( pRsp->nwkParams.grpIDsBegin );
//  423 
//  424     *pBuf++ = LO_UINT16( pRsp->nwkParams.grpIDsEnd );
//  425     *pBuf++ = HI_UINT16( pRsp->nwkParams.grpIDsEnd );
//  426 
//  427     *pBuf++ = LO_UINT16( pRsp->nwkParams.freeNwkAddrBegin );
//  428     *pBuf++ = HI_UINT16( pRsp->nwkParams.freeNwkAddrBegin );
//  429 
//  430     *pBuf++ = LO_UINT16( pRsp->nwkParams.freeNwkAddrEnd );
//  431     *pBuf++ = HI_UINT16( pRsp->nwkParams.freeNwkAddrEnd );
//  432 
//  433     *pBuf++ = LO_UINT16( pRsp->nwkParams.freeGrpIDBegin );
//  434     *pBuf++ = HI_UINT16( pRsp->nwkParams.freeGrpIDBegin );
//  435 
//  436     *pBuf++ = LO_UINT16( pRsp->nwkParams.freeGrpIDEnd );
//  437     *pBuf++ = HI_UINT16( pRsp->nwkParams.freeGrpIDEnd );
//  438 
//  439     status = bdbTL_SendInterPANCommand( srcEP, dstAddr, cmd, ZCL_FRAME_CLIENT_SERVER_DIR, seqNum,
//  440                                         TOUCHLINK_CMDLEN_NWK_JOIN_REQ, buf );
//  441     zcl_mem_free( buf );
//  442   }
//  443   else
//  444   {
//  445     status = ZMemError;
//  446   }
//  447 
//  448   return ( status );
//  449 }
//  450 
//  451 /*********************************************************************
//  452  * @fn      bdbTL_Send_NwkUpdateReq
//  453  *
//  454  * @brief   Call to send out a Network Update Request command
//  455  *
//  456  * @param   srcEP - sending application's endpoint
//  457  * @param   dstAddr - where you want the message to go
//  458  * @param   pReq - response parameters
//  459  * @param   seqNum - sequence number
//  460  *
//  461  * @return  ZStatus_t
//  462  */
//  463 ZStatus_t bdbTL_Send_NwkUpdateReq( uint8 srcEP, afAddrType_t *dstAddr,
//  464                                    bdbTLNwkUpdateReq_t *pReq, uint8 seqNum )
//  465 {
//  466   uint8 *buf;
//  467   uint8 *pBuf;
//  468   ZStatus_t status;
//  469 
//  470   buf = zcl_mem_alloc( TOUCHLINK_CMDLEN_NWK_UPDATE_REQ );
//  471   if ( buf != NULL )
//  472   {
//  473     pBuf = buf;
//  474 
//  475     pBuf = zcl_buffer_uint32( pBuf, pReq->transID );
//  476     pBuf = zcl_cpyExtAddr( pBuf, pReq->extendedPANID );
//  477 
//  478     *pBuf++ = pReq->nwkUpdateId;
//  479     *pBuf++ = pReq->logicalChannel;
//  480 
//  481     *pBuf++ = LO_UINT16( pReq->PANID );
//  482     *pBuf++ = HI_UINT16( pReq->PANID );
//  483 
//  484     *pBuf++ = LO_UINT16( pReq->nwkAddr );
//  485     *pBuf++ = HI_UINT16( pReq->nwkAddr );
//  486 
//  487     status = bdbTL_SendInterPANCommand( srcEP, dstAddr, COMMAND_TOUCHLINK_NWK_UPDATE_REQ,
//  488                                         ZCL_FRAME_CLIENT_SERVER_DIR, seqNum, TOUCHLINK_CMDLEN_NWK_UPDATE_REQ, buf );
//  489     zcl_mem_free( buf );
//  490   }
//  491   else
//  492   {
//  493     status = ZMemError;
//  494   }
//  495 
//  496   return ( status );
//  497 }
//  498 
//  499 /*********************************************************************
//  500  * @fn      bdbTL_Send_ScanRsp
//  501  *
//  502  * @brief   Call to send out an Scan Response command
//  503  *
//  504  * @param   srcEP - sending application's endpoint
//  505  * @param   dstAddr - where you want the message to go
//  506  * @param   pRsp - response parameters
//  507  * @param   seqNum - sequence number
//  508  *
//  509  * @return  ZStatus_t
//  510  */
//  511 ZStatus_t bdbTL_Send_ScanRsp( uint8 srcEP, afAddrType_t *dstAddr,
//  512                               bdbTLScanRsp_t *pRsp, uint8 seqNum )
//  513 {
//  514   uint8 *buf;
//  515   uint8 bufLen = TOUCHLINK_CMDLEN_SCAN_RSP;
//  516   ZStatus_t status;
//  517 
//  518   // Calculate the total length needed
//  519   if ( pRsp->numSubDevices == 1 )
//  520   {
//  521     bufLen += TOUCHLINK_CMDLENOPTIONAL_SCAN_RSP;
//  522   }
//  523 
//  524   buf = zcl_mem_alloc( bufLen );
//  525   if ( buf != NULL )
//  526   {
//  527     uint8 *pBuf = buf;
//  528 
//  529     pBuf = zcl_buffer_uint32( pBuf, pRsp->transID );
//  530 
//  531     *pBuf++ = pRsp->rssiCorrection;
//  532     *pBuf++ = pRsp->zInfo.zInfoByte;
//  533     *pBuf++ = pRsp->touchLinkInfo.touchLinkInfoByte;
//  534 
//  535     *pBuf++ = LO_UINT16( pRsp->keyBitmask );
//  536     *pBuf++ = HI_UINT16( pRsp->keyBitmask );
//  537 
//  538     pBuf = zcl_buffer_uint32( pBuf, pRsp->responseID );
//  539     pBuf = zcl_cpyExtAddr( pBuf, pRsp->extendedPANID );
//  540 
//  541     *pBuf++ = pRsp->nwkUpdateId;
//  542     *pBuf++ = pRsp->logicalChannel;
//  543 
//  544     *pBuf++ = LO_UINT16( pRsp->PANID );
//  545     *pBuf++ = HI_UINT16( pRsp->PANID );
//  546 
//  547     *pBuf++ = LO_UINT16( pRsp->nwkAddr );
//  548     *pBuf++ = HI_UINT16( pRsp->nwkAddr );
//  549 
//  550     *pBuf++ = pRsp->numSubDevices;
//  551     *pBuf++ = pRsp->totalGrpIDs;
//  552 
//  553     if ( pRsp->numSubDevices == 1 )
//  554     {
//  555       *pBuf++ = pRsp->deviceInfo.endpoint;
//  556 
//  557       *pBuf++ = LO_UINT16( pRsp->deviceInfo.profileID );
//  558       *pBuf++ = HI_UINT16( pRsp->deviceInfo.profileID );
//  559 
//  560       *pBuf++ = LO_UINT16( pRsp->deviceInfo.deviceID );
//  561       *pBuf++ = HI_UINT16( pRsp->deviceInfo.deviceID );
//  562 
//  563       *pBuf++ = pRsp->deviceInfo.version;
//  564       *pBuf++ = pRsp->deviceInfo.grpIdCnt;
//  565     }
//  566 
//  567     status = bdbTL_SendInterPANCommand( srcEP, dstAddr, COMMAND_TOUCHLINK_SCAN_RSP,
//  568                                         ZCL_FRAME_SERVER_CLIENT_DIR, seqNum, bufLen, buf );
//  569     zcl_mem_free( buf );
//  570   }
//  571   else
//  572   {
//  573     status = ZMemError;
//  574   }
//  575 
//  576   return ( status );
//  577 }
//  578 
//  579 /*********************************************************************
//  580  * @fn      bdbTL_Send_DeviceInfoRsp
//  581  *
//  582  * @brief   Call to send out a Device Information Response command
//  583  *
//  584  * @param   srcEP - sending application's endpoint
//  585  * @param   dstAddr - where you want the message to go
//  586  * @param   pRsp - response parameters
//  587  * @param   seqNum - sequence number
//  588  *
//  589  * @return  ZStatus_t
//  590  */
//  591 ZStatus_t bdbTL_Send_DeviceInfoRsp( uint8 srcEP, afAddrType_t *dstAddr,
//  592                                     bdbTLDeviceInfoRsp_t *pRsp, uint8 seqNum )
//  593 {
//  594   uint8 *buf;
//  595   uint8 bufLen = TOUCHLINK_CMDLEN_DEVICE_INFO_RSP;
//  596   ZStatus_t status;
//  597 
//  598   // Calculate the total length needed
//  599   bufLen += ( pRsp->cnt * TOUCHLINK_CMDLENOPTIONAL_DEVICE_INFO_RSP );
//  600 
//  601   buf = zcl_mem_alloc( bufLen );
//  602   if ( buf != NULL )
//  603   {
//  604     uint8 *pBuf = buf;
//  605     uint8 i;
//  606 
//  607     pBuf = zcl_buffer_uint32( pBuf, pRsp->transID );
//  608 
//  609     *pBuf++ = pRsp->numSubDevices;
//  610     *pBuf++ = pRsp->startIndex;
//  611     *pBuf++ = pRsp->cnt;
//  612 
//  613     // Device information record
//  614     for ( i = 0; i < pRsp->cnt; i++ )
//  615     {
//  616       devInfoRec_t *pRec = &(pRsp->devInfoRec[i]);
//  617 
//  618       pBuf = zcl_cpyExtAddr( pBuf, pRec->ieeeAddr );
//  619 
//  620       *pBuf++ = pRec->deviceInfo.endpoint;
//  621 
//  622       *pBuf++ = LO_UINT16( pRec->deviceInfo.profileID );
//  623       *pBuf++ = HI_UINT16( pRec->deviceInfo.profileID );
//  624 
//  625       *pBuf++ = LO_UINT16( pRec->deviceInfo.deviceID );
//  626       *pBuf++ = HI_UINT16( pRec->deviceInfo.deviceID );
//  627 
//  628       *pBuf++ = pRec->deviceInfo.version;
//  629       *pBuf++ = pRec->deviceInfo.grpIdCnt;
//  630 
//  631       *pBuf++ = pRec->sort;
//  632     }
//  633 
//  634     status = bdbTL_SendInterPANCommand( srcEP, dstAddr, COMMAND_TOUCHLINK_DEVICE_INFO_RSP,
//  635                                         ZCL_FRAME_SERVER_CLIENT_DIR, seqNum, bufLen, buf );
//  636     zcl_mem_free( buf );
//  637   }
//  638   else
//  639   {
//  640     status = ZMemError;
//  641   }
//  642 
//  643   return ( status );
//  644 }
//  645 
//  646 /*********************************************************************
//  647  * @fn      bdbTL_Send_NwkStartRsp
//  648  *
//  649  * @brief   Call to send out a Network Start Response command
//  650  *
//  651  * @param   srcEP - sending application's endpoint
//  652  * @param   dstAddr - where you want the message to go
//  653  * @param   pRsp - response parameters
//  654  * @param   seqNum - sequence number
//  655  *
//  656  * @return  ZStatus_t
//  657  */
//  658 ZStatus_t bdbTL_Send_NwkStartRsp( uint8 srcEP, afAddrType_t *dstAddr,
//  659                                   bdbTLNwkStartRsp_t *pRsp, uint8 seqNum )
//  660 {
//  661   uint8 *buf;
//  662   ZStatus_t status;
//  663 
//  664   buf = zcl_mem_alloc( TOUCHLINK_CMDLEN_NWK_START_RSP );
//  665   if ( buf != NULL )
//  666   {
//  667     uint8 *pBuf = buf;
//  668 
//  669     pBuf = zcl_buffer_uint32( pBuf, pRsp->transID );
//  670 
//  671     *pBuf++ = pRsp->status;
//  672 
//  673     pBuf = zcl_cpyExtAddr( pBuf, pRsp->extendedPANID );
//  674 
//  675     *pBuf++ = pRsp->nwkUpdateId;
//  676     *pBuf++ = pRsp->logicalChannel;
//  677 
//  678     *pBuf++ = LO_UINT16( pRsp->panId );
//  679     *pBuf++ = HI_UINT16( pRsp->panId );
//  680 
//  681     status = bdbTL_SendInterPANCommand( srcEP, dstAddr, COMMAND_TOUCHLINK_NWK_START_RSP,
//  682                                         ZCL_FRAME_SERVER_CLIENT_DIR, seqNum, TOUCHLINK_CMDLEN_NWK_START_RSP, buf );
//  683     zcl_mem_free( buf );
//  684   }
//  685   else
//  686   {
//  687     status = ZMemError;
//  688   }
//  689 
//  690   return ( status );
//  691 }
//  692 
//  693 /*********************************************************************
//  694  * @fn      bdbTL_Send_NwkJoinRsp
//  695  *
//  696  * @brief   Call to send out a Network Join Response command
//  697  *
//  698  * @param   srcEP - sending application's endpoint
//  699  * @param   dstAddr - where you want the message to go
//  700  * @param   pRsp - response parameters
//  701  * @param   cmd - COMMAND_TOUCHLINK_NWK_JOIN_RTR_RSP or COMMAND_TOUCHLINK_NWK_JOIN_ED_RSP
//  702  * @param   seqNum - sequence number
//  703  *
//  704  * @return  ZStatus_t
//  705  */
//  706 ZStatus_t bdbTL_Send_NwkJoinRsp( uint8 srcEP, afAddrType_t *dstAddr,
//  707                                  bdbTLNwkJoinRsp_t *pRsp, uint8 cmd, uint8 seqNum )
//  708 {
//  709   uint8 buf[TOUCHLINK_CMDLEN_NWK_JOIN_RSP];
//  710 
//  711   VOID zcl_buffer_uint32( buf, pRsp->transID );
//  712 
//  713   buf[4] = pRsp->status;
//  714 
//  715   return bdbTL_SendInterPANCommand( srcEP, dstAddr, cmd, ZCL_FRAME_SERVER_CLIENT_DIR, seqNum,
//  716                                     TOUCHLINK_CMDLEN_NWK_JOIN_RSP, buf );
//  717 }
//  718 
//  719 /*********************************************************************
//  720  * @fn      bdbTL_Send_EndpointInfo
//  721  *
//  722  * @brief   Call to send out an Endpoint Information command
//  723  *
//  724  * @param   srcEP - sending application's endpoint
//  725  * @param   dstAddr - where you want the message to go
//  726  * @param   pCmd - cmd parameters
//  727  * @param   disableDefaultRsp - whether to disable the Default Response command
//  728  * @param   seqNum - sequence number
//  729  *
//  730  * @return  ZStatus_t
//  731  */
//  732 ZStatus_t bdbTL_Send_EndpointInfo( uint8 srcEP, afAddrType_t *dstAddr,
//  733                                    bdbTLEndpointInfo_t *pCmd,
//  734                                    uint8 disableDefaultRsp, uint8 seqNum )
//  735 {
//  736   uint8 *buf;
//  737   ZStatus_t status;
//  738 
//  739   buf = zcl_mem_alloc( TOUCHLINK_CMDLEN_EP_INFO );
//  740   if ( buf != NULL )
//  741   {
//  742     uint8 *pBuf = buf;
//  743 
//  744     pBuf = zcl_cpyExtAddr( pBuf, pCmd->ieeeAddr );
//  745 
//  746     *pBuf++ = LO_UINT16( pCmd->nwkAddr );
//  747     *pBuf++ = HI_UINT16( pCmd->nwkAddr );
//  748 
//  749     *pBuf++ = pCmd->endpoint;
//  750 
//  751     *pBuf++ = LO_UINT16( pCmd->profileID );
//  752     *pBuf++ = HI_UINT16( pCmd->profileID );
//  753 
//  754     *pBuf++ = LO_UINT16( pCmd->deviceID );
//  755     *pBuf++ = HI_UINT16( pCmd->deviceID );
//  756 
//  757     *pBuf++ = pCmd->version;
//  758 
//  759     status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_TOUCHLINK,
//  760                               COMMAND_TOUCHLINK_EP_INFO, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
//  761                               disableDefaultRsp, 0, seqNum, TOUCHLINK_CMDLEN_EP_INFO, buf );
//  762     zcl_mem_free( buf );
//  763   }
//  764   else
//  765   {
//  766     status = ZMemError;
//  767   }
//  768 
//  769   return ( status );
//  770 }
//  771 
//  772 /*********************************************************************
//  773  * @fn      bdbTL_Send_GetGrpIDsRsp
//  774  *
//  775  * @brief   Call to send out a Get Group Identifiers Response command
//  776  *
//  777  * @param   srcEP - sending application's endpoint
//  778  * @param   dstAddr - where you want the message to go
//  779  * @param   pRsp - response parameters
//  780  * @param   disableDefaultRsp - whether to disable the Default Response command
//  781  * @param   seqNum - sequence number
//  782  *
//  783  * @return  ZStatus_t
//  784  */
//  785 ZStatus_t bdbTL_Send_GetGrpIDsRsp( uint8 srcEP, afAddrType_t *dstAddr,
//  786                                     bdbTLGetGrpIDsRsp_t *pRsp,
//  787                                     uint8 disableDefaultRsp, uint8 seqNum )
//  788 {
//  789   uint8 *buf;
//  790   uint8 bufLen = TOUCHLINK_CMDLEN_GET_GRP_IDS_RSP;
//  791   ZStatus_t status;
//  792 
//  793   // Calculate the total length needed
//  794   bufLen += ( pRsp->cnt * TOUCHLINK_CMDLENOPTIONAL_GET_GRP_IDS_RSP );
//  795 
//  796   buf = zcl_mem_alloc( bufLen );
//  797   if ( buf != NULL )
//  798   {
//  799     uint8 *pBuf = buf;
//  800     uint8 i;
//  801 
//  802     *pBuf++ = pRsp->total;
//  803     *pBuf++ = pRsp->startIndex;
//  804     *pBuf++ = pRsp->cnt;
//  805 
//  806     // Group information record
//  807     for ( i = 0; i < pRsp->cnt; i++ )
//  808     {
//  809       grpInfoRec_t *pRec = &(pRsp->grpInfoRec[i]);
//  810 
//  811       *pBuf++ = LO_UINT16( pRec->grpID );
//  812       *pBuf++ = HI_UINT16( pRec->grpID );
//  813 
//  814       *pBuf++ = pRec->grpType;
//  815     }
//  816 
//  817     status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_TOUCHLINK,
//  818                               COMMAND_TOUCHLINK_GET_GRP_IDS_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
//  819                               disableDefaultRsp, 0, seqNum, bufLen, buf );
//  820     zcl_mem_free( buf );
//  821   }
//  822   else
//  823   {
//  824     status = ZMemError;
//  825   }
//  826 
//  827   return ( status );
//  828 }
//  829 
//  830 /*********************************************************************
//  831  * @fn      bdbTL_Send_GetEPListRsp
//  832  *
//  833  * @brief   Call to send out a Get Endpoint List Response command
//  834  *
//  835  * @param   srcEP - sending application's endpoint
//  836  * @param   dstAddr - where you want the message to go
//  837  * @param   pRsp - response parameters
//  838  * @param   disableDefaultRsp - whether to disable the Default Response command
//  839  * @param   seqNum - sequence number
//  840  *
//  841  * @return  ZStatus_t
//  842  */
//  843 ZStatus_t bdbTL_Send_GetEPListRsp( uint8 srcEP, afAddrType_t *dstAddr,
//  844                                    bdbTLGetEPListRsp_t *pRsp,
//  845                                    uint8 disableDefaultRsp, uint8 seqNum )
//  846 {
//  847   uint8 *buf;
//  848   uint8 bufLen = TOUCHLINK_CMDLEN_GET_EP_LIST_RSP;
//  849   ZStatus_t status;
//  850 
//  851   // Calculate the total length needed
//  852   bufLen += ( pRsp->cnt * TOUCHLINK_CMDLENOPTIONAL_GET_EP_LIST_RSP );
//  853 
//  854   buf = zcl_mem_alloc( bufLen );
//  855   if ( buf != NULL )
//  856   {
//  857     uint8 *pBuf = buf;
//  858     uint8 i;
//  859 
//  860     *pBuf++ = pRsp->total;
//  861     *pBuf++ = pRsp->startIndex;
//  862     *pBuf++ = pRsp->cnt;
//  863 
//  864     // Endpoint information record
//  865     for ( i = 0; i < pRsp->cnt; i++ )
//  866     {
//  867       epInfoRec_t *pRec = &(pRsp->epInfoRec[i]);
//  868 
//  869       *pBuf++ = LO_UINT16( pRec->nwkAddr );
//  870       *pBuf++ = HI_UINT16( pRec->nwkAddr );
//  871 
//  872       *pBuf++ = pRec->endpoint;
//  873 
//  874       *pBuf++ = LO_UINT16( pRec->profileID );
//  875       *pBuf++ = HI_UINT16( pRec->profileID );
//  876 
//  877       *pBuf++ = LO_UINT16( pRec->deviceID );
//  878       *pBuf++ = HI_UINT16( pRec->deviceID );
//  879 
//  880       *pBuf++ = pRec->version;
//  881     }
//  882 
//  883     status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_TOUCHLINK,
//  884                               COMMAND_TOUCHLINK_GET_EP_LIST_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
//  885                               disableDefaultRsp, 0, seqNum, bufLen, buf );
//  886     zcl_mem_free( buf );
//  887   }
//  888   else
//  889   {
//  890     status = ZMemError;
//  891   }
//  892 
//  893   return ( status );
//  894 }
//  895 
//  896 /*********************************************************************
//  897  * @fn      bdbTL_SendInterPANCommand
//  898  *
//  899  * @brief   Used to send TOUCHLINK Profile and Cluster Specific Inter-PAN Command
//  900  *          messages.
//  901  *
//  902  *          NOTE: The calling application is responsible for incrementing
//  903  *                the Sequence Number.
//  904  *
//  905  * @param   srcEp - source endpoint
//  906  * @param   destAddr - destination address
//  907  * @param   cmd - command ID
//  908  * @param   direction - direction of the command
//  909  * @param   seqNumber - identification number for the transaction
//  910  * @param   cmdFormatLen - length of the command to be sent
//  911  * @param   cmdFormat - command to be sent
//  912  *
//  913  * @return  ZSuccess if OK
//  914  */
//  915 ZStatus_t bdbTL_SendInterPANCommand( uint8 srcEP, afAddrType_t *destAddr, uint8 cmd,
//  916                                      uint8 direction, uint8 seqNum, uint16 cmdFormatLen, uint8 *cmdFormat )
//  917 {
//  918   //
//  919   // Note: TOUCHLINK Frame Control has a defferent format than ZCL Frame Control
//  920   //
//  921 
//  922   // TOUCHLINK Header Format:
//  923   // - Frame control (1 octect):
//  924   //   * b3-b0: TOUCHLINK version (0b0000)
//  925   //   * b7-b4: Reserved (0b0000)
//  926   // - Transaction sequence number (1 octet)
//  927   // - Command identifier (1 octect)
//  928   return zcl_SendCommand( srcEP, destAddr, ZCL_CLUSTER_ID_TOUCHLINK,
//  929                           cmd, TRUE, direction, TRUE, 0,
//  930                           seqNum, cmdFormatLen, cmdFormat );
//  931 }
//  932 
//  933 /*********************************************************************
//  934  * @fn      bdbTL_FindCallbacks
//  935  *
//  936  * @brief   Find the callbacks for an endpoint
//  937  *
//  938  * @param   endpoint
//  939  *
//  940  * @return  pointer to the callbacks
//  941  */
//  942 static bdbTL_AppCallbacks_t *bdbTL_FindCallbacks( uint8 endpoint )
//  943 {
//  944   bdbTLCBRec_t *pCBs;
//  945 
//  946   pCBs = bdbTLCBs;
//  947   while ( pCBs )
//  948   {
//  949     if ( pCBs->endpoint == endpoint )
//  950       return ( pCBs->CBs );
//  951     pCBs = pCBs->next;
//  952   }
//  953 
//  954   return ( (bdbTL_AppCallbacks_t *)NULL );
//  955 }
//  956 
//  957 /*********************************************************************
//  958  * @fn      bdbTL_HdlIncoming
//  959  *
//  960  * @brief   Callback from ZCL to process incoming Commands specific
//  961  *          to this cluster library or Profile commands for attributes
//  962  *          that aren't in the attribute list
//  963  *
//  964  * @param   pInMsg - pointer to the incoming message
//  965  *
//  966  * @return  ZStatus_t
//  967  */
//  968 static ZStatus_t bdbTL_HdlIncoming(  zclIncoming_t *pInMsg )
//  969 {
//  970   ZStatus_t status = ZSuccess;
//  971 
//  972   if ( StubAPS_InterPan( pInMsg->msg->srcAddr.panId, pInMsg->msg->srcAddr.endPoint ) )
//  973   {
//  974     return ( bdbTL_HdlInInterPANCommands( pInMsg ) );
//  975   }
//  976 
//  977   if ( zcl_ClusterCmd( pInMsg->hdr.fc.type ) )
//  978   {
//  979     // Is this a manufacturer specific command?
//  980     if ( pInMsg->hdr.fc.manuSpecific == 0 )
//  981     {
//  982       status = bdbTL_HdlInSpecificCommands( pInMsg );
//  983     }
//  984     else
//  985     {
//  986       // We don't support any manufacturer specific command.
//  987       status = ZFailure;
//  988     }
//  989   }
//  990   else
//  991   {
//  992     // Handle all the normal (Read, Write...) commands -- should never get here
//  993     status = ZFailure;
//  994   }
//  995   return ( status );
//  996 }
//  997 
//  998 /*********************************************************************
//  999  * @fn      bdbTL_HdlInSpecificCommands
// 1000  *
// 1001  * @brief   Callback from ZCL to process incoming Commands specific
// 1002  *          to this cluster library
// 1003  *
// 1004  * @param   pInMsg - pointer to the incoming message
// 1005  *
// 1006  * @return  ZStatus_t
// 1007  */
// 1008 static ZStatus_t bdbTL_HdlInSpecificCommands( zclIncoming_t *pInMsg )
// 1009 {
// 1010   ZStatus_t status;
// 1011   bdbTL_AppCallbacks_t *pCBs;
// 1012 
// 1013   // make sure endpoint exists
// 1014   pCBs = bdbTL_FindCallbacks( pInMsg->msg->endPoint );
// 1015   if ( pCBs == NULL )
// 1016     return ( ZFailure );
// 1017 
// 1018   switch ( pInMsg->msg->clusterId )
// 1019   {
// 1020     case ZCL_CLUSTER_ID_TOUCHLINK:
// 1021       status = bdbTL_ProcessInLLCmds( pInMsg, pCBs );
// 1022       break;
// 1023 
// 1024     default:
// 1025       status = ZFailure;
// 1026       break;
// 1027   }
// 1028 
// 1029   return ( status );
// 1030 }
// 1031 
// 1032 /*********************************************************************
// 1033  * @fn      bdbTL_ProcessInLLCmds
// 1034  *
// 1035  * @brief   Callback from ZCL to process incoming Commands specific
// 1036  *          to this cluster library on a command ID basis
// 1037  *
// 1038  * @param   pInMsg - pointer to the incoming message
// 1039  * @param   pCBs - pointer to callbacks
// 1040  *
// 1041  * @return  ZStatus_t
// 1042  */
// 1043 static ZStatus_t bdbTL_ProcessInLLCmds( zclIncoming_t *pInMsg, bdbTL_AppCallbacks_t *pCBs )
// 1044 {
// 1045   ZStatus_t status = SUCCESS;
// 1046 
// 1047   if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
// 1048   {
// 1049     switch ( pInMsg->hdr.commandID )
// 1050     {
// 1051       case COMMAND_TOUCHLINK_GET_GRP_IDS_REQ:
// 1052         status = bdbTL_ProcessInCmd_GetGrpIDsReq( pInMsg, pCBs );
// 1053         break;
// 1054 
// 1055       case COMMAND_TOUCHLINK_GET_EP_LIST_REQ:
// 1056         status = bdbTL_ProcessInCmd_GetEPListReq( pInMsg, pCBs );
// 1057         break;
// 1058 
// 1059       default:
// 1060         status = ZFailure;   // Error ignore the command
// 1061         break;
// 1062      }
// 1063   }
// 1064   else // Client Commands
// 1065   {
// 1066     switch ( pInMsg->hdr.commandID )
// 1067     {
// 1068       case COMMAND_TOUCHLINK_EP_INFO:
// 1069         status = bdbTL_ProcessInCmd_EndpointInfo( pInMsg, pCBs );
// 1070         break;
// 1071 
// 1072       case COMMAND_TOUCHLINK_GET_GRP_IDS_RSP:
// 1073         status = bdbTL_ProcessInCmd_GetGrpIDsRsp( pInMsg, pCBs );
// 1074         break;
// 1075 
// 1076       case COMMAND_TOUCHLINK_GET_EP_LIST_RSP:
// 1077         status = bdbTL_ProcessInCmd_GetEPListRsp( pInMsg, pCBs );
// 1078         break;
// 1079 
// 1080       default:
// 1081         status = ZFailure;   // Error ignore the command
// 1082         break;
// 1083     }
// 1084   }
// 1085 
// 1086   return ( status );
// 1087 }
// 1088 
// 1089 
// 1090 /*********************************************************************
// 1091  * @fn      bdbTL_ProcessInCmd_GetGrpIDsReq
// 1092  *
// 1093  * @brief   Process in the received Get Group Identifiers Request command.
// 1094  *
// 1095  * @param   pInMsg - pointer to the incoming message
// 1096  * @param   pCBs - pointer to the application callbacks
// 1097  *
// 1098  * @return  ZStatus_t
// 1099  */
// 1100 static ZStatus_t bdbTL_ProcessInCmd_GetGrpIDsReq( zclIncoming_t *pInMsg,
// 1101                                                   bdbTL_AppCallbacks_t *pCBs )
// 1102 {
// 1103   if ( pCBs->pfnGetGrpIDsReq )
// 1104   {
// 1105     bdbTLGetGrpIDsReq_t req;
// 1106 
// 1107     req.startIndex = pInMsg->pData[0];
// 1108 
// 1109     if ( pCBs->pfnGetGrpIDsReq( &(pInMsg->msg->srcAddr), &req, pInMsg->hdr.transSeqNum ) == ZSuccess )
// 1110     {
// 1111       return ( ZCL_STATUS_CMD_HAS_RSP );
// 1112     }
// 1113   }
// 1114 
// 1115   return ( ZFailure );
// 1116 }
// 1117 
// 1118 /*********************************************************************
// 1119  * @fn      bdbTL_ProcessInCmd_GetEPListReq
// 1120  *
// 1121  * @brief   Process in the received Get Endpoint List Request command.
// 1122  *
// 1123  * @param   pInMsg - pointer to the incoming message
// 1124  * @param   pCBs - pointer to the application callbacks
// 1125  *
// 1126  * @return  ZStatus_t
// 1127  */
// 1128 static ZStatus_t bdbTL_ProcessInCmd_GetEPListReq( zclIncoming_t *pInMsg,
// 1129                                                   bdbTL_AppCallbacks_t *pCBs )
// 1130 {
// 1131   if ( pCBs->pfnGetEPListReq )
// 1132   {
// 1133     bdbTLGetEPListReq_t req;
// 1134 
// 1135     req.startIndex = pInMsg->pData[0];
// 1136 
// 1137     if ( pCBs->pfnGetEPListReq( &(pInMsg->msg->srcAddr), &req, pInMsg->hdr.transSeqNum ) == ZSuccess )
// 1138     {
// 1139       return ( ZCL_STATUS_CMD_HAS_RSP );
// 1140     }
// 1141   }
// 1142 
// 1143   return ( ZFailure );
// 1144 }
// 1145 
// 1146 
// 1147 /*********************************************************************
// 1148  * @fn      bdbTL_ProcessInCmd_EndpointInfo
// 1149  *
// 1150  * @brief   Process in the received Endpoint Information command.
// 1151  *
// 1152  * @param   pInMsg - pointer to the incoming message
// 1153  * @param   pCBs - pointer to the application callbacks
// 1154  *
// 1155  * @return  ZStatus_t
// 1156  */
// 1157 static ZStatus_t bdbTL_ProcessInCmd_EndpointInfo( zclIncoming_t *pInMsg,
// 1158                                                   bdbTL_AppCallbacks_t *pCBs )
// 1159 {
// 1160   ZStatus_t status = ZFailure;
// 1161 
// 1162   if ( pCBs->pfnEndpointInfo )
// 1163   {
// 1164     bdbTLEndpointInfo_t *pCmd;
// 1165 
// 1166     pCmd = (bdbTLEndpointInfo_t *)zcl_mem_alloc( sizeof( bdbTLEndpointInfo_t ) );
// 1167     if ( pCmd )
// 1168     {
// 1169       uint8 *pBuf = pInMsg->pData;
// 1170 
// 1171       zcl_cpyExtAddr( pCmd->ieeeAddr, pBuf );
// 1172       pBuf += Z_EXTADDR_LEN;
// 1173 
// 1174       pCmd->nwkAddr = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1175       pBuf += 2;
// 1176 
// 1177       pCmd->endpoint = *pBuf++;
// 1178 
// 1179       pCmd->profileID = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1180       pBuf += 2;
// 1181 
// 1182       pCmd->deviceID = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1183       pBuf += 2;
// 1184 
// 1185       pCmd->version = *pBuf++;
// 1186 
// 1187       status = pCBs->pfnEndpointInfo( &(pInMsg->msg->srcAddr), pCmd );
// 1188 
// 1189       zcl_mem_free( pCmd );
// 1190     }
// 1191   }
// 1192   else
// 1193   {
// 1194     status = ZSuccess;
// 1195   }
// 1196 
// 1197   return ( status );
// 1198 }
// 1199 
// 1200 /*********************************************************************
// 1201  * @fn      bdbTL_ProcessInCmd_GetGrpIDsRsp
// 1202  *
// 1203  * @brief   Process in the received Get Group Identifiers Response command.
// 1204  *
// 1205  * @param   pInMsg - pointer to the incoming message
// 1206  * @param   pCBs - pointer to the application callbacks
// 1207  *
// 1208  * @return  ZStatus_t
// 1209  */
// 1210 static ZStatus_t bdbTL_ProcessInCmd_GetGrpIDsRsp( zclIncoming_t *pInMsg,
// 1211                                                   bdbTL_AppCallbacks_t *pCBs )
// 1212 {
// 1213   ZStatus_t status = ZFailure;
// 1214 
// 1215   if ( pCBs->pfnGetGrpIDsRsp )
// 1216   {
// 1217     bdbTLGetGrpIDsRsp_t *pRsp;
// 1218     uint8 cnt = pInMsg->pData[TOUCHLINK_CMDLEN_GET_GRP_IDS_RSP-1];
// 1219     uint8 rspLen = sizeof( bdbTLGetGrpIDsRsp_t ) + ( cnt * sizeof( grpInfoRec_t ) );
// 1220 
// 1221     pRsp = (bdbTLGetGrpIDsRsp_t *)zcl_mem_alloc( rspLen );
// 1222     if ( pRsp )
// 1223     {
// 1224       uint8 *pBuf = pInMsg->pData;
// 1225       uint8 i;
// 1226 
// 1227       pRsp->total = *pBuf++;
// 1228       pRsp->startIndex = *pBuf++;
// 1229       pRsp->cnt = *pBuf++;
// 1230       pRsp->grpInfoRec = (grpInfoRec_t *)(pRsp+1);
// 1231 
// 1232       for ( i = 0; i < cnt; i++ )
// 1233       {
// 1234         grpInfoRec_t *pRec = &(pRsp->grpInfoRec[i]);
// 1235 
// 1236         pRec->grpID = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1237         pBuf += 2;
// 1238 
// 1239         pRec->grpType = *pBuf++;
// 1240       }
// 1241 
// 1242       status = pCBs->pfnGetGrpIDsRsp( &(pInMsg->msg->srcAddr), pRsp );
// 1243 
// 1244       zcl_mem_free( pRsp );
// 1245     }
// 1246   }
// 1247 
// 1248   return ( status );
// 1249 }
// 1250 
// 1251 /*********************************************************************
// 1252  * @fn      bdbTL_ProcessInCmd_GetEPListRsp
// 1253  *
// 1254  * @brief   Process in the received Get Endpoint List Response command.
// 1255  *
// 1256  * @param   pInMsg - pointer to the incoming message
// 1257  * @param   pCBs - pointer to the application callbacks
// 1258  *
// 1259  * @return  ZStatus_t
// 1260  */
// 1261 static ZStatus_t bdbTL_ProcessInCmd_GetEPListRsp( zclIncoming_t *pInMsg,
// 1262                                                   bdbTL_AppCallbacks_t *pCBs )
// 1263 {
// 1264   ZStatus_t status = ZFailure;
// 1265 
// 1266   if ( pCBs->pfnGetEPListRsp )
// 1267   {
// 1268     bdbTLGetEPListRsp_t *pRsp;
// 1269     uint8 cnt = pInMsg->pData[TOUCHLINK_CMDLEN_GET_EP_LIST_RSP-1];
// 1270     uint8 rspLen = sizeof( bdbTLGetEPListRsp_t ) + ( cnt * sizeof( epInfoRec_t ) );
// 1271 
// 1272     pRsp = (bdbTLGetEPListRsp_t *)zcl_mem_alloc( rspLen );
// 1273     if ( pRsp )
// 1274     {
// 1275       uint8 *pBuf = pInMsg->pData;
// 1276       uint8 i;
// 1277 
// 1278       pRsp->total = *pBuf++;
// 1279       pRsp->startIndex = *pBuf++;
// 1280       pRsp->cnt = *pBuf++;
// 1281       pRsp->epInfoRec = (epInfoRec_t *)(pRsp+1);
// 1282 
// 1283       for ( i = 0; i < cnt; i++ )
// 1284       {
// 1285         epInfoRec_t *pRec = &(pRsp->epInfoRec[i]);
// 1286 
// 1287         pRec->nwkAddr = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1288         pBuf += 2;
// 1289 
// 1290         pRec->endpoint = *pBuf++;
// 1291 
// 1292         pRec->profileID = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1293         pBuf += 2;
// 1294 
// 1295         pRec->deviceID = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1296         pBuf += 2;
// 1297 
// 1298         pRec->version = *pBuf++;
// 1299       }
// 1300 
// 1301       status = pCBs->pfnGetEPListRsp( &(pInMsg->msg->srcAddr), pRsp );
// 1302 
// 1303       zcl_mem_free( pRsp );
// 1304     }
// 1305   }
// 1306 
// 1307   return ( status );
// 1308 }
// 1309 
// 1310 /*********************************************************************
// 1311 * Inter-PAN functions
// 1312 **********************************************************************/
// 1313 
// 1314 /*********************************************************************
// 1315  * @fn      bdbTL_HdlInInterPANCommands
// 1316  *
// 1317  * @brief   Callback from ZCL to process incoming Inter-PAN Commands
// 1318  *          specific to this cluster library
// 1319 
// 1320  * @param   pInMsg - pointer to the incoming message
// 1321  *
// 1322  * @return  ZStatus_t
// 1323  */
// 1324 static ZStatus_t bdbTL_HdlInInterPANCommands( zclIncoming_t *pInMsg )
// 1325 {
// 1326   ZStatus_t status;
// 1327 
// 1328   // make sure Inter-PAN callbacks exist
// 1329   if ( pInterPANCBs == NULL )
// 1330     return ( ZFailure );
// 1331 
// 1332   switch ( pInMsg->msg->clusterId )
// 1333   {
// 1334     case ZCL_CLUSTER_ID_TOUCHLINK:
// 1335       status = bdbTL_ProcessInLLInterPANCmds( pInMsg );
// 1336       break;
// 1337 
// 1338     default:
// 1339       status = ZFailure;
// 1340       break;
// 1341   }
// 1342 
// 1343   return ( status );
// 1344 }
// 1345 
// 1346 /*********************************************************************
// 1347  * @fn      bdbTL_ProcessInLLInterPANCmds
// 1348  *
// 1349  * @brief   Callback from ZCL to process incoming Inter-PAN Commands
// 1350  *          specific to this cluster library on a command ID basis
// 1351  *
// 1352  * @param   pInMsg - pointer to the incoming message
// 1353  *
// 1354  * @return  ZStatus_t
// 1355  */
// 1356 static ZStatus_t bdbTL_ProcessInLLInterPANCmds( zclIncoming_t *pInMsg )
// 1357 {
// 1358   ZStatus_t status = SUCCESS;
// 1359   
// 1360 #if ( defined ( BDB_TL_TARGET ) && (BDB_TOUCHLINK_CAPABILITY_ENABLED == TRUE) )
// 1361   if ( touchLinkTargetEnabled == FALSE )
// 1362   {
// 1363     return status;
// 1364   }
// 1365 #endif
// 1366   
// 1367   switch ( pInMsg->hdr.commandID )
// 1368   {
// 1369     case COMMAND_TOUCHLINK_SCAN_REQ:
// 1370       status = bdbTL_ProcessInCmd_ScanReq( pInMsg );
// 1371       break;
// 1372 
// 1373     case COMMAND_TOUCHLINK_DEVICE_INFO_REQ:
// 1374       status = bdbTL_ProcessInCmd_DeviceInfoReq( pInMsg );
// 1375       break;
// 1376 
// 1377     case COMMAND_TOUCHLINK_IDENTIFY_REQ:
// 1378       status = bdbTL_ProcessInCmd_IdentifyReq( pInMsg );
// 1379       break;
// 1380 
// 1381     case COMMAND_TOUCHLINK_RESET_TO_FN_REQ:
// 1382       status = bdbTL_ProcessInCmd_ResetToFNReq( pInMsg );
// 1383       break;
// 1384 
// 1385     case COMMAND_TOUCHLINK_NWK_START_REQ:
// 1386       status = bdbTL_ProcessInCmd_NwkStartReq( pInMsg );
// 1387       break;
// 1388 
// 1389     case COMMAND_TOUCHLINK_NWK_JOIN_RTR_REQ:
// 1390       status = bdbTL_ProcessInCmd_NwkJoinRtrReq( pInMsg );
// 1391       break;
// 1392 
// 1393     case COMMAND_TOUCHLINK_NWK_JOIN_ED_REQ:
// 1394       status = bdbTL_ProcessInCmd_NwkJoinEDReq( pInMsg );
// 1395       break;
// 1396 
// 1397     case COMMAND_TOUCHLINK_NWK_UPDATE_REQ:
// 1398       status = bdbTL_ProcessInCmd_NwkUpdateReq( pInMsg );
// 1399       break;
// 1400 
// 1401     case COMMAND_TOUCHLINK_SCAN_RSP:
// 1402       status = bdbTL_ProcessInCmd_ScanRsp( pInMsg );
// 1403       break;
// 1404 
// 1405     case COMMAND_TOUCHLINK_DEVICE_INFO_RSP:
// 1406       status = bdbTL_ProcessInCmd_DeviceInfoRsp( pInMsg );
// 1407       break;
// 1408 
// 1409     case COMMAND_TOUCHLINK_NWK_START_RSP:
// 1410       status = bdbTL_ProcessInCmd_NwkStartRsp( pInMsg );
// 1411       break;
// 1412 
// 1413     case COMMAND_TOUCHLINK_NWK_JOIN_RTR_RSP:
// 1414       status = bdbTL_ProcessInCmd_NwkJoinRtrRsp( pInMsg );
// 1415       break;
// 1416 
// 1417     case COMMAND_TOUCHLINK_NWK_JOIN_ED_RSP:
// 1418       status = bdbTL_ProcessInCmd_NwkJoinEDRsp( pInMsg );
// 1419       break;
// 1420 
// 1421     default:
// 1422       status = ZFailure;   // Error ignore the command
// 1423       break;
// 1424   }
// 1425 
// 1426   return ( status );
// 1427 }
// 1428 
// 1429 /*********************************************************************
// 1430  * @fn      bdbTL_ProcessInCmd_ScanReq
// 1431  *
// 1432  * @brief   Process in the received Scan Request command.
// 1433  *
// 1434  * @param   pInMsg - pointer to the incoming message
// 1435  *
// 1436  * @return  ZStatus_t
// 1437  */
// 1438 static ZStatus_t bdbTL_ProcessInCmd_ScanReq( zclIncoming_t *pInMsg )
// 1439 {
// 1440   if ( pInterPANCBs->pfnScanReq )
// 1441   {
// 1442     bdbTLScanReq_t req;
// 1443 
// 1444     req.transID = zcl_build_uint32( pInMsg->pData, 4 );
// 1445 
// 1446     req.zInfo.zInfoByte = pInMsg->pData[4];
// 1447     req.touchLinkInfo.touchLinkInfoByte = pInMsg->pData[5];
// 1448 
// 1449     return ( pInterPANCBs->pfnScanReq( &(pInMsg->msg->srcAddr), &req,
// 1450                                        pInMsg->hdr.transSeqNum ) );
// 1451   }
// 1452 
// 1453   return ( ZSuccess );
// 1454 }
// 1455 
// 1456 /*********************************************************************
// 1457  * @fn      bdbTL_ProcessInCmd_DeviceInfoReq
// 1458  *
// 1459  * @brief   Process in the received Device Information Request command.
// 1460  *
// 1461  * @param   pInMsg - pointer to the incoming message
// 1462  *
// 1463  * @return  ZStatus_t
// 1464  */
// 1465 static ZStatus_t bdbTL_ProcessInCmd_DeviceInfoReq( zclIncoming_t *pInMsg )
// 1466 {
// 1467   if ( pInterPANCBs->pfnDeviceInfoReq )
// 1468   {
// 1469     bdbTLDeviceInfoReq_t req;
// 1470 
// 1471     req.transID = zcl_build_uint32( pInMsg->pData, 4 );
// 1472 
// 1473     req.startIndex = pInMsg->pData[4];
// 1474 
// 1475     return ( pInterPANCBs->pfnDeviceInfoReq( &(pInMsg->msg->srcAddr), &req,
// 1476                                              pInMsg->hdr.transSeqNum ) );
// 1477   }
// 1478 
// 1479   return ( ZSuccess );
// 1480 }
// 1481 
// 1482 
// 1483 /*********************************************************************
// 1484  * @fn      bdbTL_ProcessInCmd_IdentifyReq
// 1485  *
// 1486  * @brief   Process in the received Identify Request command.
// 1487  *
// 1488  * @param   pInMsg - pointer to the incoming message
// 1489  *
// 1490  * @return  ZStatus_t
// 1491  */
// 1492 static ZStatus_t bdbTL_ProcessInCmd_IdentifyReq( zclIncoming_t *pInMsg )
// 1493 {
// 1494   if ( pInterPANCBs->pfnIdentifyReq )
// 1495   {
// 1496     bdbTLIdentifyReq_t req;
// 1497 
// 1498     req.transID = zcl_build_uint32( pInMsg->pData, 4 );
// 1499 
// 1500     req.IdDuration = BUILD_UINT16( pInMsg->pData[4], pInMsg->pData[5] );
// 1501 
// 1502     return ( pInterPANCBs->pfnIdentifyReq( &(pInMsg->msg->srcAddr), &req ) );
// 1503   }
// 1504 
// 1505   return ( ZSuccess );
// 1506 }
// 1507 
// 1508 /*********************************************************************
// 1509  * @fn      bdbTL_ProcessInCmd_ResetToFNReq
// 1510  *
// 1511  * @brief   Process in the received Reset to Factory New Request command.
// 1512  *
// 1513  * @param   pInMsg - pointer to the incoming message
// 1514  *
// 1515  * @return  ZStatus_t
// 1516  */
// 1517 static ZStatus_t bdbTL_ProcessInCmd_ResetToFNReq( zclIncoming_t *pInMsg )
// 1518 {
// 1519   if ( pInterPANCBs->pfnResetToFNReq )
// 1520   {
// 1521     bdbTLResetToFNReq_t req;
// 1522 
// 1523     req.transID = zcl_build_uint32( pInMsg->pData, 4 );
// 1524 
// 1525     return ( pInterPANCBs->pfnResetToFNReq( &(pInMsg->msg->srcAddr), &req ) );
// 1526   }
// 1527 
// 1528   return ( ZSuccess );
// 1529 }
// 1530 
// 1531 /*********************************************************************
// 1532  * @fn      bdbTL_ProcessInCmd_NwkStartReq
// 1533  *
// 1534  * @brief   Process in the received Network Start Request command.
// 1535  *
// 1536  * @param   pInMsg - pointer to the incoming message
// 1537  *
// 1538  * @return  ZStatus_t
// 1539  */
// 1540 static ZStatus_t bdbTL_ProcessInCmd_NwkStartReq( zclIncoming_t *pInMsg )
// 1541 {
// 1542   uint8 status = ZSuccess;
// 1543 
// 1544   if ( pInterPANCBs->pfnNwkStartReq )
// 1545   {
// 1546     bdbTLNwkStartReq_t *pReq;
// 1547 
// 1548     pReq = (bdbTLNwkStartReq_t *)zcl_mem_alloc( sizeof( bdbTLNwkStartReq_t ) );
// 1549     if ( pReq )
// 1550     {
// 1551       uint8 *pBuf = pInMsg->pData;
// 1552 
// 1553       pReq->transID = zcl_build_uint32( pBuf, 4 );
// 1554       pBuf += 4;
// 1555 
// 1556       zcl_cpyExtAddr( pReq->nwkParams.extendedPANID, pBuf );
// 1557       pBuf += Z_EXTADDR_LEN;
// 1558 
// 1559       pReq->nwkParams.keyIndex = *pBuf++;
// 1560 
// 1561       zcl_memcpy( pReq->nwkParams.nwkKey, pBuf, SEC_KEY_LEN );
// 1562       pBuf += SEC_KEY_LEN;
// 1563 
// 1564       pReq->nwkParams.logicalChannel = *pBuf++;
// 1565 
// 1566       pReq->nwkParams.panId = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1567       pBuf += 2;
// 1568 
// 1569       pReq->nwkParams.nwkAddr = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1570       pBuf += 2;
// 1571 
// 1572       pReq->nwkParams.grpIDsBegin = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1573       pBuf += 2;
// 1574 
// 1575       pReq->nwkParams.grpIDsEnd = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1576       pBuf += 2;
// 1577 
// 1578       pReq->nwkParams.freeNwkAddrBegin = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1579       pBuf += 2;
// 1580 
// 1581       pReq->nwkParams.freeNwkAddrEnd = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1582       pBuf += 2;
// 1583 
// 1584       pReq->nwkParams.freeGrpIDBegin = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1585       pBuf += 2;
// 1586 
// 1587       pReq->nwkParams.freeGrpIDEnd = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1588       pBuf += 2;
// 1589 
// 1590       zcl_cpyExtAddr( pReq->initiatorIeeeAddr, pBuf );
// 1591       pBuf += Z_EXTADDR_LEN;
// 1592 
// 1593       pReq->initiatorNwkAddr = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1594 
// 1595       status = pInterPANCBs->pfnNwkStartReq( &(pInMsg->msg->srcAddr), pReq,
// 1596                                              pInMsg->hdr.transSeqNum );
// 1597 
// 1598       zcl_mem_free( pReq );
// 1599     }
// 1600   }
// 1601 
// 1602   return ( status );
// 1603 }
// 1604 
// 1605 /*********************************************************************
// 1606  * @fn      bdbTL_ParseInCmd_NwkJoinReq
// 1607  *
// 1608  * @brief   Parse in the received Network Router/End Device Join Request command.
// 1609  *
// 1610  * @param   pBuf - pointer to the incoming message
// 1611  *
// 1612  * @return  void
// 1613  */
// 1614 static void bdbTL_ParseInCmd_NwkJoinReq( uint8 *pBuf, bdbTLNwkJoinReq_t *pReq )
// 1615 {
// 1616   pReq->transID = zcl_build_uint32( pBuf, 4 );
// 1617   pBuf += 4;
// 1618 
// 1619   zcl_cpyExtAddr( pReq->nwkParams.extendedPANID, pBuf );
// 1620   pBuf += Z_EXTADDR_LEN;
// 1621 
// 1622   pReq->nwkParams.keyIndex = *pBuf++;
// 1623 
// 1624   zcl_memcpy( pReq->nwkParams.nwkKey, pBuf, SEC_KEY_LEN );
// 1625   pBuf += SEC_KEY_LEN;
// 1626 
// 1627   pReq->nwkUpdateId = *pBuf++;
// 1628   pReq->nwkParams.logicalChannel = *pBuf++;
// 1629 
// 1630   pReq->nwkParams.panId = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1631   pBuf += 2;
// 1632 
// 1633   pReq->nwkParams.nwkAddr = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1634   pBuf += 2;
// 1635 
// 1636   pReq->nwkParams.grpIDsBegin = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1637   pBuf += 2;
// 1638 
// 1639   pReq->nwkParams.grpIDsEnd = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1640   pBuf += 2;
// 1641 
// 1642   pReq->nwkParams.freeNwkAddrBegin = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1643   pBuf += 2;
// 1644 
// 1645   pReq->nwkParams.freeNwkAddrEnd = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1646   pBuf += 2;
// 1647 
// 1648   pReq->nwkParams.freeGrpIDBegin = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1649   pBuf += 2;
// 1650 
// 1651   pReq->nwkParams.freeGrpIDEnd = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1652 }
// 1653 
// 1654 /*********************************************************************
// 1655  * @fn      bdbTL_ProcessInCmd_NwkJoinRtrReq
// 1656  *
// 1657  * @brief   Process in the received Network Join Router Request command.
// 1658  *
// 1659  * @param   pInMsg - pointer to the incoming message
// 1660  *
// 1661  * @return  ZStatus_t
// 1662  */
// 1663 static ZStatus_t bdbTL_ProcessInCmd_NwkJoinRtrReq( zclIncoming_t *pInMsg )
// 1664 {
// 1665   ZStatus_t status = ZSuccess;
// 1666 
// 1667   if ( pInterPANCBs->pfnNwkJoinRtrReq )
// 1668   {
// 1669     bdbTLNwkJoinReq_t *pReq;
// 1670 
// 1671     pReq = (bdbTLNwkJoinReq_t *)zcl_mem_alloc( sizeof( bdbTLNwkJoinReq_t ) );
// 1672     if ( pReq )
// 1673     {
// 1674       bdbTL_ParseInCmd_NwkJoinReq( pInMsg->pData, pReq );
// 1675 
// 1676       status = pInterPANCBs->pfnNwkJoinRtrReq( &(pInMsg->msg->srcAddr), pReq,
// 1677                                                pInMsg->hdr.transSeqNum  );
// 1678       zcl_mem_free( pReq );
// 1679     }
// 1680   }
// 1681 
// 1682   return ( status );
// 1683 }
// 1684 
// 1685 /*********************************************************************
// 1686  * @fn      bdbTL_ProcessInCmd_NwkJoinEDReq
// 1687  *
// 1688  * @brief   Process in the received Network Join End Device  Request command.
// 1689  *
// 1690  * @param   pInMsg - pointer to the incoming message
// 1691  *
// 1692  * @return  ZStatus_t
// 1693  */
// 1694 static ZStatus_t bdbTL_ProcessInCmd_NwkJoinEDReq( zclIncoming_t *pInMsg )
// 1695 {
// 1696   ZStatus_t status = ZSuccess;
// 1697 
// 1698   if ( pInterPANCBs->pfnNwkJoinEDReq )
// 1699   {
// 1700     bdbTLNwkJoinReq_t *pReq;
// 1701 
// 1702     pReq = (bdbTLNwkJoinReq_t *)zcl_mem_alloc( sizeof( bdbTLNwkJoinReq_t ) );
// 1703     if ( pReq )
// 1704     {
// 1705       bdbTL_ParseInCmd_NwkJoinReq( pInMsg->pData, pReq );
// 1706 
// 1707       status = pInterPANCBs->pfnNwkJoinEDReq( &(pInMsg->msg->srcAddr), pReq,
// 1708                                               pInMsg->hdr.transSeqNum );
// 1709       zcl_mem_free( pReq );
// 1710     }
// 1711   }
// 1712 
// 1713   return ( status );
// 1714 }
// 1715 
// 1716 /*********************************************************************
// 1717  * @fn      bdbTL_ProcessInCmd_NwkUpdateReq
// 1718  *
// 1719  * @brief   Process in the received Network Update Request command.
// 1720  *
// 1721  * @param   pInMsg - pointer to the incoming message
// 1722  *
// 1723  * @return  ZStatus_t
// 1724  */
// 1725 static ZStatus_t bdbTL_ProcessInCmd_NwkUpdateReq( zclIncoming_t *pInMsg )
// 1726 {
// 1727   ZStatus_t status = ZSuccess;
// 1728 
// 1729   if ( pInterPANCBs->pfnNwkUpdateReq )
// 1730   {
// 1731     bdbTLNwkUpdateReq_t *pReq;
// 1732 
// 1733     pReq = (bdbTLNwkUpdateReq_t *)zcl_mem_alloc( sizeof( bdbTLNwkUpdateReq_t ) );
// 1734     if ( pReq )
// 1735     {
// 1736       uint8 *pBuf = pInMsg->pData;
// 1737 
// 1738       pReq->transID = zcl_build_uint32( pBuf, 4 );
// 1739       pBuf += 4;
// 1740 
// 1741       zcl_cpyExtAddr( pReq->extendedPANID, pBuf );
// 1742       pBuf += Z_EXTADDR_LEN;
// 1743 
// 1744       pReq->nwkUpdateId = *pBuf++;
// 1745       pReq->logicalChannel = *pBuf++;
// 1746 
// 1747       pReq->PANID = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1748       pBuf += 2;
// 1749 
// 1750       pReq->nwkAddr = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1751       pBuf += 2;
// 1752 
// 1753       status = pInterPANCBs->pfnNwkUpdateReq( &(pInMsg->msg->srcAddr), pReq );
// 1754 
// 1755       zcl_mem_free( pReq );
// 1756     }
// 1757   }
// 1758 
// 1759   return ( status );
// 1760 }
// 1761 
// 1762 /*********************************************************************
// 1763  * @fn      bdbTL_ProcessInCmd_ScanRsp
// 1764  *
// 1765  * @brief   Process in the received Scan Response command.
// 1766  *
// 1767  * @param   pInMsg - pointer to the incoming message
// 1768  *
// 1769  * @return  ZStatus_t
// 1770  */
// 1771 static ZStatus_t bdbTL_ProcessInCmd_ScanRsp( zclIncoming_t *pInMsg )
// 1772 {
// 1773   ZStatus_t status = ZSuccess;
// 1774 
// 1775   if ( pInterPANCBs->pfnScanRsp )
// 1776   {
// 1777     bdbTLScanRsp_t *pRsp;
// 1778 
// 1779     pRsp = (bdbTLScanRsp_t *)zcl_mem_alloc( sizeof( bdbTLScanRsp_t ) );
// 1780     if ( pRsp )
// 1781     {
// 1782       uint8 *pBuf = pInMsg->pData;
// 1783 
// 1784       zcl_memset( pRsp, 0, sizeof( bdbTLScanRsp_t ) );
// 1785 
// 1786       pRsp->transID = zcl_build_uint32( pBuf, 4 );
// 1787       pBuf += 4;
// 1788 
// 1789       pRsp->rssiCorrection = *pBuf++;
// 1790       pRsp->zInfo.zInfoByte = *pBuf++;
// 1791       pRsp->touchLinkInfo.touchLinkInfoByte = *pBuf++;
// 1792 
// 1793       pRsp->keyBitmask = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1794       pBuf += 2;
// 1795 
// 1796       pRsp->responseID = zcl_build_uint32( pBuf, 4 );
// 1797       pBuf += 4;
// 1798 
// 1799       zcl_cpyExtAddr( pRsp->extendedPANID, pBuf );
// 1800       pBuf += Z_EXTADDR_LEN;
// 1801 
// 1802       pRsp->nwkUpdateId = *pBuf++;
// 1803       pRsp->logicalChannel = *pBuf++;
// 1804 
// 1805       pRsp->PANID = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1806       pBuf += 2;
// 1807 
// 1808       pRsp->nwkAddr = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1809       pBuf += 2;
// 1810 
// 1811       pRsp->numSubDevices = *pBuf++;
// 1812       pRsp->totalGrpIDs = *pBuf++;
// 1813 
// 1814       if ( pRsp->numSubDevices == 1 )
// 1815       {
// 1816         pRsp->deviceInfo.endpoint = *pBuf++;
// 1817 
// 1818         pRsp->deviceInfo.profileID = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1819         pBuf += 2;
// 1820 
// 1821         pRsp->deviceInfo.deviceID = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1822         pBuf += 2;
// 1823 
// 1824         pRsp->deviceInfo.version = *pBuf++;
// 1825         pRsp->deviceInfo.grpIdCnt = *pBuf;
// 1826       }
// 1827 
// 1828       status = pInterPANCBs->pfnScanRsp( &(pInMsg->msg->srcAddr), pRsp );
// 1829       zcl_mem_free( pRsp );
// 1830     }
// 1831   }
// 1832 
// 1833   return ( status );
// 1834 }
// 1835 
// 1836 /*********************************************************************
// 1837  * @fn      bdbTL_ProcessInCmd_DeviceInfoRsp
// 1838  *
// 1839  * @brief   Process in the received Device Information Response command.
// 1840  *
// 1841  * @param   pInMsg - pointer to the incoming message
// 1842  *
// 1843  * @return  ZStatus_t
// 1844  */
// 1845 static ZStatus_t bdbTL_ProcessInCmd_DeviceInfoRsp( zclIncoming_t *pInMsg )
// 1846 {
// 1847   ZStatus_t status = ZSuccess;
// 1848 
// 1849   if ( pInterPANCBs->pfnDeviceInfoRsp )
// 1850   {
// 1851     bdbTLDeviceInfoRsp_t *pRsp;
// 1852     uint8 cnt = pInMsg->pData[TOUCHLINK_CMDLEN_DEVICE_INFO_RSP-1];
// 1853     uint8 rspLen = sizeof( bdbTLDeviceInfoRsp_t ) + ( cnt * sizeof( devInfoRec_t ) );
// 1854 
// 1855     pRsp = (bdbTLDeviceInfoRsp_t *)zcl_mem_alloc( rspLen );
// 1856     if ( pRsp )
// 1857     {
// 1858       uint8 *pBuf = pInMsg->pData;
// 1859       uint8 i;
// 1860 
// 1861       pRsp->transID = zcl_build_uint32( pBuf, 4 );
// 1862       pBuf += 4;
// 1863 
// 1864       pRsp->numSubDevices = *pBuf++;
// 1865       pRsp->startIndex = *pBuf++;
// 1866       pRsp->cnt = *pBuf++;
// 1867 
// 1868       for ( i = 0; i < cnt; i++ )
// 1869       {
// 1870         devInfoRec_t *pRec = &(pRsp->devInfoRec[i]);
// 1871 
// 1872         zcl_cpyExtAddr( pRec->ieeeAddr, pBuf );
// 1873         pBuf += Z_EXTADDR_LEN;
// 1874 
// 1875         pRec->deviceInfo.endpoint = *pBuf++;
// 1876 
// 1877         pRec->deviceInfo.profileID = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1878         pBuf += 2;
// 1879 
// 1880         pRec->deviceInfo.deviceID = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1881         pBuf += 2;
// 1882 
// 1883         pRec->deviceInfo.version = *pBuf++;
// 1884         pRec->deviceInfo.grpIdCnt = *pBuf++;
// 1885 
// 1886         pRec->sort = *pBuf++;
// 1887       }
// 1888 
// 1889       status = pInterPANCBs->pfnDeviceInfoRsp( &(pInMsg->msg->srcAddr), pRsp );
// 1890 
// 1891       zcl_mem_free( pRsp );
// 1892     }
// 1893   }
// 1894 
// 1895   return ( status );
// 1896 }
// 1897 
// 1898 /*********************************************************************
// 1899  * @fn      bdbTL_ProcessInCmd_NwkStartRsp
// 1900  *
// 1901  * @brief   Process in the received Network Start Response command.
// 1902  *
// 1903  * @param   pInMsg - pointer to the incoming message
// 1904  *
// 1905  * @return  ZStatus_t
// 1906  */
// 1907 static ZStatus_t bdbTL_ProcessInCmd_NwkStartRsp( zclIncoming_t *pInMsg )
// 1908 {
// 1909   ZStatus_t status = ZSuccess;
// 1910 
// 1911   if ( pInterPANCBs->pfnNwkStartRsp )
// 1912   {
// 1913     bdbTLNwkStartRsp_t *pRsp;
// 1914 
// 1915     pRsp = (bdbTLNwkStartRsp_t *)zcl_mem_alloc( sizeof( bdbTLNwkStartRsp_t ) );
// 1916     if ( pRsp )
// 1917     {
// 1918       uint8 *pBuf = pInMsg->pData;
// 1919 
// 1920       pRsp->transID = zcl_build_uint32( pBuf, 4 );
// 1921       pBuf += 4;
// 1922 
// 1923       pRsp->status = *pBuf++;
// 1924 
// 1925       zcl_cpyExtAddr( pRsp->extendedPANID, pBuf );
// 1926       pBuf += Z_EXTADDR_LEN;
// 1927 
// 1928       pRsp->nwkUpdateId = *pBuf++;
// 1929       pRsp->logicalChannel = *pBuf++;
// 1930 
// 1931       pRsp->panId = BUILD_UINT16( pBuf[0], pBuf[1] );
// 1932 
// 1933       status = pInterPANCBs->pfnNwkStartRsp( &(pInMsg->msg->srcAddr), pRsp );
// 1934 
// 1935       zcl_mem_free( pRsp );
// 1936     }
// 1937   }
// 1938 
// 1939   return ( status );
// 1940 }
// 1941 
// 1942 /*********************************************************************
// 1943  * @fn      bdbTL_ProcessInCmd_NwkJoinRtrRsp
// 1944  *
// 1945  * @brief   Process in the received Network Join Router Response command.
// 1946  *
// 1947  * @param   pInMsg - pointer to the incoming message
// 1948  *
// 1949  * @return  ZStatus_t
// 1950  */
// 1951 static ZStatus_t bdbTL_ProcessInCmd_NwkJoinRtrRsp( zclIncoming_t *pInMsg )
// 1952 {
// 1953   if ( pInterPANCBs->pfnNwkJoinRtrRsp )
// 1954   {
// 1955     bdbTLNwkJoinRsp_t rsp;
// 1956 
// 1957     rsp.transID = zcl_build_uint32( pInMsg->pData, 4 );
// 1958 
// 1959     rsp.status = pInMsg->pData[4];
// 1960 
// 1961     return ( pInterPANCBs->pfnNwkJoinRtrRsp( &(pInMsg->msg->srcAddr), &rsp ) );
// 1962   }
// 1963 
// 1964   return ( ZSuccess );
// 1965 }
// 1966 
// 1967 
// 1968 /*********************************************************************
// 1969  * @fn      bdbTL_ProcessInCmd_NwkJoinEDRsp
// 1970  *
// 1971  * @brief   Process in the received Network Join End Device Response command.
// 1972  *
// 1973  * @param   pInMsg - pointer to the incoming message
// 1974  *
// 1975  * @return  ZStatus_t
// 1976  */
// 1977 static ZStatus_t bdbTL_ProcessInCmd_NwkJoinEDRsp( zclIncoming_t *pInMsg )
// 1978 {
// 1979   if ( pInterPANCBs->pfnNwkJoinEDRsp )
// 1980   {
// 1981     bdbTLNwkJoinRsp_t rsp;
// 1982 
// 1983     rsp.transID = zcl_build_uint32( pInMsg->pData, 4 );
// 1984 
// 1985     rsp.status = pInMsg->pData[4];
// 1986 
// 1987     return ( pInterPANCBs->pfnNwkJoinEDRsp( &(pInMsg->msg->srcAddr), &rsp ) );
// 1988   }
// 1989 
// 1990   return ( ZSuccess );
// 1991 }
// 1992 
// 1993 #endif // BDB_TL_TARGET || BDB_TL_INITIATOR
// 1994 
// 1995 /********************************************************************************************
// 1996 *********************************************************************************************/
// 
//
// 
//
//
//Errors: none
//Warnings: none
